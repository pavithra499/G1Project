/*
 *  This file is part of the Jikes RVM project (http://jikesrvm.org).
 *
 *  This file is licensed to You under the Eclipse Public License (EPL);
 *  You may not use this file except in compliance with the License. You
 *  may obtain a copy of the License at
 *
 *      http://www.opensource.org/licenses/eclipse-1.0.php
 *
 *  See the COPYRIGHT.txt file distributed with this work for information
 *  regarding copyright ownership.
 */

##NEW_FILE_STARTS_HERE ArchInstructionFormat.java##

/*
 *  This file is part of the Jikes RVM project (http://jikesrvm.org).
 *
 *  This file is licensed to You under the Eclipse Public License (EPL);
 *  You may not use this file except in compliance with the License. You
 *  may obtain a copy of the License at
 *
 *      http://www.opensource.org/licenses/eclipse-1.0.php
 *
 *  See the COPYRIGHT.txt file distributed with this work for information
 *  regarding copyright ownership.
 */
package org.jikesrvm.compilers.opt.ir.ppc;

import org.jikesrvm.VM;
import org.jikesrvm.compilers.opt.OptimizingCompilerException;
import org.jikesrvm.compilers.opt.ir.operand.*;
import org.jikesrvm.compilers.opt.ir.InstructionFormat;
import org.jikesrvm.compilers.opt.ir.Operator;

/**
 * Abstract parent class of all InstructionFormat classes.<p>
 *
 * The header comment for {@link org.jikesrvm.compilers.opt.ir.Instruction} contains
 * an explanation of the role of InstructionFormats in the
 * opt compiler's IR.<p>
 *
 * NOTE: We currently only support a subset of cases of variable operands.
 * <ul>
 *  <li>instructions with 0+ defs, 0+ def/uses, 0+ uses, and a variable number of uses
 *  <li>instructions with 0+ defs and variable number of defs.
 * Variable number of def/uses and variable number of defs with non-zero
 * number of def/uses or uses are not supported (and will generate java code
 * for the instruction format that doesn't compile).  Fully general support would
 * be a pain in the butt and since it currently isn't required, we don't do it.
 * </ul>
 * <p>
 *
 * THIS FILE IS MACHINE_GENERATED. DO NOT EDIT.
 * See ArchInstructionFormats.template, InstructionFormatList.dat,
 * OperatorList.dat, etc
 */
public abstract class ArchInstructionFormat extends InstructionFormat {

  static {
    if (MIN_OPERAND_ARRAY_LENGTH != 5) {
      throw new Error("Disagreement between architecture and common instruction formats on minimum operands");
    }
  }

  /** Typecode for the MIR_Load InstructionFormat */
  public static final byte MIR_Load_format = ARCH_INDEPENDENT_INSTR_FORMAT_END_format+0;
  /** Typecode for the MIR_LoadUpdate InstructionFormat */
  public static final byte MIR_LoadUpdate_format = ARCH_INDEPENDENT_INSTR_FORMAT_END_format+1;
  /** Typecode for the MIR_Store InstructionFormat */
  public static final byte MIR_Store_format = ARCH_INDEPENDENT_INSTR_FORMAT_END_format+2;
  /** Typecode for the MIR_StoreUpdate InstructionFormat */
  public static final byte MIR_StoreUpdate_format = ARCH_INDEPENDENT_INSTR_FORMAT_END_format+3;
  /** Typecode for the MIR_CacheOp InstructionFormat */
  public static final byte MIR_CacheOp_format = ARCH_INDEPENDENT_INSTR_FORMAT_END_format+4;
  /** Typecode for the MIR_Move InstructionFormat */
  public static final byte MIR_Move_format = ARCH_INDEPENDENT_INSTR_FORMAT_END_format+5;
  /** Typecode for the MIR_Trap InstructionFormat */
  public static final byte MIR_Trap_format = ARCH_INDEPENDENT_INSTR_FORMAT_END_format+6;
  /** Typecode for the MIR_DataInt InstructionFormat */
  public static final byte MIR_DataInt_format = ARCH_INDEPENDENT_INSTR_FORMAT_END_format+7;
  /** Typecode for the MIR_DataLabel InstructionFormat */
  public static final byte MIR_DataLabel_format = ARCH_INDEPENDENT_INSTR_FORMAT_END_format+8;
  /** Typecode for the MIR_Branch InstructionFormat */
  public static final byte MIR_Branch_format = ARCH_INDEPENDENT_INSTR_FORMAT_END_format+9;
  /** Typecode for the MIR_CondBranch InstructionFormat */
  public static final byte MIR_CondBranch_format = ARCH_INDEPENDENT_INSTR_FORMAT_END_format+10;
  /** Typecode for the MIR_CondBranch2 InstructionFormat */
  public static final byte MIR_CondBranch2_format = ARCH_INDEPENDENT_INSTR_FORMAT_END_format+11;
  /** Typecode for the MIR_Call InstructionFormat */
  public static final byte MIR_Call_format = ARCH_INDEPENDENT_INSTR_FORMAT_END_format+12;
  /** Typecode for the MIR_CondCall InstructionFormat */
  public static final byte MIR_CondCall_format = ARCH_INDEPENDENT_INSTR_FORMAT_END_format+13;
  /** Typecode for the MIR_Return InstructionFormat */
  public static final byte MIR_Return_format = ARCH_INDEPENDENT_INSTR_FORMAT_END_format+14;
  /** Typecode for the MIR_Empty InstructionFormat */
  public static final byte MIR_Empty_format = ARCH_INDEPENDENT_INSTR_FORMAT_END_format+15;
  /** Typecode for the MIR_Nullary InstructionFormat */
  public static final byte MIR_Nullary_format = ARCH_INDEPENDENT_INSTR_FORMAT_END_format+16;
  /** Typecode for the MIR_Unary InstructionFormat */
  public static final byte MIR_Unary_format = ARCH_INDEPENDENT_INSTR_FORMAT_END_format+17;
  /** Typecode for the MIR_Binary InstructionFormat */
  public static final byte MIR_Binary_format = ARCH_INDEPENDENT_INSTR_FORMAT_END_format+18;
  /** Typecode for the MIR_Condition InstructionFormat */
  public static final byte MIR_Condition_format = ARCH_INDEPENDENT_INSTR_FORMAT_END_format+19;
  /** Typecode for the MIR_Ternary InstructionFormat */
  public static final byte MIR_Ternary_format = ARCH_INDEPENDENT_INSTR_FORMAT_END_format+20;
  /** Typecode for the MIR_LowTableSwitch InstructionFormat */
  public static final byte MIR_LowTableSwitch_format = ARCH_INDEPENDENT_INSTR_FORMAT_END_format+21;
  /** Typecode for the MIR_RotateAndMask InstructionFormat */
  public static final byte MIR_RotateAndMask_format = ARCH_INDEPENDENT_INSTR_FORMAT_END_format+22;

  /** Shared traits for operators of the MIR_Load InstructionFormat */
  public static final int MIR_Load_traits = Operator.none;
  /** Shared traits for operators of the MIR_LoadUpdate InstructionFormat */
  public static final int MIR_LoadUpdate_traits = Operator.none;
  /** Shared traits for operators of the MIR_Store InstructionFormat */
  public static final int MIR_Store_traits = Operator.none;
  /** Shared traits for operators of the MIR_StoreUpdate InstructionFormat */
  public static final int MIR_StoreUpdate_traits = Operator.none;
  /** Shared traits for operators of the MIR_CacheOp InstructionFormat */
  public static final int MIR_CacheOp_traits = Operator.none;
  /** Shared traits for operators of the MIR_Move InstructionFormat */
  public static final int MIR_Move_traits = Operator.none;
  /** Shared traits for operators of the MIR_Trap InstructionFormat */
  public static final int MIR_Trap_traits = Operator.none;
  /** Shared traits for operators of the MIR_DataInt InstructionFormat */
  public static final int MIR_DataInt_traits = Operator.none;
  /** Shared traits for operators of the MIR_DataLabel InstructionFormat */
  public static final int MIR_DataLabel_traits = Operator.none;
  /** Shared traits for operators of the MIR_Branch InstructionFormat */
  public static final int MIR_Branch_traits = Operator.none;
  /** Shared traits for operators of the MIR_CondBranch InstructionFormat */
  public static final int MIR_CondBranch_traits = Operator.none;
  /** Shared traits for operators of the MIR_CondBranch2 InstructionFormat */
  public static final int MIR_CondBranch2_traits = Operator.none;
  /** Shared traits for operators of the MIR_Call InstructionFormat */
  public static final int MIR_Call_traits = Operator.varUses;
  /** Shared traits for operators of the MIR_CondCall InstructionFormat */
  public static final int MIR_CondCall_traits = Operator.varUses;
  /** Shared traits for operators of the MIR_Return InstructionFormat */
  public static final int MIR_Return_traits = Operator.none;
  /** Shared traits for operators of the MIR_Empty InstructionFormat */
  public static final int MIR_Empty_traits = Operator.none;
  /** Shared traits for operators of the MIR_Nullary InstructionFormat */
  public static final int MIR_Nullary_traits = Operator.none;
  /** Shared traits for operators of the MIR_Unary InstructionFormat */
  public static final int MIR_Unary_traits = Operator.none;
  /** Shared traits for operators of the MIR_Binary InstructionFormat */
  public static final int MIR_Binary_traits = Operator.none;
  /** Shared traits for operators of the MIR_Condition InstructionFormat */
  public static final int MIR_Condition_traits = Operator.none;
  /** Shared traits for operators of the MIR_Ternary InstructionFormat */
  public static final int MIR_Ternary_traits = Operator.none;
  /** Shared traits for operators of the MIR_LowTableSwitch InstructionFormat */
  public static final int MIR_LowTableSwitch_traits = Operator.varUses;
  /** Shared traits for operators of the MIR_RotateAndMask InstructionFormat */
  public static final int MIR_RotateAndMask_traits = Operator.none;

}

##NEW_FILE_STARTS_HERE MIR_Load.java##

/*
 * THIS FILE IS MACHINE_GENERATED. DO NOT EDIT.
 * See InstructionFormats.template, InstructionFormatList.dat,
 * OperatorList.dat, etc.
 */

package org.jikesrvm.compilers.opt.ir.ppc;

import org.jikesrvm.Configuration;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCConditionOperand;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCTrapOperand;
import org.jikesrvm.compilers.opt.ir.operand.*;
import org.jikesrvm.compilers.opt.ir.Instruction;
import org.jikesrvm.compilers.opt.ir.Operator;

/**
 * The MIR_Load InstructionFormat class.
 *
 * The header comment for {@link Instruction} contains
 * an explanation of the role of InstructionFormats in the
 * opt compiler's IR.
 */
@SuppressWarnings("unused")  // Machine generated code is never 100% clean
public final class MIR_Load extends ArchInstructionFormat {
  /**
   * InstructionFormat identification method for MIR_Load.
   * @param i an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         instruction is MIR_Load or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Instruction i) {
    return conforms(i.operator());
  }
  /**
   * InstructionFormat identification method for MIR_Load.
   * @param o an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         operator is MIR_Load or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Operator o) {
    return o.format == MIR_Load_format;
  }

  /**
   * Get the operand called Result from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Result
   */
  public static RegisterOperand getResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Load");
    return (RegisterOperand) i.getOperand(0);
  }
  /**
   * Get the operand called Result from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Result
   */
  public static RegisterOperand getClearResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Load");
    return (RegisterOperand) i.getClearOperand(0);
  }
  /**
   * Set the operand called Result in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Result the operand to store
   */
  public static void setResult(Instruction i, RegisterOperand Result) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Load");
    i.putOperand(0, Result);
  }
  /**
   * Return the index of the operand called Result
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Result
   *         in the argument instruction
   */
  public static int indexOfResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Load");
    return 0;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Result?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Result or <code>false</code>
   *         if it does not.
   */
  public static boolean hasResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Load");
    return i.getOperand(0) != null;
  }

  /**
   * Get the operand called Address from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Address
   */
  public static RegisterOperand getAddress(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Load");
    return (RegisterOperand) i.getOperand(1);
  }
  /**
   * Get the operand called Address from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Address
   */
  public static RegisterOperand getClearAddress(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Load");
    return (RegisterOperand) i.getClearOperand(1);
  }
  /**
   * Set the operand called Address in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Address the operand to store
   */
  public static void setAddress(Instruction i, RegisterOperand Address) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Load");
    i.putOperand(1, Address);
  }
  /**
   * Return the index of the operand called Address
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Address
   *         in the argument instruction
   */
  public static int indexOfAddress(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Load");
    return 1;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Address?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Address or <code>false</code>
   *         if it does not.
   */
  public static boolean hasAddress(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Load");
    return i.getOperand(1) != null;
  }

  /**
   * Get the operand called Offset from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Offset
   */
  public static Operand getOffset(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Load");
    return (Operand) i.getOperand(2);
  }
  /**
   * Get the operand called Offset from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Offset
   */
  public static Operand getClearOffset(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Load");
    return (Operand) i.getClearOperand(2);
  }
  /**
   * Set the operand called Offset in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Offset the operand to store
   */
  public static void setOffset(Instruction i, Operand Offset) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Load");
    i.putOperand(2, Offset);
  }
  /**
   * Return the index of the operand called Offset
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Offset
   *         in the argument instruction
   */
  public static int indexOfOffset(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Load");
    return 2;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Offset?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Offset or <code>false</code>
   *         if it does not.
   */
  public static boolean hasOffset(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Load");
    return i.getOperand(2) != null;
  }

  /**
   * Get the operand called Location from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Location
   */
  public static LocationOperand getLocation(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Load");
    return (LocationOperand) i.getOperand(3);
  }
  /**
   * Get the operand called Location from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Location
   */
  public static LocationOperand getClearLocation(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Load");
    return (LocationOperand) i.getClearOperand(3);
  }
  /**
   * Set the operand called Location in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Location the operand to store
   */
  public static void setLocation(Instruction i, LocationOperand Location) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Load");
    i.putOperand(3, Location);
  }
  /**
   * Return the index of the operand called Location
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Location
   *         in the argument instruction
   */
  public static int indexOfLocation(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Load");
    return 3;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Location?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Location or <code>false</code>
   *         if it does not.
   */
  public static boolean hasLocation(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Load");
    return i.getOperand(3) != null;
  }

  /**
   * Get the operand called Guard from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Guard
   */
  public static Operand getGuard(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Load");
    return (Operand) i.getOperand(4);
  }
  /**
   * Get the operand called Guard from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Guard
   */
  public static Operand getClearGuard(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Load");
    return (Operand) i.getClearOperand(4);
  }
  /**
   * Set the operand called Guard in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Guard the operand to store
   */
  public static void setGuard(Instruction i, Operand Guard) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Load");
    i.putOperand(4, Guard);
  }
  /**
   * Return the index of the operand called Guard
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Guard
   *         in the argument instruction
   */
  public static int indexOfGuard(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Load");
    return 4;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Guard?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Guard or <code>false</code>
   *         if it does not.
   */
  public static boolean hasGuard(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Load");
    return i.getOperand(4) != null;
  }


  /**
   * Create an instruction of the MIR_Load instruction format.
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Address the instruction's Address operand
   * @param Offset the instruction's Offset operand
   * @param Location the instruction's Location operand
   * @param Guard the instruction's Guard operand
   * @return the newly created MIR_Load instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Result
                   , RegisterOperand Address
                   , Operand Offset
                   , LocationOperand Location
                   , Operand Guard
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Load");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Result);
    i.putOperand(1, Address);
    i.putOperand(2, Offset);
    i.putOperand(3, Location);
    i.putOperand(4, Guard);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_Load instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Address the instruction's Address operand
   * @param Offset the instruction's Offset operand
   * @param Location the instruction's Location operand
   * @param Guard the instruction's Guard operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Result
                   , RegisterOperand Address
                   , Operand Offset
                   , LocationOperand Location
                   , Operand Guard
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Load");
    i.changeOperatorTo(o);
    i.putOperand(0, Result);
    i.putOperand(1, Address);
    i.putOperand(2, Offset);
    i.putOperand(3, Location);
    i.putOperand(4, Guard);
    return i;
  }
  /**
   * Create an instruction of the MIR_Load instruction format.
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Address the instruction's Address operand
   * @param Offset the instruction's Offset operand
   * @param Location the instruction's Location operand
   * @return the newly created MIR_Load instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Result
                   , RegisterOperand Address
                   , Operand Offset
                   , LocationOperand Location
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Load");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Result);
    i.putOperand(1, Address);
    i.putOperand(2, Offset);
    i.putOperand(3, Location);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_Load instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Address the instruction's Address operand
   * @param Offset the instruction's Offset operand
   * @param Location the instruction's Location operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Result
                   , RegisterOperand Address
                   , Operand Offset
                   , LocationOperand Location
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Load");
    i.changeOperatorTo(o);
    i.putOperand(0, Result);
    i.putOperand(1, Address);
    i.putOperand(2, Offset);
    i.putOperand(3, Location);
    i.putOperand(4, null);
    return i;
  }
  /**
   * Create an instruction of the MIR_Load instruction format.
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Address the instruction's Address operand
   * @param Offset the instruction's Offset operand
   * @param Guard the instruction's Guard operand
   * @return the newly created MIR_Load instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Result
                   , RegisterOperand Address
                   , Operand Offset
                   , Operand Guard
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Load");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Result);
    i.putOperand(1, Address);
    i.putOperand(2, Offset);
    i.putOperand(4, Guard);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_Load instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Address the instruction's Address operand
   * @param Offset the instruction's Offset operand
   * @param Guard the instruction's Guard operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Result
                   , RegisterOperand Address
                   , Operand Offset
                   , Operand Guard
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Load");
    i.changeOperatorTo(o);
    i.putOperand(0, Result);
    i.putOperand(1, Address);
    i.putOperand(2, Offset);
    i.putOperand(3, null);
    i.putOperand(4, Guard);
    return i;
  }
  /**
   * Create an instruction of the MIR_Load instruction format.
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Address the instruction's Address operand
   * @param Offset the instruction's Offset operand
   * @return the newly created MIR_Load instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Result
                   , RegisterOperand Address
                   , Operand Offset
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Load");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Result);
    i.putOperand(1, Address);
    i.putOperand(2, Offset);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_Load instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Address the instruction's Address operand
   * @param Offset the instruction's Offset operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Result
                   , RegisterOperand Address
                   , Operand Offset
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Load");
    i.changeOperatorTo(o);
    i.putOperand(0, Result);
    i.putOperand(1, Address);
    i.putOperand(2, Offset);
    i.putOperand(3, null);
    i.putOperand(4, null);
    return i;
  }
}

##NEW_FILE_STARTS_HERE MIR_LoadUpdate.java##

/*
 * THIS FILE IS MACHINE_GENERATED. DO NOT EDIT.
 * See InstructionFormats.template, InstructionFormatList.dat,
 * OperatorList.dat, etc.
 */

package org.jikesrvm.compilers.opt.ir.ppc;

import org.jikesrvm.Configuration;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCConditionOperand;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCTrapOperand;
import org.jikesrvm.compilers.opt.ir.operand.*;
import org.jikesrvm.compilers.opt.ir.Instruction;
import org.jikesrvm.compilers.opt.ir.Operator;

/**
 * The MIR_LoadUpdate InstructionFormat class.
 *
 * The header comment for {@link Instruction} contains
 * an explanation of the role of InstructionFormats in the
 * opt compiler's IR.
 */
@SuppressWarnings("unused")  // Machine generated code is never 100% clean
public final class MIR_LoadUpdate extends ArchInstructionFormat {
  /**
   * InstructionFormat identification method for MIR_LoadUpdate.
   * @param i an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         instruction is MIR_LoadUpdate or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Instruction i) {
    return conforms(i.operator());
  }
  /**
   * InstructionFormat identification method for MIR_LoadUpdate.
   * @param o an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         operator is MIR_LoadUpdate or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Operator o) {
    return o.format == MIR_LoadUpdate_format;
  }

  /**
   * Get the operand called Result from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Result
   */
  public static RegisterOperand getResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LoadUpdate");
    return (RegisterOperand) i.getOperand(0);
  }
  /**
   * Get the operand called Result from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Result
   */
  public static RegisterOperand getClearResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LoadUpdate");
    return (RegisterOperand) i.getClearOperand(0);
  }
  /**
   * Set the operand called Result in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Result the operand to store
   */
  public static void setResult(Instruction i, RegisterOperand Result) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LoadUpdate");
    i.putOperand(0, Result);
  }
  /**
   * Return the index of the operand called Result
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Result
   *         in the argument instruction
   */
  public static int indexOfResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LoadUpdate");
    return 0;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Result?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Result or <code>false</code>
   *         if it does not.
   */
  public static boolean hasResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LoadUpdate");
    return i.getOperand(0) != null;
  }

  /**
   * Get the operand called Address from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Address
   */
  public static RegisterOperand getAddress(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LoadUpdate");
    return (RegisterOperand) i.getOperand(1);
  }
  /**
   * Get the operand called Address from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Address
   */
  public static RegisterOperand getClearAddress(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LoadUpdate");
    return (RegisterOperand) i.getClearOperand(1);
  }
  /**
   * Set the operand called Address in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Address the operand to store
   */
  public static void setAddress(Instruction i, RegisterOperand Address) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LoadUpdate");
    i.putOperand(1, Address);
  }
  /**
   * Return the index of the operand called Address
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Address
   *         in the argument instruction
   */
  public static int indexOfAddress(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LoadUpdate");
    return 1;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Address?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Address or <code>false</code>
   *         if it does not.
   */
  public static boolean hasAddress(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LoadUpdate");
    return i.getOperand(1) != null;
  }

  /**
   * Get the operand called Offset from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Offset
   */
  public static Operand getOffset(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LoadUpdate");
    return (Operand) i.getOperand(2);
  }
  /**
   * Get the operand called Offset from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Offset
   */
  public static Operand getClearOffset(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LoadUpdate");
    return (Operand) i.getClearOperand(2);
  }
  /**
   * Set the operand called Offset in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Offset the operand to store
   */
  public static void setOffset(Instruction i, Operand Offset) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LoadUpdate");
    i.putOperand(2, Offset);
  }
  /**
   * Return the index of the operand called Offset
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Offset
   *         in the argument instruction
   */
  public static int indexOfOffset(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LoadUpdate");
    return 2;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Offset?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Offset or <code>false</code>
   *         if it does not.
   */
  public static boolean hasOffset(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LoadUpdate");
    return i.getOperand(2) != null;
  }

  /**
   * Get the operand called Location from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Location
   */
  public static LocationOperand getLocation(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LoadUpdate");
    return (LocationOperand) i.getOperand(3);
  }
  /**
   * Get the operand called Location from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Location
   */
  public static LocationOperand getClearLocation(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LoadUpdate");
    return (LocationOperand) i.getClearOperand(3);
  }
  /**
   * Set the operand called Location in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Location the operand to store
   */
  public static void setLocation(Instruction i, LocationOperand Location) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LoadUpdate");
    i.putOperand(3, Location);
  }
  /**
   * Return the index of the operand called Location
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Location
   *         in the argument instruction
   */
  public static int indexOfLocation(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LoadUpdate");
    return 3;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Location?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Location or <code>false</code>
   *         if it does not.
   */
  public static boolean hasLocation(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LoadUpdate");
    return i.getOperand(3) != null;
  }

  /**
   * Get the operand called Guard from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Guard
   */
  public static Operand getGuard(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LoadUpdate");
    return (Operand) i.getOperand(4);
  }
  /**
   * Get the operand called Guard from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Guard
   */
  public static Operand getClearGuard(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LoadUpdate");
    return (Operand) i.getClearOperand(4);
  }
  /**
   * Set the operand called Guard in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Guard the operand to store
   */
  public static void setGuard(Instruction i, Operand Guard) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LoadUpdate");
    i.putOperand(4, Guard);
  }
  /**
   * Return the index of the operand called Guard
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Guard
   *         in the argument instruction
   */
  public static int indexOfGuard(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LoadUpdate");
    return 4;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Guard?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Guard or <code>false</code>
   *         if it does not.
   */
  public static boolean hasGuard(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LoadUpdate");
    return i.getOperand(4) != null;
  }


  /**
   * Create an instruction of the MIR_LoadUpdate instruction format.
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Address the instruction's Address operand
   * @param Offset the instruction's Offset operand
   * @param Location the instruction's Location operand
   * @param Guard the instruction's Guard operand
   * @return the newly created MIR_LoadUpdate instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Result
                   , RegisterOperand Address
                   , Operand Offset
                   , LocationOperand Location
                   , Operand Guard
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_LoadUpdate");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Result);
    i.putOperand(1, Address);
    i.putOperand(2, Offset);
    i.putOperand(3, Location);
    i.putOperand(4, Guard);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_LoadUpdate instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Address the instruction's Address operand
   * @param Offset the instruction's Offset operand
   * @param Location the instruction's Location operand
   * @param Guard the instruction's Guard operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Result
                   , RegisterOperand Address
                   , Operand Offset
                   , LocationOperand Location
                   , Operand Guard
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_LoadUpdate");
    i.changeOperatorTo(o);
    i.putOperand(0, Result);
    i.putOperand(1, Address);
    i.putOperand(2, Offset);
    i.putOperand(3, Location);
    i.putOperand(4, Guard);
    return i;
  }
  /**
   * Create an instruction of the MIR_LoadUpdate instruction format.
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Address the instruction's Address operand
   * @param Offset the instruction's Offset operand
   * @param Location the instruction's Location operand
   * @return the newly created MIR_LoadUpdate instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Result
                   , RegisterOperand Address
                   , Operand Offset
                   , LocationOperand Location
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_LoadUpdate");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Result);
    i.putOperand(1, Address);
    i.putOperand(2, Offset);
    i.putOperand(3, Location);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_LoadUpdate instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Address the instruction's Address operand
   * @param Offset the instruction's Offset operand
   * @param Location the instruction's Location operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Result
                   , RegisterOperand Address
                   , Operand Offset
                   , LocationOperand Location
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_LoadUpdate");
    i.changeOperatorTo(o);
    i.putOperand(0, Result);
    i.putOperand(1, Address);
    i.putOperand(2, Offset);
    i.putOperand(3, Location);
    i.putOperand(4, null);
    return i;
  }
  /**
   * Create an instruction of the MIR_LoadUpdate instruction format.
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Address the instruction's Address operand
   * @param Offset the instruction's Offset operand
   * @param Guard the instruction's Guard operand
   * @return the newly created MIR_LoadUpdate instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Result
                   , RegisterOperand Address
                   , Operand Offset
                   , Operand Guard
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_LoadUpdate");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Result);
    i.putOperand(1, Address);
    i.putOperand(2, Offset);
    i.putOperand(4, Guard);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_LoadUpdate instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Address the instruction's Address operand
   * @param Offset the instruction's Offset operand
   * @param Guard the instruction's Guard operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Result
                   , RegisterOperand Address
                   , Operand Offset
                   , Operand Guard
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_LoadUpdate");
    i.changeOperatorTo(o);
    i.putOperand(0, Result);
    i.putOperand(1, Address);
    i.putOperand(2, Offset);
    i.putOperand(3, null);
    i.putOperand(4, Guard);
    return i;
  }
  /**
   * Create an instruction of the MIR_LoadUpdate instruction format.
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Address the instruction's Address operand
   * @param Offset the instruction's Offset operand
   * @return the newly created MIR_LoadUpdate instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Result
                   , RegisterOperand Address
                   , Operand Offset
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_LoadUpdate");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Result);
    i.putOperand(1, Address);
    i.putOperand(2, Offset);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_LoadUpdate instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Address the instruction's Address operand
   * @param Offset the instruction's Offset operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Result
                   , RegisterOperand Address
                   , Operand Offset
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_LoadUpdate");
    i.changeOperatorTo(o);
    i.putOperand(0, Result);
    i.putOperand(1, Address);
    i.putOperand(2, Offset);
    i.putOperand(3, null);
    i.putOperand(4, null);
    return i;
  }
}

##NEW_FILE_STARTS_HERE MIR_Store.java##

/*
 * THIS FILE IS MACHINE_GENERATED. DO NOT EDIT.
 * See InstructionFormats.template, InstructionFormatList.dat,
 * OperatorList.dat, etc.
 */

package org.jikesrvm.compilers.opt.ir.ppc;

import org.jikesrvm.Configuration;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCConditionOperand;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCTrapOperand;
import org.jikesrvm.compilers.opt.ir.operand.*;
import org.jikesrvm.compilers.opt.ir.Instruction;
import org.jikesrvm.compilers.opt.ir.Operator;

/**
 * The MIR_Store InstructionFormat class.
 *
 * The header comment for {@link Instruction} contains
 * an explanation of the role of InstructionFormats in the
 * opt compiler's IR.
 */
@SuppressWarnings("unused")  // Machine generated code is never 100% clean
public final class MIR_Store extends ArchInstructionFormat {
  /**
   * InstructionFormat identification method for MIR_Store.
   * @param i an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         instruction is MIR_Store or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Instruction i) {
    return conforms(i.operator());
  }
  /**
   * InstructionFormat identification method for MIR_Store.
   * @param o an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         operator is MIR_Store or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Operator o) {
    return o.format == MIR_Store_format;
  }

  /**
   * Get the operand called Value from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value
   */
  public static RegisterOperand getValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Store");
    return (RegisterOperand) i.getOperand(0);
  }
  /**
   * Get the operand called Value from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value
   */
  public static RegisterOperand getClearValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Store");
    return (RegisterOperand) i.getClearOperand(0);
  }
  /**
   * Set the operand called Value in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Value the operand to store
   */
  public static void setValue(Instruction i, RegisterOperand Value) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Store");
    i.putOperand(0, Value);
  }
  /**
   * Return the index of the operand called Value
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Value
   *         in the argument instruction
   */
  public static int indexOfValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Store");
    return 0;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Value?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Value or <code>false</code>
   *         if it does not.
   */
  public static boolean hasValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Store");
    return i.getOperand(0) != null;
  }

  /**
   * Get the operand called Address from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Address
   */
  public static RegisterOperand getAddress(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Store");
    return (RegisterOperand) i.getOperand(1);
  }
  /**
   * Get the operand called Address from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Address
   */
  public static RegisterOperand getClearAddress(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Store");
    return (RegisterOperand) i.getClearOperand(1);
  }
  /**
   * Set the operand called Address in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Address the operand to store
   */
  public static void setAddress(Instruction i, RegisterOperand Address) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Store");
    i.putOperand(1, Address);
  }
  /**
   * Return the index of the operand called Address
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Address
   *         in the argument instruction
   */
  public static int indexOfAddress(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Store");
    return 1;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Address?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Address or <code>false</code>
   *         if it does not.
   */
  public static boolean hasAddress(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Store");
    return i.getOperand(1) != null;
  }

  /**
   * Get the operand called Offset from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Offset
   */
  public static Operand getOffset(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Store");
    return (Operand) i.getOperand(2);
  }
  /**
   * Get the operand called Offset from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Offset
   */
  public static Operand getClearOffset(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Store");
    return (Operand) i.getClearOperand(2);
  }
  /**
   * Set the operand called Offset in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Offset the operand to store
   */
  public static void setOffset(Instruction i, Operand Offset) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Store");
    i.putOperand(2, Offset);
  }
  /**
   * Return the index of the operand called Offset
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Offset
   *         in the argument instruction
   */
  public static int indexOfOffset(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Store");
    return 2;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Offset?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Offset or <code>false</code>
   *         if it does not.
   */
  public static boolean hasOffset(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Store");
    return i.getOperand(2) != null;
  }

  /**
   * Get the operand called Location from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Location
   */
  public static LocationOperand getLocation(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Store");
    return (LocationOperand) i.getOperand(3);
  }
  /**
   * Get the operand called Location from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Location
   */
  public static LocationOperand getClearLocation(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Store");
    return (LocationOperand) i.getClearOperand(3);
  }
  /**
   * Set the operand called Location in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Location the operand to store
   */
  public static void setLocation(Instruction i, LocationOperand Location) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Store");
    i.putOperand(3, Location);
  }
  /**
   * Return the index of the operand called Location
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Location
   *         in the argument instruction
   */
  public static int indexOfLocation(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Store");
    return 3;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Location?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Location or <code>false</code>
   *         if it does not.
   */
  public static boolean hasLocation(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Store");
    return i.getOperand(3) != null;
  }

  /**
   * Get the operand called Guard from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Guard
   */
  public static Operand getGuard(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Store");
    return (Operand) i.getOperand(4);
  }
  /**
   * Get the operand called Guard from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Guard
   */
  public static Operand getClearGuard(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Store");
    return (Operand) i.getClearOperand(4);
  }
  /**
   * Set the operand called Guard in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Guard the operand to store
   */
  public static void setGuard(Instruction i, Operand Guard) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Store");
    i.putOperand(4, Guard);
  }
  /**
   * Return the index of the operand called Guard
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Guard
   *         in the argument instruction
   */
  public static int indexOfGuard(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Store");
    return 4;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Guard?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Guard or <code>false</code>
   *         if it does not.
   */
  public static boolean hasGuard(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Store");
    return i.getOperand(4) != null;
  }


  /**
   * Create an instruction of the MIR_Store instruction format.
   * @param o the instruction's operator
   * @param Value the instruction's Value operand
   * @param Address the instruction's Address operand
   * @param Offset the instruction's Offset operand
   * @param Location the instruction's Location operand
   * @param Guard the instruction's Guard operand
   * @return the newly created MIR_Store instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Value
                   , RegisterOperand Address
                   , Operand Offset
                   , LocationOperand Location
                   , Operand Guard
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Store");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Value);
    i.putOperand(1, Address);
    i.putOperand(2, Offset);
    i.putOperand(3, Location);
    i.putOperand(4, Guard);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_Store instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Value the instruction's Value operand
   * @param Address the instruction's Address operand
   * @param Offset the instruction's Offset operand
   * @param Location the instruction's Location operand
   * @param Guard the instruction's Guard operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Value
                   , RegisterOperand Address
                   , Operand Offset
                   , LocationOperand Location
                   , Operand Guard
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Store");
    i.changeOperatorTo(o);
    i.putOperand(0, Value);
    i.putOperand(1, Address);
    i.putOperand(2, Offset);
    i.putOperand(3, Location);
    i.putOperand(4, Guard);
    return i;
  }
  /**
   * Create an instruction of the MIR_Store instruction format.
   * @param o the instruction's operator
   * @param Value the instruction's Value operand
   * @param Address the instruction's Address operand
   * @param Offset the instruction's Offset operand
   * @param Location the instruction's Location operand
   * @return the newly created MIR_Store instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Value
                   , RegisterOperand Address
                   , Operand Offset
                   , LocationOperand Location
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Store");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Value);
    i.putOperand(1, Address);
    i.putOperand(2, Offset);
    i.putOperand(3, Location);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_Store instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Value the instruction's Value operand
   * @param Address the instruction's Address operand
   * @param Offset the instruction's Offset operand
   * @param Location the instruction's Location operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Value
                   , RegisterOperand Address
                   , Operand Offset
                   , LocationOperand Location
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Store");
    i.changeOperatorTo(o);
    i.putOperand(0, Value);
    i.putOperand(1, Address);
    i.putOperand(2, Offset);
    i.putOperand(3, Location);
    i.putOperand(4, null);
    return i;
  }
  /**
   * Create an instruction of the MIR_Store instruction format.
   * @param o the instruction's operator
   * @param Value the instruction's Value operand
   * @param Address the instruction's Address operand
   * @param Offset the instruction's Offset operand
   * @param Guard the instruction's Guard operand
   * @return the newly created MIR_Store instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Value
                   , RegisterOperand Address
                   , Operand Offset
                   , Operand Guard
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Store");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Value);
    i.putOperand(1, Address);
    i.putOperand(2, Offset);
    i.putOperand(4, Guard);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_Store instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Value the instruction's Value operand
   * @param Address the instruction's Address operand
   * @param Offset the instruction's Offset operand
   * @param Guard the instruction's Guard operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Value
                   , RegisterOperand Address
                   , Operand Offset
                   , Operand Guard
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Store");
    i.changeOperatorTo(o);
    i.putOperand(0, Value);
    i.putOperand(1, Address);
    i.putOperand(2, Offset);
    i.putOperand(3, null);
    i.putOperand(4, Guard);
    return i;
  }
  /**
   * Create an instruction of the MIR_Store instruction format.
   * @param o the instruction's operator
   * @param Value the instruction's Value operand
   * @param Address the instruction's Address operand
   * @param Offset the instruction's Offset operand
   * @return the newly created MIR_Store instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Value
                   , RegisterOperand Address
                   , Operand Offset
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Store");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Value);
    i.putOperand(1, Address);
    i.putOperand(2, Offset);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_Store instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Value the instruction's Value operand
   * @param Address the instruction's Address operand
   * @param Offset the instruction's Offset operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Value
                   , RegisterOperand Address
                   , Operand Offset
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Store");
    i.changeOperatorTo(o);
    i.putOperand(0, Value);
    i.putOperand(1, Address);
    i.putOperand(2, Offset);
    i.putOperand(3, null);
    i.putOperand(4, null);
    return i;
  }
}

##NEW_FILE_STARTS_HERE MIR_StoreUpdate.java##

/*
 * THIS FILE IS MACHINE_GENERATED. DO NOT EDIT.
 * See InstructionFormats.template, InstructionFormatList.dat,
 * OperatorList.dat, etc.
 */

package org.jikesrvm.compilers.opt.ir.ppc;

import org.jikesrvm.Configuration;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCConditionOperand;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCTrapOperand;
import org.jikesrvm.compilers.opt.ir.operand.*;
import org.jikesrvm.compilers.opt.ir.Instruction;
import org.jikesrvm.compilers.opt.ir.Operator;

/**
 * The MIR_StoreUpdate InstructionFormat class.
 *
 * The header comment for {@link Instruction} contains
 * an explanation of the role of InstructionFormats in the
 * opt compiler's IR.
 */
@SuppressWarnings("unused")  // Machine generated code is never 100% clean
public final class MIR_StoreUpdate extends ArchInstructionFormat {
  /**
   * InstructionFormat identification method for MIR_StoreUpdate.
   * @param i an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         instruction is MIR_StoreUpdate or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Instruction i) {
    return conforms(i.operator());
  }
  /**
   * InstructionFormat identification method for MIR_StoreUpdate.
   * @param o an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         operator is MIR_StoreUpdate or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Operator o) {
    return o.format == MIR_StoreUpdate_format;
  }

  /**
   * Get the operand called Address from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Address
   */
  public static RegisterOperand getAddress(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_StoreUpdate");
    return (RegisterOperand) i.getOperand(0);
  }
  /**
   * Get the operand called Address from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Address
   */
  public static RegisterOperand getClearAddress(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_StoreUpdate");
    return (RegisterOperand) i.getClearOperand(0);
  }
  /**
   * Set the operand called Address in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Address the operand to store
   */
  public static void setAddress(Instruction i, RegisterOperand Address) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_StoreUpdate");
    i.putOperand(0, Address);
  }
  /**
   * Return the index of the operand called Address
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Address
   *         in the argument instruction
   */
  public static int indexOfAddress(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_StoreUpdate");
    return 0;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Address?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Address or <code>false</code>
   *         if it does not.
   */
  public static boolean hasAddress(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_StoreUpdate");
    return i.getOperand(0) != null;
  }

  /**
   * Get the operand called Value from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value
   */
  public static RegisterOperand getValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_StoreUpdate");
    return (RegisterOperand) i.getOperand(1);
  }
  /**
   * Get the operand called Value from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value
   */
  public static RegisterOperand getClearValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_StoreUpdate");
    return (RegisterOperand) i.getClearOperand(1);
  }
  /**
   * Set the operand called Value in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Value the operand to store
   */
  public static void setValue(Instruction i, RegisterOperand Value) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_StoreUpdate");
    i.putOperand(1, Value);
  }
  /**
   * Return the index of the operand called Value
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Value
   *         in the argument instruction
   */
  public static int indexOfValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_StoreUpdate");
    return 1;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Value?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Value or <code>false</code>
   *         if it does not.
   */
  public static boolean hasValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_StoreUpdate");
    return i.getOperand(1) != null;
  }

  /**
   * Get the operand called Offset from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Offset
   */
  public static Operand getOffset(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_StoreUpdate");
    return (Operand) i.getOperand(2);
  }
  /**
   * Get the operand called Offset from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Offset
   */
  public static Operand getClearOffset(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_StoreUpdate");
    return (Operand) i.getClearOperand(2);
  }
  /**
   * Set the operand called Offset in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Offset the operand to store
   */
  public static void setOffset(Instruction i, Operand Offset) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_StoreUpdate");
    i.putOperand(2, Offset);
  }
  /**
   * Return the index of the operand called Offset
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Offset
   *         in the argument instruction
   */
  public static int indexOfOffset(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_StoreUpdate");
    return 2;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Offset?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Offset or <code>false</code>
   *         if it does not.
   */
  public static boolean hasOffset(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_StoreUpdate");
    return i.getOperand(2) != null;
  }

  /**
   * Get the operand called Location from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Location
   */
  public static LocationOperand getLocation(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_StoreUpdate");
    return (LocationOperand) i.getOperand(3);
  }
  /**
   * Get the operand called Location from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Location
   */
  public static LocationOperand getClearLocation(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_StoreUpdate");
    return (LocationOperand) i.getClearOperand(3);
  }
  /**
   * Set the operand called Location in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Location the operand to store
   */
  public static void setLocation(Instruction i, LocationOperand Location) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_StoreUpdate");
    i.putOperand(3, Location);
  }
  /**
   * Return the index of the operand called Location
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Location
   *         in the argument instruction
   */
  public static int indexOfLocation(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_StoreUpdate");
    return 3;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Location?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Location or <code>false</code>
   *         if it does not.
   */
  public static boolean hasLocation(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_StoreUpdate");
    return i.getOperand(3) != null;
  }

  /**
   * Get the operand called Guard from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Guard
   */
  public static Operand getGuard(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_StoreUpdate");
    return (Operand) i.getOperand(4);
  }
  /**
   * Get the operand called Guard from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Guard
   */
  public static Operand getClearGuard(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_StoreUpdate");
    return (Operand) i.getClearOperand(4);
  }
  /**
   * Set the operand called Guard in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Guard the operand to store
   */
  public static void setGuard(Instruction i, Operand Guard) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_StoreUpdate");
    i.putOperand(4, Guard);
  }
  /**
   * Return the index of the operand called Guard
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Guard
   *         in the argument instruction
   */
  public static int indexOfGuard(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_StoreUpdate");
    return 4;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Guard?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Guard or <code>false</code>
   *         if it does not.
   */
  public static boolean hasGuard(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_StoreUpdate");
    return i.getOperand(4) != null;
  }


  /**
   * Create an instruction of the MIR_StoreUpdate instruction format.
   * @param o the instruction's operator
   * @param Address the instruction's Address operand
   * @param Value the instruction's Value operand
   * @param Offset the instruction's Offset operand
   * @param Location the instruction's Location operand
   * @param Guard the instruction's Guard operand
   * @return the newly created MIR_StoreUpdate instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Address
                   , RegisterOperand Value
                   , Operand Offset
                   , LocationOperand Location
                   , Operand Guard
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_StoreUpdate");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Address);
    i.putOperand(1, Value);
    i.putOperand(2, Offset);
    i.putOperand(3, Location);
    i.putOperand(4, Guard);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_StoreUpdate instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Address the instruction's Address operand
   * @param Value the instruction's Value operand
   * @param Offset the instruction's Offset operand
   * @param Location the instruction's Location operand
   * @param Guard the instruction's Guard operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Address
                   , RegisterOperand Value
                   , Operand Offset
                   , LocationOperand Location
                   , Operand Guard
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_StoreUpdate");
    i.changeOperatorTo(o);
    i.putOperand(0, Address);
    i.putOperand(1, Value);
    i.putOperand(2, Offset);
    i.putOperand(3, Location);
    i.putOperand(4, Guard);
    return i;
  }
  /**
   * Create an instruction of the MIR_StoreUpdate instruction format.
   * @param o the instruction's operator
   * @param Address the instruction's Address operand
   * @param Value the instruction's Value operand
   * @param Offset the instruction's Offset operand
   * @param Location the instruction's Location operand
   * @return the newly created MIR_StoreUpdate instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Address
                   , RegisterOperand Value
                   , Operand Offset
                   , LocationOperand Location
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_StoreUpdate");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Address);
    i.putOperand(1, Value);
    i.putOperand(2, Offset);
    i.putOperand(3, Location);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_StoreUpdate instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Address the instruction's Address operand
   * @param Value the instruction's Value operand
   * @param Offset the instruction's Offset operand
   * @param Location the instruction's Location operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Address
                   , RegisterOperand Value
                   , Operand Offset
                   , LocationOperand Location
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_StoreUpdate");
    i.changeOperatorTo(o);
    i.putOperand(0, Address);
    i.putOperand(1, Value);
    i.putOperand(2, Offset);
    i.putOperand(3, Location);
    i.putOperand(4, null);
    return i;
  }
  /**
   * Create an instruction of the MIR_StoreUpdate instruction format.
   * @param o the instruction's operator
   * @param Address the instruction's Address operand
   * @param Value the instruction's Value operand
   * @param Offset the instruction's Offset operand
   * @param Guard the instruction's Guard operand
   * @return the newly created MIR_StoreUpdate instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Address
                   , RegisterOperand Value
                   , Operand Offset
                   , Operand Guard
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_StoreUpdate");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Address);
    i.putOperand(1, Value);
    i.putOperand(2, Offset);
    i.putOperand(4, Guard);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_StoreUpdate instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Address the instruction's Address operand
   * @param Value the instruction's Value operand
   * @param Offset the instruction's Offset operand
   * @param Guard the instruction's Guard operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Address
                   , RegisterOperand Value
                   , Operand Offset
                   , Operand Guard
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_StoreUpdate");
    i.changeOperatorTo(o);
    i.putOperand(0, Address);
    i.putOperand(1, Value);
    i.putOperand(2, Offset);
    i.putOperand(3, null);
    i.putOperand(4, Guard);
    return i;
  }
  /**
   * Create an instruction of the MIR_StoreUpdate instruction format.
   * @param o the instruction's operator
   * @param Address the instruction's Address operand
   * @param Value the instruction's Value operand
   * @param Offset the instruction's Offset operand
   * @return the newly created MIR_StoreUpdate instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Address
                   , RegisterOperand Value
                   , Operand Offset
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_StoreUpdate");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Address);
    i.putOperand(1, Value);
    i.putOperand(2, Offset);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_StoreUpdate instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Address the instruction's Address operand
   * @param Value the instruction's Value operand
   * @param Offset the instruction's Offset operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Address
                   , RegisterOperand Value
                   , Operand Offset
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_StoreUpdate");
    i.changeOperatorTo(o);
    i.putOperand(0, Address);
    i.putOperand(1, Value);
    i.putOperand(2, Offset);
    i.putOperand(3, null);
    i.putOperand(4, null);
    return i;
  }
}

##NEW_FILE_STARTS_HERE MIR_CacheOp.java##

/*
 * THIS FILE IS MACHINE_GENERATED. DO NOT EDIT.
 * See InstructionFormats.template, InstructionFormatList.dat,
 * OperatorList.dat, etc.
 */

package org.jikesrvm.compilers.opt.ir.ppc;

import org.jikesrvm.Configuration;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCConditionOperand;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCTrapOperand;
import org.jikesrvm.compilers.opt.ir.operand.*;
import org.jikesrvm.compilers.opt.ir.Instruction;
import org.jikesrvm.compilers.opt.ir.Operator;

/**
 * The MIR_CacheOp InstructionFormat class.
 *
 * The header comment for {@link Instruction} contains
 * an explanation of the role of InstructionFormats in the
 * opt compiler's IR.
 */
@SuppressWarnings("unused")  // Machine generated code is never 100% clean
public final class MIR_CacheOp extends ArchInstructionFormat {
  /**
   * InstructionFormat identification method for MIR_CacheOp.
   * @param i an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         instruction is MIR_CacheOp or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Instruction i) {
    return conforms(i.operator());
  }
  /**
   * InstructionFormat identification method for MIR_CacheOp.
   * @param o an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         operator is MIR_CacheOp or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Operator o) {
    return o.format == MIR_CacheOp_format;
  }

  /**
   * Get the operand called Address from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Address
   */
  public static RegisterOperand getAddress(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CacheOp");
    return (RegisterOperand) i.getOperand(0);
  }
  /**
   * Get the operand called Address from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Address
   */
  public static RegisterOperand getClearAddress(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CacheOp");
    return (RegisterOperand) i.getClearOperand(0);
  }
  /**
   * Set the operand called Address in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Address the operand to store
   */
  public static void setAddress(Instruction i, RegisterOperand Address) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CacheOp");
    i.putOperand(0, Address);
  }
  /**
   * Return the index of the operand called Address
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Address
   *         in the argument instruction
   */
  public static int indexOfAddress(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CacheOp");
    return 0;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Address?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Address or <code>false</code>
   *         if it does not.
   */
  public static boolean hasAddress(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CacheOp");
    return i.getOperand(0) != null;
  }

  /**
   * Get the operand called Offset from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Offset
   */
  public static RegisterOperand getOffset(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CacheOp");
    return (RegisterOperand) i.getOperand(1);
  }
  /**
   * Get the operand called Offset from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Offset
   */
  public static RegisterOperand getClearOffset(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CacheOp");
    return (RegisterOperand) i.getClearOperand(1);
  }
  /**
   * Set the operand called Offset in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Offset the operand to store
   */
  public static void setOffset(Instruction i, RegisterOperand Offset) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CacheOp");
    i.putOperand(1, Offset);
  }
  /**
   * Return the index of the operand called Offset
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Offset
   *         in the argument instruction
   */
  public static int indexOfOffset(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CacheOp");
    return 1;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Offset?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Offset or <code>false</code>
   *         if it does not.
   */
  public static boolean hasOffset(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CacheOp");
    return i.getOperand(1) != null;
  }


  /**
   * Create an instruction of the MIR_CacheOp instruction format.
   * @param o the instruction's operator
   * @param Address the instruction's Address operand
   * @param Offset the instruction's Offset operand
   * @return the newly created MIR_CacheOp instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Address
                   , RegisterOperand Offset
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_CacheOp");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Address);
    i.putOperand(1, Offset);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_CacheOp instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Address the instruction's Address operand
   * @param Offset the instruction's Offset operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Address
                   , RegisterOperand Offset
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_CacheOp");
    i.changeOperatorTo(o);
    i.putOperand(0, Address);
    i.putOperand(1, Offset);
    return i;
  }
}

##NEW_FILE_STARTS_HERE MIR_Move.java##

/*
 * THIS FILE IS MACHINE_GENERATED. DO NOT EDIT.
 * See InstructionFormats.template, InstructionFormatList.dat,
 * OperatorList.dat, etc.
 */

package org.jikesrvm.compilers.opt.ir.ppc;

import org.jikesrvm.Configuration;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCConditionOperand;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCTrapOperand;
import org.jikesrvm.compilers.opt.ir.operand.*;
import org.jikesrvm.compilers.opt.ir.Instruction;
import org.jikesrvm.compilers.opt.ir.Operator;

/**
 * The MIR_Move InstructionFormat class.
 *
 * The header comment for {@link Instruction} contains
 * an explanation of the role of InstructionFormats in the
 * opt compiler's IR.
 */
@SuppressWarnings("unused")  // Machine generated code is never 100% clean
public final class MIR_Move extends ArchInstructionFormat {
  /**
   * InstructionFormat identification method for MIR_Move.
   * @param i an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         instruction is MIR_Move or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Instruction i) {
    return conforms(i.operator());
  }
  /**
   * InstructionFormat identification method for MIR_Move.
   * @param o an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         operator is MIR_Move or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Operator o) {
    return o.format == MIR_Move_format;
  }

  /**
   * Get the operand called Result from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Result
   */
  public static RegisterOperand getResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Move");
    return (RegisterOperand) i.getOperand(0);
  }
  /**
   * Get the operand called Result from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Result
   */
  public static RegisterOperand getClearResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Move");
    return (RegisterOperand) i.getClearOperand(0);
  }
  /**
   * Set the operand called Result in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Result the operand to store
   */
  public static void setResult(Instruction i, RegisterOperand Result) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Move");
    i.putOperand(0, Result);
  }
  /**
   * Return the index of the operand called Result
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Result
   *         in the argument instruction
   */
  public static int indexOfResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Move");
    return 0;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Result?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Result or <code>false</code>
   *         if it does not.
   */
  public static boolean hasResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Move");
    return i.getOperand(0) != null;
  }

  /**
   * Get the operand called Value from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value
   */
  public static RegisterOperand getValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Move");
    return (RegisterOperand) i.getOperand(1);
  }
  /**
   * Get the operand called Value from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value
   */
  public static RegisterOperand getClearValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Move");
    return (RegisterOperand) i.getClearOperand(1);
  }
  /**
   * Set the operand called Value in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Value the operand to store
   */
  public static void setValue(Instruction i, RegisterOperand Value) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Move");
    i.putOperand(1, Value);
  }
  /**
   * Return the index of the operand called Value
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Value
   *         in the argument instruction
   */
  public static int indexOfValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Move");
    return 1;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Value?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Value or <code>false</code>
   *         if it does not.
   */
  public static boolean hasValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Move");
    return i.getOperand(1) != null;
  }


  /**
   * Create an instruction of the MIR_Move instruction format.
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Value the instruction's Value operand
   * @return the newly created MIR_Move instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Result
                   , RegisterOperand Value
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Move");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Result);
    i.putOperand(1, Value);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_Move instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Value the instruction's Value operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Result
                   , RegisterOperand Value
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Move");
    i.changeOperatorTo(o);
    i.putOperand(0, Result);
    i.putOperand(1, Value);
    return i;
  }
}

##NEW_FILE_STARTS_HERE MIR_Trap.java##

/*
 * THIS FILE IS MACHINE_GENERATED. DO NOT EDIT.
 * See InstructionFormats.template, InstructionFormatList.dat,
 * OperatorList.dat, etc.
 */

package org.jikesrvm.compilers.opt.ir.ppc;

import org.jikesrvm.Configuration;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCConditionOperand;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCTrapOperand;
import org.jikesrvm.compilers.opt.ir.operand.*;
import org.jikesrvm.compilers.opt.ir.Instruction;
import org.jikesrvm.compilers.opt.ir.Operator;

/**
 * The MIR_Trap InstructionFormat class.
 *
 * The header comment for {@link Instruction} contains
 * an explanation of the role of InstructionFormats in the
 * opt compiler's IR.
 */
@SuppressWarnings("unused")  // Machine generated code is never 100% clean
public final class MIR_Trap extends ArchInstructionFormat {
  /**
   * InstructionFormat identification method for MIR_Trap.
   * @param i an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         instruction is MIR_Trap or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Instruction i) {
    return conforms(i.operator());
  }
  /**
   * InstructionFormat identification method for MIR_Trap.
   * @param o an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         operator is MIR_Trap or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Operator o) {
    return o.format == MIR_Trap_format;
  }

  /**
   * Get the operand called GuardResult from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called GuardResult
   */
  public static RegisterOperand getGuardResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Trap");
    return (RegisterOperand) i.getOperand(0);
  }
  /**
   * Get the operand called GuardResult from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called GuardResult
   */
  public static RegisterOperand getClearGuardResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Trap");
    return (RegisterOperand) i.getClearOperand(0);
  }
  /**
   * Set the operand called GuardResult in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param GuardResult the operand to store
   */
  public static void setGuardResult(Instruction i, RegisterOperand GuardResult) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Trap");
    i.putOperand(0, GuardResult);
  }
  /**
   * Return the index of the operand called GuardResult
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called GuardResult
   *         in the argument instruction
   */
  public static int indexOfGuardResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Trap");
    return 0;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named GuardResult?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named GuardResult or <code>false</code>
   *         if it does not.
   */
  public static boolean hasGuardResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Trap");
    return i.getOperand(0) != null;
  }

  /**
   * Get the operand called Cond from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Cond
   */
  public static PowerPCTrapOperand getCond(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Trap");
    return (PowerPCTrapOperand) i.getOperand(1);
  }
  /**
   * Get the operand called Cond from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Cond
   */
  public static PowerPCTrapOperand getClearCond(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Trap");
    return (PowerPCTrapOperand) i.getClearOperand(1);
  }
  /**
   * Set the operand called Cond in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Cond the operand to store
   */
  public static void setCond(Instruction i, PowerPCTrapOperand Cond) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Trap");
    i.putOperand(1, Cond);
  }
  /**
   * Return the index of the operand called Cond
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Cond
   *         in the argument instruction
   */
  public static int indexOfCond(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Trap");
    return 1;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Cond?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Cond or <code>false</code>
   *         if it does not.
   */
  public static boolean hasCond(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Trap");
    return i.getOperand(1) != null;
  }

  /**
   * Get the operand called Value1 from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value1
   */
  public static RegisterOperand getValue1(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Trap");
    return (RegisterOperand) i.getOperand(2);
  }
  /**
   * Get the operand called Value1 from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value1
   */
  public static RegisterOperand getClearValue1(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Trap");
    return (RegisterOperand) i.getClearOperand(2);
  }
  /**
   * Set the operand called Value1 in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Value1 the operand to store
   */
  public static void setValue1(Instruction i, RegisterOperand Value1) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Trap");
    i.putOperand(2, Value1);
  }
  /**
   * Return the index of the operand called Value1
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Value1
   *         in the argument instruction
   */
  public static int indexOfValue1(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Trap");
    return 2;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Value1?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Value1 or <code>false</code>
   *         if it does not.
   */
  public static boolean hasValue1(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Trap");
    return i.getOperand(2) != null;
  }

  /**
   * Get the operand called Value2 from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value2
   */
  public static Operand getValue2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Trap");
    return (Operand) i.getOperand(3);
  }
  /**
   * Get the operand called Value2 from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value2
   */
  public static Operand getClearValue2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Trap");
    return (Operand) i.getClearOperand(3);
  }
  /**
   * Set the operand called Value2 in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Value2 the operand to store
   */
  public static void setValue2(Instruction i, Operand Value2) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Trap");
    i.putOperand(3, Value2);
  }
  /**
   * Return the index of the operand called Value2
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Value2
   *         in the argument instruction
   */
  public static int indexOfValue2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Trap");
    return 3;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Value2?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Value2 or <code>false</code>
   *         if it does not.
   */
  public static boolean hasValue2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Trap");
    return i.getOperand(3) != null;
  }

  /**
   * Get the operand called TCode from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called TCode
   */
  public static TrapCodeOperand getTCode(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Trap");
    return (TrapCodeOperand) i.getOperand(4);
  }
  /**
   * Get the operand called TCode from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called TCode
   */
  public static TrapCodeOperand getClearTCode(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Trap");
    return (TrapCodeOperand) i.getClearOperand(4);
  }
  /**
   * Set the operand called TCode in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param TCode the operand to store
   */
  public static void setTCode(Instruction i, TrapCodeOperand TCode) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Trap");
    i.putOperand(4, TCode);
  }
  /**
   * Return the index of the operand called TCode
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called TCode
   *         in the argument instruction
   */
  public static int indexOfTCode(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Trap");
    return 4;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named TCode?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named TCode or <code>false</code>
   *         if it does not.
   */
  public static boolean hasTCode(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Trap");
    return i.getOperand(4) != null;
  }


  /**
   * Create an instruction of the MIR_Trap instruction format.
   * @param o the instruction's operator
   * @param GuardResult the instruction's GuardResult operand
   * @param Cond the instruction's Cond operand
   * @param Value1 the instruction's Value1 operand
   * @param Value2 the instruction's Value2 operand
   * @param TCode the instruction's TCode operand
   * @return the newly created MIR_Trap instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand GuardResult
                   , PowerPCTrapOperand Cond
                   , RegisterOperand Value1
                   , Operand Value2
                   , TrapCodeOperand TCode
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Trap");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, GuardResult);
    i.putOperand(1, Cond);
    i.putOperand(2, Value1);
    i.putOperand(3, Value2);
    i.putOperand(4, TCode);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_Trap instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param GuardResult the instruction's GuardResult operand
   * @param Cond the instruction's Cond operand
   * @param Value1 the instruction's Value1 operand
   * @param Value2 the instruction's Value2 operand
   * @param TCode the instruction's TCode operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand GuardResult
                   , PowerPCTrapOperand Cond
                   , RegisterOperand Value1
                   , Operand Value2
                   , TrapCodeOperand TCode
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Trap");
    i.changeOperatorTo(o);
    i.putOperand(0, GuardResult);
    i.putOperand(1, Cond);
    i.putOperand(2, Value1);
    i.putOperand(3, Value2);
    i.putOperand(4, TCode);
    return i;
  }
  /**
   * Create an instruction of the MIR_Trap instruction format.
   * @param o the instruction's operator
   * @param Cond the instruction's Cond operand
   * @param Value1 the instruction's Value1 operand
   * @param Value2 the instruction's Value2 operand
   * @param TCode the instruction's TCode operand
   * @return the newly created MIR_Trap instruction
   */
  public static Instruction create(Operator o
                   , PowerPCTrapOperand Cond
                   , RegisterOperand Value1
                   , Operand Value2
                   , TrapCodeOperand TCode
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Trap");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(1, Cond);
    i.putOperand(2, Value1);
    i.putOperand(3, Value2);
    i.putOperand(4, TCode);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_Trap instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Cond the instruction's Cond operand
   * @param Value1 the instruction's Value1 operand
   * @param Value2 the instruction's Value2 operand
   * @param TCode the instruction's TCode operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , PowerPCTrapOperand Cond
                   , RegisterOperand Value1
                   , Operand Value2
                   , TrapCodeOperand TCode
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Trap");
    i.changeOperatorTo(o);
    i.putOperand(0, null);
    i.putOperand(1, Cond);
    i.putOperand(2, Value1);
    i.putOperand(3, Value2);
    i.putOperand(4, TCode);
    return i;
  }
}

##NEW_FILE_STARTS_HERE MIR_DataInt.java##

/*
 * THIS FILE IS MACHINE_GENERATED. DO NOT EDIT.
 * See InstructionFormats.template, InstructionFormatList.dat,
 * OperatorList.dat, etc.
 */

package org.jikesrvm.compilers.opt.ir.ppc;

import org.jikesrvm.Configuration;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCConditionOperand;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCTrapOperand;
import org.jikesrvm.compilers.opt.ir.operand.*;
import org.jikesrvm.compilers.opt.ir.Instruction;
import org.jikesrvm.compilers.opt.ir.Operator;

/**
 * The MIR_DataInt InstructionFormat class.
 *
 * The header comment for {@link Instruction} contains
 * an explanation of the role of InstructionFormats in the
 * opt compiler's IR.
 */
@SuppressWarnings("unused")  // Machine generated code is never 100% clean
public final class MIR_DataInt extends ArchInstructionFormat {
  /**
   * InstructionFormat identification method for MIR_DataInt.
   * @param i an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         instruction is MIR_DataInt or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Instruction i) {
    return conforms(i.operator());
  }
  /**
   * InstructionFormat identification method for MIR_DataInt.
   * @param o an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         operator is MIR_DataInt or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Operator o) {
    return o.format == MIR_DataInt_format;
  }

  /**
   * Get the operand called Value from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value
   */
  public static IntConstantOperand getValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_DataInt");
    return (IntConstantOperand) i.getOperand(0);
  }
  /**
   * Get the operand called Value from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value
   */
  public static IntConstantOperand getClearValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_DataInt");
    return (IntConstantOperand) i.getClearOperand(0);
  }
  /**
   * Set the operand called Value in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Value the operand to store
   */
  public static void setValue(Instruction i, IntConstantOperand Value) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_DataInt");
    i.putOperand(0, Value);
  }
  /**
   * Return the index of the operand called Value
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Value
   *         in the argument instruction
   */
  public static int indexOfValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_DataInt");
    return 0;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Value?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Value or <code>false</code>
   *         if it does not.
   */
  public static boolean hasValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_DataInt");
    return i.getOperand(0) != null;
  }


  /**
   * Create an instruction of the MIR_DataInt instruction format.
   * @param o the instruction's operator
   * @param Value the instruction's Value operand
   * @return the newly created MIR_DataInt instruction
   */
  public static Instruction create(Operator o
                   , IntConstantOperand Value
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_DataInt");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Value);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_DataInt instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Value the instruction's Value operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , IntConstantOperand Value
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_DataInt");
    i.changeOperatorTo(o);
    i.putOperand(0, Value);
    return i;
  }
}

##NEW_FILE_STARTS_HERE MIR_DataLabel.java##

/*
 * THIS FILE IS MACHINE_GENERATED. DO NOT EDIT.
 * See InstructionFormats.template, InstructionFormatList.dat,
 * OperatorList.dat, etc.
 */

package org.jikesrvm.compilers.opt.ir.ppc;

import org.jikesrvm.Configuration;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCConditionOperand;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCTrapOperand;
import org.jikesrvm.compilers.opt.ir.operand.*;
import org.jikesrvm.compilers.opt.ir.Instruction;
import org.jikesrvm.compilers.opt.ir.Operator;

/**
 * The MIR_DataLabel InstructionFormat class.
 *
 * The header comment for {@link Instruction} contains
 * an explanation of the role of InstructionFormats in the
 * opt compiler's IR.
 */
@SuppressWarnings("unused")  // Machine generated code is never 100% clean
public final class MIR_DataLabel extends ArchInstructionFormat {
  /**
   * InstructionFormat identification method for MIR_DataLabel.
   * @param i an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         instruction is MIR_DataLabel or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Instruction i) {
    return conforms(i.operator());
  }
  /**
   * InstructionFormat identification method for MIR_DataLabel.
   * @param o an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         operator is MIR_DataLabel or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Operator o) {
    return o.format == MIR_DataLabel_format;
  }

  /**
   * Get the operand called Target from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Target
   */
  public static BranchOperand getTarget(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_DataLabel");
    return (BranchOperand) i.getOperand(0);
  }
  /**
   * Get the operand called Target from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Target
   */
  public static BranchOperand getClearTarget(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_DataLabel");
    return (BranchOperand) i.getClearOperand(0);
  }
  /**
   * Set the operand called Target in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Target the operand to store
   */
  public static void setTarget(Instruction i, BranchOperand Target) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_DataLabel");
    i.putOperand(0, Target);
  }
  /**
   * Return the index of the operand called Target
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Target
   *         in the argument instruction
   */
  public static int indexOfTarget(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_DataLabel");
    return 0;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Target?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Target or <code>false</code>
   *         if it does not.
   */
  public static boolean hasTarget(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_DataLabel");
    return i.getOperand(0) != null;
  }


  /**
   * Create an instruction of the MIR_DataLabel instruction format.
   * @param o the instruction's operator
   * @param Target the instruction's Target operand
   * @return the newly created MIR_DataLabel instruction
   */
  public static Instruction create(Operator o
                   , BranchOperand Target
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_DataLabel");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Target);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_DataLabel instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Target the instruction's Target operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , BranchOperand Target
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_DataLabel");
    i.changeOperatorTo(o);
    i.putOperand(0, Target);
    return i;
  }
}

##NEW_FILE_STARTS_HERE MIR_Branch.java##

/*
 * THIS FILE IS MACHINE_GENERATED. DO NOT EDIT.
 * See InstructionFormats.template, InstructionFormatList.dat,
 * OperatorList.dat, etc.
 */

package org.jikesrvm.compilers.opt.ir.ppc;

import org.jikesrvm.Configuration;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCConditionOperand;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCTrapOperand;
import org.jikesrvm.compilers.opt.ir.operand.*;
import org.jikesrvm.compilers.opt.ir.Instruction;
import org.jikesrvm.compilers.opt.ir.Operator;

/**
 * The MIR_Branch InstructionFormat class.
 *
 * The header comment for {@link Instruction} contains
 * an explanation of the role of InstructionFormats in the
 * opt compiler's IR.
 */
@SuppressWarnings("unused")  // Machine generated code is never 100% clean
public final class MIR_Branch extends ArchInstructionFormat {
  /**
   * InstructionFormat identification method for MIR_Branch.
   * @param i an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         instruction is MIR_Branch or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Instruction i) {
    return conforms(i.operator());
  }
  /**
   * InstructionFormat identification method for MIR_Branch.
   * @param o an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         operator is MIR_Branch or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Operator o) {
    return o.format == MIR_Branch_format;
  }

  /**
   * Get the operand called Target from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Target
   */
  public static BranchOperand getTarget(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Branch");
    return (BranchOperand) i.getOperand(0);
  }
  /**
   * Get the operand called Target from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Target
   */
  public static BranchOperand getClearTarget(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Branch");
    return (BranchOperand) i.getClearOperand(0);
  }
  /**
   * Set the operand called Target in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Target the operand to store
   */
  public static void setTarget(Instruction i, BranchOperand Target) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Branch");
    i.putOperand(0, Target);
  }
  /**
   * Return the index of the operand called Target
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Target
   *         in the argument instruction
   */
  public static int indexOfTarget(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Branch");
    return 0;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Target?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Target or <code>false</code>
   *         if it does not.
   */
  public static boolean hasTarget(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Branch");
    return i.getOperand(0) != null;
  }


  /**
   * Create an instruction of the MIR_Branch instruction format.
   * @param o the instruction's operator
   * @param Target the instruction's Target operand
   * @return the newly created MIR_Branch instruction
   */
  public static Instruction create(Operator o
                   , BranchOperand Target
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Branch");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Target);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_Branch instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Target the instruction's Target operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , BranchOperand Target
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Branch");
    i.changeOperatorTo(o);
    i.putOperand(0, Target);
    return i;
  }
  /**
   * Create an instruction of the MIR_Branch instruction format.
   * @param o the instruction's operator
   * @return the newly created MIR_Branch instruction
   */
  public static Instruction create(Operator o
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Branch");
    Instruction i = Instruction.create(o, 5);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_Branch instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Branch");
    i.changeOperatorTo(o);
    i.putOperand(0, null);
    return i;
  }
}

##NEW_FILE_STARTS_HERE MIR_CondBranch.java##

/*
 * THIS FILE IS MACHINE_GENERATED. DO NOT EDIT.
 * See InstructionFormats.template, InstructionFormatList.dat,
 * OperatorList.dat, etc.
 */

package org.jikesrvm.compilers.opt.ir.ppc;

import org.jikesrvm.Configuration;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCConditionOperand;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCTrapOperand;
import org.jikesrvm.compilers.opt.ir.operand.*;
import org.jikesrvm.compilers.opt.ir.Instruction;
import org.jikesrvm.compilers.opt.ir.Operator;

/**
 * The MIR_CondBranch InstructionFormat class.
 *
 * The header comment for {@link Instruction} contains
 * an explanation of the role of InstructionFormats in the
 * opt compiler's IR.
 */
@SuppressWarnings("unused")  // Machine generated code is never 100% clean
public final class MIR_CondBranch extends ArchInstructionFormat {
  /**
   * InstructionFormat identification method for MIR_CondBranch.
   * @param i an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         instruction is MIR_CondBranch or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Instruction i) {
    return conforms(i.operator());
  }
  /**
   * InstructionFormat identification method for MIR_CondBranch.
   * @param o an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         operator is MIR_CondBranch or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Operator o) {
    return o.format == MIR_CondBranch_format;
  }

  /**
   * Get the operand called Value from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value
   */
  public static RegisterOperand getValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch");
    return (RegisterOperand) i.getOperand(0);
  }
  /**
   * Get the operand called Value from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value
   */
  public static RegisterOperand getClearValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch");
    return (RegisterOperand) i.getClearOperand(0);
  }
  /**
   * Set the operand called Value in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Value the operand to store
   */
  public static void setValue(Instruction i, RegisterOperand Value) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch");
    i.putOperand(0, Value);
  }
  /**
   * Return the index of the operand called Value
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Value
   *         in the argument instruction
   */
  public static int indexOfValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch");
    return 0;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Value?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Value or <code>false</code>
   *         if it does not.
   */
  public static boolean hasValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch");
    return i.getOperand(0) != null;
  }

  /**
   * Get the operand called Cond from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Cond
   */
  public static PowerPCConditionOperand getCond(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch");
    return (PowerPCConditionOperand) i.getOperand(1);
  }
  /**
   * Get the operand called Cond from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Cond
   */
  public static PowerPCConditionOperand getClearCond(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch");
    return (PowerPCConditionOperand) i.getClearOperand(1);
  }
  /**
   * Set the operand called Cond in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Cond the operand to store
   */
  public static void setCond(Instruction i, PowerPCConditionOperand Cond) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch");
    i.putOperand(1, Cond);
  }
  /**
   * Return the index of the operand called Cond
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Cond
   *         in the argument instruction
   */
  public static int indexOfCond(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch");
    return 1;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Cond?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Cond or <code>false</code>
   *         if it does not.
   */
  public static boolean hasCond(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch");
    return i.getOperand(1) != null;
  }

  /**
   * Get the operand called Target from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Target
   */
  public static BranchOperand getTarget(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch");
    return (BranchOperand) i.getOperand(2);
  }
  /**
   * Get the operand called Target from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Target
   */
  public static BranchOperand getClearTarget(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch");
    return (BranchOperand) i.getClearOperand(2);
  }
  /**
   * Set the operand called Target in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Target the operand to store
   */
  public static void setTarget(Instruction i, BranchOperand Target) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch");
    i.putOperand(2, Target);
  }
  /**
   * Return the index of the operand called Target
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Target
   *         in the argument instruction
   */
  public static int indexOfTarget(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch");
    return 2;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Target?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Target or <code>false</code>
   *         if it does not.
   */
  public static boolean hasTarget(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch");
    return i.getOperand(2) != null;
  }

  /**
   * Get the operand called BranchProfile from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called BranchProfile
   */
  public static BranchProfileOperand getBranchProfile(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch");
    return (BranchProfileOperand) i.getOperand(3);
  }
  /**
   * Get the operand called BranchProfile from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called BranchProfile
   */
  public static BranchProfileOperand getClearBranchProfile(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch");
    return (BranchProfileOperand) i.getClearOperand(3);
  }
  /**
   * Set the operand called BranchProfile in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param BranchProfile the operand to store
   */
  public static void setBranchProfile(Instruction i, BranchProfileOperand BranchProfile) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch");
    i.putOperand(3, BranchProfile);
  }
  /**
   * Return the index of the operand called BranchProfile
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called BranchProfile
   *         in the argument instruction
   */
  public static int indexOfBranchProfile(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch");
    return 3;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named BranchProfile?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named BranchProfile or <code>false</code>
   *         if it does not.
   */
  public static boolean hasBranchProfile(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch");
    return i.getOperand(3) != null;
  }


  /**
   * Create an instruction of the MIR_CondBranch instruction format.
   * @param o the instruction's operator
   * @param Value the instruction's Value operand
   * @param Cond the instruction's Cond operand
   * @param Target the instruction's Target operand
   * @param BranchProfile the instruction's BranchProfile operand
   * @return the newly created MIR_CondBranch instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Value
                   , PowerPCConditionOperand Cond
                   , BranchOperand Target
                   , BranchProfileOperand BranchProfile
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_CondBranch");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Value);
    i.putOperand(1, Cond);
    i.putOperand(2, Target);
    i.putOperand(3, BranchProfile);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_CondBranch instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Value the instruction's Value operand
   * @param Cond the instruction's Cond operand
   * @param Target the instruction's Target operand
   * @param BranchProfile the instruction's BranchProfile operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Value
                   , PowerPCConditionOperand Cond
                   , BranchOperand Target
                   , BranchProfileOperand BranchProfile
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_CondBranch");
    i.changeOperatorTo(o);
    i.putOperand(0, Value);
    i.putOperand(1, Cond);
    i.putOperand(2, Target);
    i.putOperand(3, BranchProfile);
    return i;
  }
  /**
   * Create an instruction of the MIR_CondBranch instruction format.
   * @param o the instruction's operator
   * @param Value the instruction's Value operand
   * @param Cond the instruction's Cond operand
   * @param BranchProfile the instruction's BranchProfile operand
   * @return the newly created MIR_CondBranch instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Value
                   , PowerPCConditionOperand Cond
                   , BranchProfileOperand BranchProfile
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_CondBranch");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Value);
    i.putOperand(1, Cond);
    i.putOperand(3, BranchProfile);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_CondBranch instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Value the instruction's Value operand
   * @param Cond the instruction's Cond operand
   * @param BranchProfile the instruction's BranchProfile operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Value
                   , PowerPCConditionOperand Cond
                   , BranchProfileOperand BranchProfile
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_CondBranch");
    i.changeOperatorTo(o);
    i.putOperand(0, Value);
    i.putOperand(1, Cond);
    i.putOperand(2, null);
    i.putOperand(3, BranchProfile);
    return i;
  }
}

##NEW_FILE_STARTS_HERE MIR_CondBranch2.java##

/*
 * THIS FILE IS MACHINE_GENERATED. DO NOT EDIT.
 * See InstructionFormats.template, InstructionFormatList.dat,
 * OperatorList.dat, etc.
 */

package org.jikesrvm.compilers.opt.ir.ppc;

import org.jikesrvm.Configuration;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCConditionOperand;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCTrapOperand;
import org.jikesrvm.compilers.opt.ir.operand.*;
import org.jikesrvm.compilers.opt.ir.Instruction;
import org.jikesrvm.compilers.opt.ir.Operator;

/**
 * The MIR_CondBranch2 InstructionFormat class.
 *
 * The header comment for {@link Instruction} contains
 * an explanation of the role of InstructionFormats in the
 * opt compiler's IR.
 */
@SuppressWarnings("unused")  // Machine generated code is never 100% clean
public final class MIR_CondBranch2 extends ArchInstructionFormat {
  /**
   * InstructionFormat identification method for MIR_CondBranch2.
   * @param i an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         instruction is MIR_CondBranch2 or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Instruction i) {
    return conforms(i.operator());
  }
  /**
   * InstructionFormat identification method for MIR_CondBranch2.
   * @param o an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         operator is MIR_CondBranch2 or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Operator o) {
    return o.format == MIR_CondBranch2_format;
  }

  /**
   * Get the operand called Value from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value
   */
  public static RegisterOperand getValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    return (RegisterOperand) i.getOperand(0);
  }
  /**
   * Get the operand called Value from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value
   */
  public static RegisterOperand getClearValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    return (RegisterOperand) i.getClearOperand(0);
  }
  /**
   * Set the operand called Value in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Value the operand to store
   */
  public static void setValue(Instruction i, RegisterOperand Value) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    i.putOperand(0, Value);
  }
  /**
   * Return the index of the operand called Value
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Value
   *         in the argument instruction
   */
  public static int indexOfValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    return 0;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Value?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Value or <code>false</code>
   *         if it does not.
   */
  public static boolean hasValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    return i.getOperand(0) != null;
  }

  /**
   * Get the operand called Cond1 from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Cond1
   */
  public static PowerPCConditionOperand getCond1(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    return (PowerPCConditionOperand) i.getOperand(1);
  }
  /**
   * Get the operand called Cond1 from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Cond1
   */
  public static PowerPCConditionOperand getClearCond1(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    return (PowerPCConditionOperand) i.getClearOperand(1);
  }
  /**
   * Set the operand called Cond1 in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Cond1 the operand to store
   */
  public static void setCond1(Instruction i, PowerPCConditionOperand Cond1) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    i.putOperand(1, Cond1);
  }
  /**
   * Return the index of the operand called Cond1
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Cond1
   *         in the argument instruction
   */
  public static int indexOfCond1(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    return 1;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Cond1?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Cond1 or <code>false</code>
   *         if it does not.
   */
  public static boolean hasCond1(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    return i.getOperand(1) != null;
  }

  /**
   * Get the operand called Target1 from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Target1
   */
  public static BranchOperand getTarget1(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    return (BranchOperand) i.getOperand(2);
  }
  /**
   * Get the operand called Target1 from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Target1
   */
  public static BranchOperand getClearTarget1(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    return (BranchOperand) i.getClearOperand(2);
  }
  /**
   * Set the operand called Target1 in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Target1 the operand to store
   */
  public static void setTarget1(Instruction i, BranchOperand Target1) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    i.putOperand(2, Target1);
  }
  /**
   * Return the index of the operand called Target1
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Target1
   *         in the argument instruction
   */
  public static int indexOfTarget1(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    return 2;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Target1?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Target1 or <code>false</code>
   *         if it does not.
   */
  public static boolean hasTarget1(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    return i.getOperand(2) != null;
  }

  /**
   * Get the operand called BranchProfile1 from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called BranchProfile1
   */
  public static BranchProfileOperand getBranchProfile1(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    return (BranchProfileOperand) i.getOperand(3);
  }
  /**
   * Get the operand called BranchProfile1 from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called BranchProfile1
   */
  public static BranchProfileOperand getClearBranchProfile1(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    return (BranchProfileOperand) i.getClearOperand(3);
  }
  /**
   * Set the operand called BranchProfile1 in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param BranchProfile1 the operand to store
   */
  public static void setBranchProfile1(Instruction i, BranchProfileOperand BranchProfile1) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    i.putOperand(3, BranchProfile1);
  }
  /**
   * Return the index of the operand called BranchProfile1
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called BranchProfile1
   *         in the argument instruction
   */
  public static int indexOfBranchProfile1(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    return 3;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named BranchProfile1?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named BranchProfile1 or <code>false</code>
   *         if it does not.
   */
  public static boolean hasBranchProfile1(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    return i.getOperand(3) != null;
  }

  /**
   * Get the operand called Cond2 from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Cond2
   */
  public static PowerPCConditionOperand getCond2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    return (PowerPCConditionOperand) i.getOperand(4);
  }
  /**
   * Get the operand called Cond2 from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Cond2
   */
  public static PowerPCConditionOperand getClearCond2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    return (PowerPCConditionOperand) i.getClearOperand(4);
  }
  /**
   * Set the operand called Cond2 in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Cond2 the operand to store
   */
  public static void setCond2(Instruction i, PowerPCConditionOperand Cond2) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    i.putOperand(4, Cond2);
  }
  /**
   * Return the index of the operand called Cond2
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Cond2
   *         in the argument instruction
   */
  public static int indexOfCond2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    return 4;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Cond2?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Cond2 or <code>false</code>
   *         if it does not.
   */
  public static boolean hasCond2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    return i.getOperand(4) != null;
  }

  /**
   * Get the operand called Target2 from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Target2
   */
  public static BranchOperand getTarget2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    return (BranchOperand) i.getOperand(5);
  }
  /**
   * Get the operand called Target2 from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Target2
   */
  public static BranchOperand getClearTarget2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    return (BranchOperand) i.getClearOperand(5);
  }
  /**
   * Set the operand called Target2 in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Target2 the operand to store
   */
  public static void setTarget2(Instruction i, BranchOperand Target2) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    i.putOperand(5, Target2);
  }
  /**
   * Return the index of the operand called Target2
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Target2
   *         in the argument instruction
   */
  public static int indexOfTarget2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    return 5;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Target2?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Target2 or <code>false</code>
   *         if it does not.
   */
  public static boolean hasTarget2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    return i.getOperand(5) != null;
  }

  /**
   * Get the operand called BranchProfile2 from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called BranchProfile2
   */
  public static BranchProfileOperand getBranchProfile2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    return (BranchProfileOperand) i.getOperand(6);
  }
  /**
   * Get the operand called BranchProfile2 from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called BranchProfile2
   */
  public static BranchProfileOperand getClearBranchProfile2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    return (BranchProfileOperand) i.getClearOperand(6);
  }
  /**
   * Set the operand called BranchProfile2 in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param BranchProfile2 the operand to store
   */
  public static void setBranchProfile2(Instruction i, BranchProfileOperand BranchProfile2) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    i.putOperand(6, BranchProfile2);
  }
  /**
   * Return the index of the operand called BranchProfile2
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called BranchProfile2
   *         in the argument instruction
   */
  public static int indexOfBranchProfile2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    return 6;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named BranchProfile2?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named BranchProfile2 or <code>false</code>
   *         if it does not.
   */
  public static boolean hasBranchProfile2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondBranch2");
    return i.getOperand(6) != null;
  }


  /**
   * Create an instruction of the MIR_CondBranch2 instruction format.
   * @param o the instruction's operator
   * @param Value the instruction's Value operand
   * @param Cond1 the instruction's Cond1 operand
   * @param Target1 the instruction's Target1 operand
   * @param BranchProfile1 the instruction's BranchProfile1 operand
   * @param Cond2 the instruction's Cond2 operand
   * @param Target2 the instruction's Target2 operand
   * @param BranchProfile2 the instruction's BranchProfile2 operand
   * @return the newly created MIR_CondBranch2 instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Value
                   , PowerPCConditionOperand Cond1
                   , BranchOperand Target1
                   , BranchProfileOperand BranchProfile1
                   , PowerPCConditionOperand Cond2
                   , BranchOperand Target2
                   , BranchProfileOperand BranchProfile2
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_CondBranch2");
    Instruction i = Instruction.create(o, 7);
    i.putOperand(0, Value);
    i.putOperand(1, Cond1);
    i.putOperand(2, Target1);
    i.putOperand(3, BranchProfile1);
    i.putOperand(4, Cond2);
    i.putOperand(5, Target2);
    i.putOperand(6, BranchProfile2);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_CondBranch2 instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Value the instruction's Value operand
   * @param Cond1 the instruction's Cond1 operand
   * @param Target1 the instruction's Target1 operand
   * @param BranchProfile1 the instruction's BranchProfile1 operand
   * @param Cond2 the instruction's Cond2 operand
   * @param Target2 the instruction's Target2 operand
   * @param BranchProfile2 the instruction's BranchProfile2 operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Value
                   , PowerPCConditionOperand Cond1
                   , BranchOperand Target1
                   , BranchProfileOperand BranchProfile1
                   , PowerPCConditionOperand Cond2
                   , BranchOperand Target2
                   , BranchProfileOperand BranchProfile2
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_CondBranch2");
    i.resizeNumberOfOperands(7);

    i.changeOperatorTo(o);
    i.putOperand(0, Value);
    i.putOperand(1, Cond1);
    i.putOperand(2, Target1);
    i.putOperand(3, BranchProfile1);
    i.putOperand(4, Cond2);
    i.putOperand(5, Target2);
    i.putOperand(6, BranchProfile2);
    return i;
  }
}

##NEW_FILE_STARTS_HERE MIR_Call.java##

/*
 * THIS FILE IS MACHINE_GENERATED. DO NOT EDIT.
 * See InstructionFormats.template, InstructionFormatList.dat,
 * OperatorList.dat, etc.
 */

package org.jikesrvm.compilers.opt.ir.ppc;

import org.jikesrvm.Configuration;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCConditionOperand;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCTrapOperand;
import org.jikesrvm.compilers.opt.ir.operand.*;
import org.jikesrvm.compilers.opt.ir.Instruction;
import org.jikesrvm.compilers.opt.ir.Operator;

/**
 * The MIR_Call InstructionFormat class.
 *
 * The header comment for {@link Instruction} contains
 * an explanation of the role of InstructionFormats in the
 * opt compiler's IR.
 */
@SuppressWarnings("unused")  // Machine generated code is never 100% clean
public final class MIR_Call extends ArchInstructionFormat {
  /**
   * InstructionFormat identification method for MIR_Call.
   * @param i an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         instruction is MIR_Call or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Instruction i) {
    return conforms(i.operator());
  }
  /**
   * InstructionFormat identification method for MIR_Call.
   * @param o an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         operator is MIR_Call or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Operator o) {
    return o.format == MIR_Call_format;
  }

  /**
   * Get the operand called Result from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Result
   */
  public static RegisterOperand getResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Call");
    return (RegisterOperand) i.getOperand(0);
  }
  /**
   * Get the operand called Result from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Result
   */
  public static RegisterOperand getClearResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Call");
    return (RegisterOperand) i.getClearOperand(0);
  }
  /**
   * Set the operand called Result in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Result the operand to store
   */
  public static void setResult(Instruction i, RegisterOperand Result) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Call");
    i.putOperand(0, Result);
  }
  /**
   * Return the index of the operand called Result
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Result
   *         in the argument instruction
   */
  public static int indexOfResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Call");
    return 0;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Result?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Result or <code>false</code>
   *         if it does not.
   */
  public static boolean hasResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Call");
    return i.getOperand(0) != null;
  }

  /**
   * Get the operand called Result2 from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Result2
   */
  public static RegisterOperand getResult2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Call");
    return (RegisterOperand) i.getOperand(1);
  }
  /**
   * Get the operand called Result2 from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Result2
   */
  public static RegisterOperand getClearResult2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Call");
    return (RegisterOperand) i.getClearOperand(1);
  }
  /**
   * Set the operand called Result2 in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Result2 the operand to store
   */
  public static void setResult2(Instruction i, RegisterOperand Result2) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Call");
    i.putOperand(1, Result2);
  }
  /**
   * Return the index of the operand called Result2
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Result2
   *         in the argument instruction
   */
  public static int indexOfResult2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Call");
    return 1;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Result2?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Result2 or <code>false</code>
   *         if it does not.
   */
  public static boolean hasResult2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Call");
    return i.getOperand(1) != null;
  }

  /**
   * Get the operand called Target from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Target
   */
  public static BranchOperand getTarget(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Call");
    return (BranchOperand) i.getOperand(2);
  }
  /**
   * Get the operand called Target from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Target
   */
  public static BranchOperand getClearTarget(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Call");
    return (BranchOperand) i.getClearOperand(2);
  }
  /**
   * Set the operand called Target in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Target the operand to store
   */
  public static void setTarget(Instruction i, BranchOperand Target) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Call");
    i.putOperand(2, Target);
  }
  /**
   * Return the index of the operand called Target
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Target
   *         in the argument instruction
   */
  public static int indexOfTarget(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Call");
    return 2;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Target?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Target or <code>false</code>
   *         if it does not.
   */
  public static boolean hasTarget(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Call");
    return i.getOperand(2) != null;
  }

  /**
   * Get the operand called Method from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Method
   */
  public static MethodOperand getMethod(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Call");
    return (MethodOperand) i.getOperand(3);
  }
  /**
   * Get the operand called Method from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Method
   */
  public static MethodOperand getClearMethod(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Call");
    return (MethodOperand) i.getClearOperand(3);
  }
  /**
   * Set the operand called Method in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Method the operand to store
   */
  public static void setMethod(Instruction i, MethodOperand Method) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Call");
    i.putOperand(3, Method);
  }
  /**
   * Return the index of the operand called Method
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Method
   *         in the argument instruction
   */
  public static int indexOfMethod(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Call");
    return 3;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Method?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Method or <code>false</code>
   *         if it does not.
   */
  public static boolean hasMethod(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Call");
    return i.getOperand(3) != null;
  }

  /**
   * Get the k'th operand called Param from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @param k the index of the operand
   * @return the k'th operand called Param
   */
  public static Operand getParam(Instruction i, int k) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Call");
    return (Operand) i.getOperand(4+k);
  }
  /**
   * Get the k'th operand called Param from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @param k the index of the operand
   * @return the k'th operand called Param
   */
  public static Operand getClearParam(Instruction i, int k) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Call");
    return (Operand) i.getClearOperand(4+k);
  }
  /**
   * Set the k'th operand called Param in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param k the index of the operand
   * @param o the operand to store
   */
  public static void setParam(Instruction i, int k, Operand o) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Call");
    i.putOperand(4+k, o);
  }
  /**
   * Return the index of the k'th operand called Param
   * in the argument instruction.
   * @param i the instruction to access.
   * @param k the index of the operand.
   * @return the index of the k'th operand called Param
   *         in the argument instruction
   */
  public static int indexOfParam(Instruction i, int k) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Call");
    return 4+k;
  }
  /**
   * Does the argument instruction have a non-null
   * k'th operand named Param?
   * @param i the instruction to access.
   * @param k the index of the operand.
   * @return <code>true</code> if the instruction has an non-null
   *         k'th operand named Param or <code>false</code>
   *         if it does not.
   */
  public static boolean hasParam(Instruction i, int k) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Call");
    return i.getOperand(4+k) != null;
  }

  /**
   * Return the index of the first operand called Param
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the first operand called Param
   *         in the argument instruction
   */
  public static int indexOfParams(Instruction i)
  {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Call");
    return 4;
  }
  /**
   * Does the argument instruction have any operands
   * named Param?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has operands
   *         named Param or <code>false</code> if it does not.
   */
  public static boolean hasParams(Instruction i)
  {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Call");
    return i.getNumberOfOperands()-4 > 0 && i.getOperand(4) != null;
  }

  /**
   * How many variable-length operands called Params
   * does the argument instruction have?
   * @param i the instruction to access
   * @return the number of operands called Params the instruction has
   */
  public static int getNumberOfParams(Instruction i)
  {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Call");
    return i.getNumberOfOperands()-4;
  }

  /**
   * Change the number of Params that may be stored in
   * the argument instruction to numVarOps.
   * @param i the instruction to access
   * @param numVarOps the new number of variable operands called Params
   *        that may be stored in the instruction
   */
  public static void resizeNumberOfParams(Instruction i, int numVarOps)
  {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Call");
  if (4+numVarOps>MIN_OPERAND_ARRAY_LENGTH)
    i.resizeNumberOfOperands(4+numVarOps);
  else
    for (int j = 4+numVarOps; j < MIN_OPERAND_ARRAY_LENGTH; j++)
      i.putOperand(j, null);
  }

  /**
   * Create an instruction of the MIR_Call instruction format.
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Result2 the instruction's Result2 operand
   * @param Target the instruction's Target operand
   * @param Method the instruction's Method operand
   * @param numVarOps the number of variable length operands that
   *                 will be stored in the insruction.
   * @return the newly created MIR_Call instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Result
                   , RegisterOperand Result2
                   , BranchOperand Target
                   , MethodOperand Method
                   , int numVarOps
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Call");
    Instruction i = Instruction.create(o, Math.max(4+numVarOps, MIN_OPERAND_ARRAY_LENGTH));
    i.putOperand(0, Result);
    i.putOperand(1, Result2);
    i.putOperand(2, Target);
    i.putOperand(3, Method);
    return i;
  }
  /**
   * Create an instruction of the MIR_Call instruction format
   * with 0 variable arguments.
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Result2 the instruction's Result2 operand
   * @param Target the instruction's Target operand
   * @param Method the instruction's Method operand
   * @return the newly created MIR_Call instruction
   */
  public static Instruction create0(Operator o
                   , RegisterOperand Result
                   , RegisterOperand Result2
                   , BranchOperand Target
                   , MethodOperand Method
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Call");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Result);
    i.putOperand(1, Result2);
    i.putOperand(2, Target);
    i.putOperand(3, Method);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_Call instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Result2 the instruction's Result2 operand
   * @param Target the instruction's Target operand
   * @param Method the instruction's Method operand
   * @param numVarOps the number of variable length operands that
   *                  will be stored in the insruction.
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Result
                   , RegisterOperand Result2
                   , BranchOperand Target
                   , MethodOperand Method
                   , int numVarOps
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Call");
    if (4+numVarOps>MIN_OPERAND_ARRAY_LENGTH)
      i.resizeNumberOfOperands(4+numVarOps);

    i.changeOperatorTo(o);
    i.putOperand(0, Result);
    i.putOperand(1, Result2);
    i.putOperand(2, Target);
    i.putOperand(3, Method);
    return i;
  }
  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_Call instruction format having the specified
   * operator, operands, and number of variable-length operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Result2 the instruction's Result2 operand
   * @param Target the instruction's Target operand
   * @param Method the instruction's Method operand
   * @return the mutated instruction
   */
  public static Instruction mutate0(Instruction i, Operator o
                   , RegisterOperand Result
                   , RegisterOperand Result2
                   , BranchOperand Target
                   , MethodOperand Method
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Call");
    i.changeOperatorTo(o);
    i.putOperand(0, Result);
    i.putOperand(1, Result2);
    i.putOperand(2, Target);
    i.putOperand(3, Method);
    return i;
  }
  /**
   * Create an instruction of the MIR_Call instruction format.
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Result2 the instruction's Result2 operand
   * @param Target the instruction's Target operand
   * @param numVarOps the number of variable length operands that
   *                 will be stored in the insruction.
   * @return the newly created MIR_Call instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Result
                   , RegisterOperand Result2
                   , BranchOperand Target
                   , int numVarOps
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Call");
    Instruction i = Instruction.create(o, Math.max(4+numVarOps, MIN_OPERAND_ARRAY_LENGTH));
    i.putOperand(0, Result);
    i.putOperand(1, Result2);
    i.putOperand(2, Target);
    return i;
  }
  /**
   * Create an instruction of the MIR_Call instruction format
   * with 0 variable arguments.
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Result2 the instruction's Result2 operand
   * @param Target the instruction's Target operand
   * @return the newly created MIR_Call instruction
   */
  public static Instruction create0(Operator o
                   , RegisterOperand Result
                   , RegisterOperand Result2
                   , BranchOperand Target
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Call");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Result);
    i.putOperand(1, Result2);
    i.putOperand(2, Target);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_Call instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Result2 the instruction's Result2 operand
   * @param Target the instruction's Target operand
   * @param numVarOps the number of variable length operands that
   *                  will be stored in the insruction.
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Result
                   , RegisterOperand Result2
                   , BranchOperand Target
                   , int numVarOps
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Call");
    if (4+numVarOps>MIN_OPERAND_ARRAY_LENGTH)
      i.resizeNumberOfOperands(4+numVarOps);

    i.changeOperatorTo(o);
    i.putOperand(0, Result);
    i.putOperand(1, Result2);
    i.putOperand(2, Target);
    i.putOperand(3, null);
    return i;
  }
  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_Call instruction format having the specified
   * operator, operands, and number of variable-length operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Result2 the instruction's Result2 operand
   * @param Target the instruction's Target operand
   * @return the mutated instruction
   */
  public static Instruction mutate0(Instruction i, Operator o
                   , RegisterOperand Result
                   , RegisterOperand Result2
                   , BranchOperand Target
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Call");
    i.changeOperatorTo(o);
    i.putOperand(0, Result);
    i.putOperand(1, Result2);
    i.putOperand(2, Target);
    i.putOperand(3, null);
    return i;
  }
  /**
   * Create an instruction of the MIR_Call instruction format.
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Result2 the instruction's Result2 operand
   * @param Method the instruction's Method operand
   * @param numVarOps the number of variable length operands that
   *                 will be stored in the insruction.
   * @return the newly created MIR_Call instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Result
                   , RegisterOperand Result2
                   , MethodOperand Method
                   , int numVarOps
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Call");
    Instruction i = Instruction.create(o, Math.max(4+numVarOps, MIN_OPERAND_ARRAY_LENGTH));
    i.putOperand(0, Result);
    i.putOperand(1, Result2);
    i.putOperand(3, Method);
    return i;
  }
  /**
   * Create an instruction of the MIR_Call instruction format
   * with 0 variable arguments.
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Result2 the instruction's Result2 operand
   * @param Method the instruction's Method operand
   * @return the newly created MIR_Call instruction
   */
  public static Instruction create0(Operator o
                   , RegisterOperand Result
                   , RegisterOperand Result2
                   , MethodOperand Method
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Call");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Result);
    i.putOperand(1, Result2);
    i.putOperand(3, Method);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_Call instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Result2 the instruction's Result2 operand
   * @param Method the instruction's Method operand
   * @param numVarOps the number of variable length operands that
   *                  will be stored in the insruction.
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Result
                   , RegisterOperand Result2
                   , MethodOperand Method
                   , int numVarOps
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Call");
    if (4+numVarOps>MIN_OPERAND_ARRAY_LENGTH)
      i.resizeNumberOfOperands(4+numVarOps);

    i.changeOperatorTo(o);
    i.putOperand(0, Result);
    i.putOperand(1, Result2);
    i.putOperand(2, null);
    i.putOperand(3, Method);
    return i;
  }
  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_Call instruction format having the specified
   * operator, operands, and number of variable-length operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Result2 the instruction's Result2 operand
   * @param Method the instruction's Method operand
   * @return the mutated instruction
   */
  public static Instruction mutate0(Instruction i, Operator o
                   , RegisterOperand Result
                   , RegisterOperand Result2
                   , MethodOperand Method
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Call");
    i.changeOperatorTo(o);
    i.putOperand(0, Result);
    i.putOperand(1, Result2);
    i.putOperand(2, null);
    i.putOperand(3, Method);
    return i;
  }
  /**
   * Create an instruction of the MIR_Call instruction format.
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Result2 the instruction's Result2 operand
   * @param numVarOps the number of variable length operands that
   *                 will be stored in the insruction.
   * @return the newly created MIR_Call instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Result
                   , RegisterOperand Result2
                   , int numVarOps
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Call");
    Instruction i = Instruction.create(o, Math.max(4+numVarOps, MIN_OPERAND_ARRAY_LENGTH));
    i.putOperand(0, Result);
    i.putOperand(1, Result2);
    return i;
  }
  /**
   * Create an instruction of the MIR_Call instruction format
   * with 0 variable arguments.
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Result2 the instruction's Result2 operand
   * @return the newly created MIR_Call instruction
   */
  public static Instruction create0(Operator o
                   , RegisterOperand Result
                   , RegisterOperand Result2
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Call");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Result);
    i.putOperand(1, Result2);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_Call instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Result2 the instruction's Result2 operand
   * @param numVarOps the number of variable length operands that
   *                  will be stored in the insruction.
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Result
                   , RegisterOperand Result2
                   , int numVarOps
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Call");
    if (4+numVarOps>MIN_OPERAND_ARRAY_LENGTH)
      i.resizeNumberOfOperands(4+numVarOps);

    i.changeOperatorTo(o);
    i.putOperand(0, Result);
    i.putOperand(1, Result2);
    i.putOperand(2, null);
    i.putOperand(3, null);
    return i;
  }
  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_Call instruction format having the specified
   * operator, operands, and number of variable-length operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Result2 the instruction's Result2 operand
   * @return the mutated instruction
   */
  public static Instruction mutate0(Instruction i, Operator o
                   , RegisterOperand Result
                   , RegisterOperand Result2
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Call");
    i.changeOperatorTo(o);
    i.putOperand(0, Result);
    i.putOperand(1, Result2);
    i.putOperand(2, null);
    i.putOperand(3, null);
    return i;
  }
}

##NEW_FILE_STARTS_HERE MIR_CondCall.java##

/*
 * THIS FILE IS MACHINE_GENERATED. DO NOT EDIT.
 * See InstructionFormats.template, InstructionFormatList.dat,
 * OperatorList.dat, etc.
 */

package org.jikesrvm.compilers.opt.ir.ppc;

import org.jikesrvm.Configuration;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCConditionOperand;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCTrapOperand;
import org.jikesrvm.compilers.opt.ir.operand.*;
import org.jikesrvm.compilers.opt.ir.Instruction;
import org.jikesrvm.compilers.opt.ir.Operator;

/**
 * The MIR_CondCall InstructionFormat class.
 *
 * The header comment for {@link Instruction} contains
 * an explanation of the role of InstructionFormats in the
 * opt compiler's IR.
 */
@SuppressWarnings("unused")  // Machine generated code is never 100% clean
public final class MIR_CondCall extends ArchInstructionFormat {
  /**
   * InstructionFormat identification method for MIR_CondCall.
   * @param i an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         instruction is MIR_CondCall or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Instruction i) {
    return conforms(i.operator());
  }
  /**
   * InstructionFormat identification method for MIR_CondCall.
   * @param o an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         operator is MIR_CondCall or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Operator o) {
    return o.format == MIR_CondCall_format;
  }

  /**
   * Get the operand called Result from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Result
   */
  public static RegisterOperand getResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
    return (RegisterOperand) i.getOperand(0);
  }
  /**
   * Get the operand called Result from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Result
   */
  public static RegisterOperand getClearResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
    return (RegisterOperand) i.getClearOperand(0);
  }
  /**
   * Set the operand called Result in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Result the operand to store
   */
  public static void setResult(Instruction i, RegisterOperand Result) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
    i.putOperand(0, Result);
  }
  /**
   * Return the index of the operand called Result
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Result
   *         in the argument instruction
   */
  public static int indexOfResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
    return 0;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Result?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Result or <code>false</code>
   *         if it does not.
   */
  public static boolean hasResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
    return i.getOperand(0) != null;
  }

  /**
   * Get the operand called Result2 from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Result2
   */
  public static RegisterOperand getResult2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
    return (RegisterOperand) i.getOperand(1);
  }
  /**
   * Get the operand called Result2 from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Result2
   */
  public static RegisterOperand getClearResult2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
    return (RegisterOperand) i.getClearOperand(1);
  }
  /**
   * Set the operand called Result2 in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Result2 the operand to store
   */
  public static void setResult2(Instruction i, RegisterOperand Result2) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
    i.putOperand(1, Result2);
  }
  /**
   * Return the index of the operand called Result2
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Result2
   *         in the argument instruction
   */
  public static int indexOfResult2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
    return 1;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Result2?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Result2 or <code>false</code>
   *         if it does not.
   */
  public static boolean hasResult2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
    return i.getOperand(1) != null;
  }

  /**
   * Get the operand called Value from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value
   */
  public static RegisterOperand getValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
    return (RegisterOperand) i.getOperand(2);
  }
  /**
   * Get the operand called Value from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value
   */
  public static RegisterOperand getClearValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
    return (RegisterOperand) i.getClearOperand(2);
  }
  /**
   * Set the operand called Value in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Value the operand to store
   */
  public static void setValue(Instruction i, RegisterOperand Value) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
    i.putOperand(2, Value);
  }
  /**
   * Return the index of the operand called Value
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Value
   *         in the argument instruction
   */
  public static int indexOfValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
    return 2;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Value?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Value or <code>false</code>
   *         if it does not.
   */
  public static boolean hasValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
    return i.getOperand(2) != null;
  }

  /**
   * Get the operand called Cond from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Cond
   */
  public static PowerPCConditionOperand getCond(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
    return (PowerPCConditionOperand) i.getOperand(3);
  }
  /**
   * Get the operand called Cond from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Cond
   */
  public static PowerPCConditionOperand getClearCond(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
    return (PowerPCConditionOperand) i.getClearOperand(3);
  }
  /**
   * Set the operand called Cond in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Cond the operand to store
   */
  public static void setCond(Instruction i, PowerPCConditionOperand Cond) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
    i.putOperand(3, Cond);
  }
  /**
   * Return the index of the operand called Cond
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Cond
   *         in the argument instruction
   */
  public static int indexOfCond(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
    return 3;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Cond?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Cond or <code>false</code>
   *         if it does not.
   */
  public static boolean hasCond(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
    return i.getOperand(3) != null;
  }

  /**
   * Get the operand called Target from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Target
   */
  public static BranchOperand getTarget(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
    return (BranchOperand) i.getOperand(4);
  }
  /**
   * Get the operand called Target from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Target
   */
  public static BranchOperand getClearTarget(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
    return (BranchOperand) i.getClearOperand(4);
  }
  /**
   * Set the operand called Target in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Target the operand to store
   */
  public static void setTarget(Instruction i, BranchOperand Target) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
    i.putOperand(4, Target);
  }
  /**
   * Return the index of the operand called Target
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Target
   *         in the argument instruction
   */
  public static int indexOfTarget(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
    return 4;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Target?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Target or <code>false</code>
   *         if it does not.
   */
  public static boolean hasTarget(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
    return i.getOperand(4) != null;
  }

  /**
   * Get the k'th operand called Param from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @param k the index of the operand
   * @return the k'th operand called Param
   */
  public static Operand getParam(Instruction i, int k) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
    return (Operand) i.getOperand(5+k);
  }
  /**
   * Get the k'th operand called Param from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @param k the index of the operand
   * @return the k'th operand called Param
   */
  public static Operand getClearParam(Instruction i, int k) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
    return (Operand) i.getClearOperand(5+k);
  }
  /**
   * Set the k'th operand called Param in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param k the index of the operand
   * @param o the operand to store
   */
  public static void setParam(Instruction i, int k, Operand o) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
    i.putOperand(5+k, o);
  }
  /**
   * Return the index of the k'th operand called Param
   * in the argument instruction.
   * @param i the instruction to access.
   * @param k the index of the operand.
   * @return the index of the k'th operand called Param
   *         in the argument instruction
   */
  public static int indexOfParam(Instruction i, int k) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
    return 5+k;
  }
  /**
   * Does the argument instruction have a non-null
   * k'th operand named Param?
   * @param i the instruction to access.
   * @param k the index of the operand.
   * @return <code>true</code> if the instruction has an non-null
   *         k'th operand named Param or <code>false</code>
   *         if it does not.
   */
  public static boolean hasParam(Instruction i, int k) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
    return i.getOperand(5+k) != null;
  }

  /**
   * Return the index of the first operand called Param
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the first operand called Param
   *         in the argument instruction
   */
  public static int indexOfParams(Instruction i)
  {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
    return 5;
  }
  /**
   * Does the argument instruction have any operands
   * named Param?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has operands
   *         named Param or <code>false</code> if it does not.
   */
  public static boolean hasParams(Instruction i)
  {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
    return i.getNumberOfOperands()-5 > 0 && i.getOperand(5) != null;
  }

  /**
   * How many variable-length operands called Params
   * does the argument instruction have?
   * @param i the instruction to access
   * @return the number of operands called Params the instruction has
   */
  public static int getNumberOfParams(Instruction i)
  {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
    return i.getNumberOfOperands()-5;
  }

  /**
   * Change the number of Params that may be stored in
   * the argument instruction to numVarOps.
   * @param i the instruction to access
   * @param numVarOps the new number of variable operands called Params
   *        that may be stored in the instruction
   */
  public static void resizeNumberOfParams(Instruction i, int numVarOps)
  {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_CondCall");
  if (5+numVarOps>MIN_OPERAND_ARRAY_LENGTH)
    i.resizeNumberOfOperands(5+numVarOps);
  else
    for (int j = 5+numVarOps; j < MIN_OPERAND_ARRAY_LENGTH; j++)
      i.putOperand(j, null);
  }

  /**
   * Create an instruction of the MIR_CondCall instruction format.
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Result2 the instruction's Result2 operand
   * @param Value the instruction's Value operand
   * @param Cond the instruction's Cond operand
   * @param Target the instruction's Target operand
   * @param numVarOps the number of variable length operands that
   *                 will be stored in the insruction.
   * @return the newly created MIR_CondCall instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Result
                   , RegisterOperand Result2
                   , RegisterOperand Value
                   , PowerPCConditionOperand Cond
                   , BranchOperand Target
                   , int numVarOps
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_CondCall");
    Instruction i = Instruction.create(o, Math.max(5+numVarOps, MIN_OPERAND_ARRAY_LENGTH));
    i.putOperand(0, Result);
    i.putOperand(1, Result2);
    i.putOperand(2, Value);
    i.putOperand(3, Cond);
    i.putOperand(4, Target);
    return i;
  }
  /**
   * Create an instruction of the MIR_CondCall instruction format
   * with 0 variable arguments.
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Result2 the instruction's Result2 operand
   * @param Value the instruction's Value operand
   * @param Cond the instruction's Cond operand
   * @param Target the instruction's Target operand
   * @return the newly created MIR_CondCall instruction
   */
  public static Instruction create0(Operator o
                   , RegisterOperand Result
                   , RegisterOperand Result2
                   , RegisterOperand Value
                   , PowerPCConditionOperand Cond
                   , BranchOperand Target
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_CondCall");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Result);
    i.putOperand(1, Result2);
    i.putOperand(2, Value);
    i.putOperand(3, Cond);
    i.putOperand(4, Target);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_CondCall instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Result2 the instruction's Result2 operand
   * @param Value the instruction's Value operand
   * @param Cond the instruction's Cond operand
   * @param Target the instruction's Target operand
   * @param numVarOps the number of variable length operands that
   *                  will be stored in the insruction.
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Result
                   , RegisterOperand Result2
                   , RegisterOperand Value
                   , PowerPCConditionOperand Cond
                   , BranchOperand Target
                   , int numVarOps
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_CondCall");
    if (5+numVarOps>MIN_OPERAND_ARRAY_LENGTH)
      i.resizeNumberOfOperands(5+numVarOps);

    i.changeOperatorTo(o);
    i.putOperand(0, Result);
    i.putOperand(1, Result2);
    i.putOperand(2, Value);
    i.putOperand(3, Cond);
    i.putOperand(4, Target);
    return i;
  }
  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_CondCall instruction format having the specified
   * operator, operands, and number of variable-length operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Result2 the instruction's Result2 operand
   * @param Value the instruction's Value operand
   * @param Cond the instruction's Cond operand
   * @param Target the instruction's Target operand
   * @return the mutated instruction
   */
  public static Instruction mutate0(Instruction i, Operator o
                   , RegisterOperand Result
                   , RegisterOperand Result2
                   , RegisterOperand Value
                   , PowerPCConditionOperand Cond
                   , BranchOperand Target
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_CondCall");
    i.changeOperatorTo(o);
    i.putOperand(0, Result);
    i.putOperand(1, Result2);
    i.putOperand(2, Value);
    i.putOperand(3, Cond);
    i.putOperand(4, Target);
    return i;
  }
  /**
   * Create an instruction of the MIR_CondCall instruction format.
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Result2 the instruction's Result2 operand
   * @param Value the instruction's Value operand
   * @param Cond the instruction's Cond operand
   * @param numVarOps the number of variable length operands that
   *                 will be stored in the insruction.
   * @return the newly created MIR_CondCall instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Result
                   , RegisterOperand Result2
                   , RegisterOperand Value
                   , PowerPCConditionOperand Cond
                   , int numVarOps
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_CondCall");
    Instruction i = Instruction.create(o, Math.max(5+numVarOps, MIN_OPERAND_ARRAY_LENGTH));
    i.putOperand(0, Result);
    i.putOperand(1, Result2);
    i.putOperand(2, Value);
    i.putOperand(3, Cond);
    return i;
  }
  /**
   * Create an instruction of the MIR_CondCall instruction format
   * with 0 variable arguments.
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Result2 the instruction's Result2 operand
   * @param Value the instruction's Value operand
   * @param Cond the instruction's Cond operand
   * @return the newly created MIR_CondCall instruction
   */
  public static Instruction create0(Operator o
                   , RegisterOperand Result
                   , RegisterOperand Result2
                   , RegisterOperand Value
                   , PowerPCConditionOperand Cond
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_CondCall");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Result);
    i.putOperand(1, Result2);
    i.putOperand(2, Value);
    i.putOperand(3, Cond);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_CondCall instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Result2 the instruction's Result2 operand
   * @param Value the instruction's Value operand
   * @param Cond the instruction's Cond operand
   * @param numVarOps the number of variable length operands that
   *                  will be stored in the insruction.
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Result
                   , RegisterOperand Result2
                   , RegisterOperand Value
                   , PowerPCConditionOperand Cond
                   , int numVarOps
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_CondCall");
    if (5+numVarOps>MIN_OPERAND_ARRAY_LENGTH)
      i.resizeNumberOfOperands(5+numVarOps);

    i.changeOperatorTo(o);
    i.putOperand(0, Result);
    i.putOperand(1, Result2);
    i.putOperand(2, Value);
    i.putOperand(3, Cond);
    i.putOperand(4, null);
    return i;
  }
  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_CondCall instruction format having the specified
   * operator, operands, and number of variable-length operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Result2 the instruction's Result2 operand
   * @param Value the instruction's Value operand
   * @param Cond the instruction's Cond operand
   * @return the mutated instruction
   */
  public static Instruction mutate0(Instruction i, Operator o
                   , RegisterOperand Result
                   , RegisterOperand Result2
                   , RegisterOperand Value
                   , PowerPCConditionOperand Cond
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_CondCall");
    i.changeOperatorTo(o);
    i.putOperand(0, Result);
    i.putOperand(1, Result2);
    i.putOperand(2, Value);
    i.putOperand(3, Cond);
    i.putOperand(4, null);
    return i;
  }
}

##NEW_FILE_STARTS_HERE MIR_Return.java##

/*
 * THIS FILE IS MACHINE_GENERATED. DO NOT EDIT.
 * See InstructionFormats.template, InstructionFormatList.dat,
 * OperatorList.dat, etc.
 */

package org.jikesrvm.compilers.opt.ir.ppc;

import org.jikesrvm.Configuration;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCConditionOperand;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCTrapOperand;
import org.jikesrvm.compilers.opt.ir.operand.*;
import org.jikesrvm.compilers.opt.ir.Instruction;
import org.jikesrvm.compilers.opt.ir.Operator;

/**
 * The MIR_Return InstructionFormat class.
 *
 * The header comment for {@link Instruction} contains
 * an explanation of the role of InstructionFormats in the
 * opt compiler's IR.
 */
@SuppressWarnings("unused")  // Machine generated code is never 100% clean
public final class MIR_Return extends ArchInstructionFormat {
  /**
   * InstructionFormat identification method for MIR_Return.
   * @param i an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         instruction is MIR_Return or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Instruction i) {
    return conforms(i.operator());
  }
  /**
   * InstructionFormat identification method for MIR_Return.
   * @param o an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         operator is MIR_Return or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Operator o) {
    return o.format == MIR_Return_format;
  }

  /**
   * Get the operand called Val from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Val
   */
  public static RegisterOperand getVal(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Return");
    return (RegisterOperand) i.getOperand(0);
  }
  /**
   * Get the operand called Val from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Val
   */
  public static RegisterOperand getClearVal(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Return");
    return (RegisterOperand) i.getClearOperand(0);
  }
  /**
   * Set the operand called Val in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Val the operand to store
   */
  public static void setVal(Instruction i, RegisterOperand Val) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Return");
    i.putOperand(0, Val);
  }
  /**
   * Return the index of the operand called Val
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Val
   *         in the argument instruction
   */
  public static int indexOfVal(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Return");
    return 0;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Val?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Val or <code>false</code>
   *         if it does not.
   */
  public static boolean hasVal(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Return");
    return i.getOperand(0) != null;
  }

  /**
   * Get the operand called Val2 from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Val2
   */
  public static RegisterOperand getVal2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Return");
    return (RegisterOperand) i.getOperand(1);
  }
  /**
   * Get the operand called Val2 from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Val2
   */
  public static RegisterOperand getClearVal2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Return");
    return (RegisterOperand) i.getClearOperand(1);
  }
  /**
   * Set the operand called Val2 in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Val2 the operand to store
   */
  public static void setVal2(Instruction i, RegisterOperand Val2) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Return");
    i.putOperand(1, Val2);
  }
  /**
   * Return the index of the operand called Val2
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Val2
   *         in the argument instruction
   */
  public static int indexOfVal2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Return");
    return 1;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Val2?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Val2 or <code>false</code>
   *         if it does not.
   */
  public static boolean hasVal2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Return");
    return i.getOperand(1) != null;
  }


  /**
   * Create an instruction of the MIR_Return instruction format.
   * @param o the instruction's operator
   * @param Val the instruction's Val operand
   * @param Val2 the instruction's Val2 operand
   * @return the newly created MIR_Return instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Val
                   , RegisterOperand Val2
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Return");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Val);
    i.putOperand(1, Val2);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_Return instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Val the instruction's Val operand
   * @param Val2 the instruction's Val2 operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Val
                   , RegisterOperand Val2
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Return");
    i.changeOperatorTo(o);
    i.putOperand(0, Val);
    i.putOperand(1, Val2);
    return i;
  }
}

##NEW_FILE_STARTS_HERE MIR_Empty.java##

/*
 * THIS FILE IS MACHINE_GENERATED. DO NOT EDIT.
 * See InstructionFormats.template, InstructionFormatList.dat,
 * OperatorList.dat, etc.
 */

package org.jikesrvm.compilers.opt.ir.ppc;

import org.jikesrvm.Configuration;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCConditionOperand;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCTrapOperand;
import org.jikesrvm.compilers.opt.ir.operand.*;
import org.jikesrvm.compilers.opt.ir.Instruction;
import org.jikesrvm.compilers.opt.ir.Operator;

/**
 * The MIR_Empty InstructionFormat class.
 *
 * The header comment for {@link Instruction} contains
 * an explanation of the role of InstructionFormats in the
 * opt compiler's IR.
 */
@SuppressWarnings("unused")  // Machine generated code is never 100% clean
public final class MIR_Empty extends ArchInstructionFormat {
  /**
   * InstructionFormat identification method for MIR_Empty.
   * @param i an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         instruction is MIR_Empty or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Instruction i) {
    return conforms(i.operator());
  }
  /**
   * InstructionFormat identification method for MIR_Empty.
   * @param o an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         operator is MIR_Empty or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Operator o) {
    return o.format == MIR_Empty_format;
  }


  /**
   * Create an instruction of the MIR_Empty instruction format.
   * @param o the instruction's operator
   * @return the newly created MIR_Empty instruction
   */
  public static Instruction create(Operator o
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Empty");
    Instruction i = Instruction.create(o, 5);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_Empty instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Empty");
    i.changeOperatorTo(o);
    return i;
  }
}

##NEW_FILE_STARTS_HERE MIR_Nullary.java##

/*
 * THIS FILE IS MACHINE_GENERATED. DO NOT EDIT.
 * See InstructionFormats.template, InstructionFormatList.dat,
 * OperatorList.dat, etc.
 */

package org.jikesrvm.compilers.opt.ir.ppc;

import org.jikesrvm.Configuration;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCConditionOperand;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCTrapOperand;
import org.jikesrvm.compilers.opt.ir.operand.*;
import org.jikesrvm.compilers.opt.ir.Instruction;
import org.jikesrvm.compilers.opt.ir.Operator;

/**
 * The MIR_Nullary InstructionFormat class.
 *
 * The header comment for {@link Instruction} contains
 * an explanation of the role of InstructionFormats in the
 * opt compiler's IR.
 */
@SuppressWarnings("unused")  // Machine generated code is never 100% clean
public final class MIR_Nullary extends ArchInstructionFormat {
  /**
   * InstructionFormat identification method for MIR_Nullary.
   * @param i an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         instruction is MIR_Nullary or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Instruction i) {
    return conforms(i.operator());
  }
  /**
   * InstructionFormat identification method for MIR_Nullary.
   * @param o an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         operator is MIR_Nullary or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Operator o) {
    return o.format == MIR_Nullary_format;
  }

  /**
   * Get the operand called Result from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Result
   */
  public static RegisterOperand getResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Nullary");
    return (RegisterOperand) i.getOperand(0);
  }
  /**
   * Get the operand called Result from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Result
   */
  public static RegisterOperand getClearResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Nullary");
    return (RegisterOperand) i.getClearOperand(0);
  }
  /**
   * Set the operand called Result in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Result the operand to store
   */
  public static void setResult(Instruction i, RegisterOperand Result) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Nullary");
    i.putOperand(0, Result);
  }
  /**
   * Return the index of the operand called Result
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Result
   *         in the argument instruction
   */
  public static int indexOfResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Nullary");
    return 0;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Result?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Result or <code>false</code>
   *         if it does not.
   */
  public static boolean hasResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Nullary");
    return i.getOperand(0) != null;
  }


  /**
   * Create an instruction of the MIR_Nullary instruction format.
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @return the newly created MIR_Nullary instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Result
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Nullary");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Result);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_Nullary instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Result
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Nullary");
    i.changeOperatorTo(o);
    i.putOperand(0, Result);
    return i;
  }
}

##NEW_FILE_STARTS_HERE MIR_Unary.java##

/*
 * THIS FILE IS MACHINE_GENERATED. DO NOT EDIT.
 * See InstructionFormats.template, InstructionFormatList.dat,
 * OperatorList.dat, etc.
 */

package org.jikesrvm.compilers.opt.ir.ppc;

import org.jikesrvm.Configuration;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCConditionOperand;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCTrapOperand;
import org.jikesrvm.compilers.opt.ir.operand.*;
import org.jikesrvm.compilers.opt.ir.Instruction;
import org.jikesrvm.compilers.opt.ir.Operator;

/**
 * The MIR_Unary InstructionFormat class.
 *
 * The header comment for {@link Instruction} contains
 * an explanation of the role of InstructionFormats in the
 * opt compiler's IR.
 */
@SuppressWarnings("unused")  // Machine generated code is never 100% clean
public final class MIR_Unary extends ArchInstructionFormat {
  /**
   * InstructionFormat identification method for MIR_Unary.
   * @param i an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         instruction is MIR_Unary or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Instruction i) {
    return conforms(i.operator());
  }
  /**
   * InstructionFormat identification method for MIR_Unary.
   * @param o an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         operator is MIR_Unary or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Operator o) {
    return o.format == MIR_Unary_format;
  }

  /**
   * Get the operand called Result from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Result
   */
  public static RegisterOperand getResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Unary");
    return (RegisterOperand) i.getOperand(0);
  }
  /**
   * Get the operand called Result from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Result
   */
  public static RegisterOperand getClearResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Unary");
    return (RegisterOperand) i.getClearOperand(0);
  }
  /**
   * Set the operand called Result in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Result the operand to store
   */
  public static void setResult(Instruction i, RegisterOperand Result) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Unary");
    i.putOperand(0, Result);
  }
  /**
   * Return the index of the operand called Result
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Result
   *         in the argument instruction
   */
  public static int indexOfResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Unary");
    return 0;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Result?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Result or <code>false</code>
   *         if it does not.
   */
  public static boolean hasResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Unary");
    return i.getOperand(0) != null;
  }

  /**
   * Get the operand called Value from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value
   */
  public static Operand getValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Unary");
    return (Operand) i.getOperand(1);
  }
  /**
   * Get the operand called Value from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value
   */
  public static Operand getClearValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Unary");
    return (Operand) i.getClearOperand(1);
  }
  /**
   * Set the operand called Value in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Value the operand to store
   */
  public static void setValue(Instruction i, Operand Value) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Unary");
    i.putOperand(1, Value);
  }
  /**
   * Return the index of the operand called Value
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Value
   *         in the argument instruction
   */
  public static int indexOfValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Unary");
    return 1;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Value?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Value or <code>false</code>
   *         if it does not.
   */
  public static boolean hasValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Unary");
    return i.getOperand(1) != null;
  }


  /**
   * Create an instruction of the MIR_Unary instruction format.
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Value the instruction's Value operand
   * @return the newly created MIR_Unary instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Result
                   , Operand Value
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Unary");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Result);
    i.putOperand(1, Value);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_Unary instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Value the instruction's Value operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Result
                   , Operand Value
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Unary");
    i.changeOperatorTo(o);
    i.putOperand(0, Result);
    i.putOperand(1, Value);
    return i;
  }
}

##NEW_FILE_STARTS_HERE MIR_Binary.java##

/*
 * THIS FILE IS MACHINE_GENERATED. DO NOT EDIT.
 * See InstructionFormats.template, InstructionFormatList.dat,
 * OperatorList.dat, etc.
 */

package org.jikesrvm.compilers.opt.ir.ppc;

import org.jikesrvm.Configuration;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCConditionOperand;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCTrapOperand;
import org.jikesrvm.compilers.opt.ir.operand.*;
import org.jikesrvm.compilers.opt.ir.Instruction;
import org.jikesrvm.compilers.opt.ir.Operator;

/**
 * The MIR_Binary InstructionFormat class.
 *
 * The header comment for {@link Instruction} contains
 * an explanation of the role of InstructionFormats in the
 * opt compiler's IR.
 */
@SuppressWarnings("unused")  // Machine generated code is never 100% clean
public final class MIR_Binary extends ArchInstructionFormat {
  /**
   * InstructionFormat identification method for MIR_Binary.
   * @param i an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         instruction is MIR_Binary or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Instruction i) {
    return conforms(i.operator());
  }
  /**
   * InstructionFormat identification method for MIR_Binary.
   * @param o an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         operator is MIR_Binary or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Operator o) {
    return o.format == MIR_Binary_format;
  }

  /**
   * Get the operand called Result from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Result
   */
  public static RegisterOperand getResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Binary");
    return (RegisterOperand) i.getOperand(0);
  }
  /**
   * Get the operand called Result from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Result
   */
  public static RegisterOperand getClearResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Binary");
    return (RegisterOperand) i.getClearOperand(0);
  }
  /**
   * Set the operand called Result in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Result the operand to store
   */
  public static void setResult(Instruction i, RegisterOperand Result) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Binary");
    i.putOperand(0, Result);
  }
  /**
   * Return the index of the operand called Result
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Result
   *         in the argument instruction
   */
  public static int indexOfResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Binary");
    return 0;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Result?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Result or <code>false</code>
   *         if it does not.
   */
  public static boolean hasResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Binary");
    return i.getOperand(0) != null;
  }

  /**
   * Get the operand called Value1 from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value1
   */
  public static RegisterOperand getValue1(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Binary");
    return (RegisterOperand) i.getOperand(1);
  }
  /**
   * Get the operand called Value1 from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value1
   */
  public static RegisterOperand getClearValue1(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Binary");
    return (RegisterOperand) i.getClearOperand(1);
  }
  /**
   * Set the operand called Value1 in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Value1 the operand to store
   */
  public static void setValue1(Instruction i, RegisterOperand Value1) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Binary");
    i.putOperand(1, Value1);
  }
  /**
   * Return the index of the operand called Value1
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Value1
   *         in the argument instruction
   */
  public static int indexOfValue1(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Binary");
    return 1;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Value1?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Value1 or <code>false</code>
   *         if it does not.
   */
  public static boolean hasValue1(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Binary");
    return i.getOperand(1) != null;
  }

  /**
   * Get the operand called Value2 from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value2
   */
  public static Operand getValue2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Binary");
    return (Operand) i.getOperand(2);
  }
  /**
   * Get the operand called Value2 from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value2
   */
  public static Operand getClearValue2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Binary");
    return (Operand) i.getClearOperand(2);
  }
  /**
   * Set the operand called Value2 in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Value2 the operand to store
   */
  public static void setValue2(Instruction i, Operand Value2) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Binary");
    i.putOperand(2, Value2);
  }
  /**
   * Return the index of the operand called Value2
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Value2
   *         in the argument instruction
   */
  public static int indexOfValue2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Binary");
    return 2;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Value2?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Value2 or <code>false</code>
   *         if it does not.
   */
  public static boolean hasValue2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Binary");
    return i.getOperand(2) != null;
  }


  /**
   * Create an instruction of the MIR_Binary instruction format.
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Value1 the instruction's Value1 operand
   * @param Value2 the instruction's Value2 operand
   * @return the newly created MIR_Binary instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Result
                   , RegisterOperand Value1
                   , Operand Value2
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Binary");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Result);
    i.putOperand(1, Value1);
    i.putOperand(2, Value2);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_Binary instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Value1 the instruction's Value1 operand
   * @param Value2 the instruction's Value2 operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Result
                   , RegisterOperand Value1
                   , Operand Value2
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Binary");
    i.changeOperatorTo(o);
    i.putOperand(0, Result);
    i.putOperand(1, Value1);
    i.putOperand(2, Value2);
    return i;
  }
}

##NEW_FILE_STARTS_HERE MIR_Condition.java##

/*
 * THIS FILE IS MACHINE_GENERATED. DO NOT EDIT.
 * See InstructionFormats.template, InstructionFormatList.dat,
 * OperatorList.dat, etc.
 */

package org.jikesrvm.compilers.opt.ir.ppc;

import org.jikesrvm.Configuration;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCConditionOperand;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCTrapOperand;
import org.jikesrvm.compilers.opt.ir.operand.*;
import org.jikesrvm.compilers.opt.ir.Instruction;
import org.jikesrvm.compilers.opt.ir.Operator;

/**
 * The MIR_Condition InstructionFormat class.
 *
 * The header comment for {@link Instruction} contains
 * an explanation of the role of InstructionFormats in the
 * opt compiler's IR.
 */
@SuppressWarnings("unused")  // Machine generated code is never 100% clean
public final class MIR_Condition extends ArchInstructionFormat {
  /**
   * InstructionFormat identification method for MIR_Condition.
   * @param i an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         instruction is MIR_Condition or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Instruction i) {
    return conforms(i.operator());
  }
  /**
   * InstructionFormat identification method for MIR_Condition.
   * @param o an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         operator is MIR_Condition or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Operator o) {
    return o.format == MIR_Condition_format;
  }

  /**
   * Get the operand called ResultBit from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called ResultBit
   */
  public static IntConstantOperand getResultBit(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Condition");
    return (IntConstantOperand) i.getOperand(0);
  }
  /**
   * Get the operand called ResultBit from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called ResultBit
   */
  public static IntConstantOperand getClearResultBit(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Condition");
    return (IntConstantOperand) i.getClearOperand(0);
  }
  /**
   * Set the operand called ResultBit in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param ResultBit the operand to store
   */
  public static void setResultBit(Instruction i, IntConstantOperand ResultBit) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Condition");
    i.putOperand(0, ResultBit);
  }
  /**
   * Return the index of the operand called ResultBit
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called ResultBit
   *         in the argument instruction
   */
  public static int indexOfResultBit(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Condition");
    return 0;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named ResultBit?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named ResultBit or <code>false</code>
   *         if it does not.
   */
  public static boolean hasResultBit(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Condition");
    return i.getOperand(0) != null;
  }

  /**
   * Get the operand called Value1Bit from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value1Bit
   */
  public static IntConstantOperand getValue1Bit(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Condition");
    return (IntConstantOperand) i.getOperand(1);
  }
  /**
   * Get the operand called Value1Bit from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value1Bit
   */
  public static IntConstantOperand getClearValue1Bit(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Condition");
    return (IntConstantOperand) i.getClearOperand(1);
  }
  /**
   * Set the operand called Value1Bit in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Value1Bit the operand to store
   */
  public static void setValue1Bit(Instruction i, IntConstantOperand Value1Bit) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Condition");
    i.putOperand(1, Value1Bit);
  }
  /**
   * Return the index of the operand called Value1Bit
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Value1Bit
   *         in the argument instruction
   */
  public static int indexOfValue1Bit(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Condition");
    return 1;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Value1Bit?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Value1Bit or <code>false</code>
   *         if it does not.
   */
  public static boolean hasValue1Bit(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Condition");
    return i.getOperand(1) != null;
  }

  /**
   * Get the operand called Value2Bit from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value2Bit
   */
  public static IntConstantOperand getValue2Bit(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Condition");
    return (IntConstantOperand) i.getOperand(2);
  }
  /**
   * Get the operand called Value2Bit from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value2Bit
   */
  public static IntConstantOperand getClearValue2Bit(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Condition");
    return (IntConstantOperand) i.getClearOperand(2);
  }
  /**
   * Set the operand called Value2Bit in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Value2Bit the operand to store
   */
  public static void setValue2Bit(Instruction i, IntConstantOperand Value2Bit) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Condition");
    i.putOperand(2, Value2Bit);
  }
  /**
   * Return the index of the operand called Value2Bit
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Value2Bit
   *         in the argument instruction
   */
  public static int indexOfValue2Bit(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Condition");
    return 2;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Value2Bit?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Value2Bit or <code>false</code>
   *         if it does not.
   */
  public static boolean hasValue2Bit(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Condition");
    return i.getOperand(2) != null;
  }


  /**
   * Create an instruction of the MIR_Condition instruction format.
   * @param o the instruction's operator
   * @param ResultBit the instruction's ResultBit operand
   * @param Value1Bit the instruction's Value1Bit operand
   * @param Value2Bit the instruction's Value2Bit operand
   * @return the newly created MIR_Condition instruction
   */
  public static Instruction create(Operator o
                   , IntConstantOperand ResultBit
                   , IntConstantOperand Value1Bit
                   , IntConstantOperand Value2Bit
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Condition");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, ResultBit);
    i.putOperand(1, Value1Bit);
    i.putOperand(2, Value2Bit);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_Condition instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param ResultBit the instruction's ResultBit operand
   * @param Value1Bit the instruction's Value1Bit operand
   * @param Value2Bit the instruction's Value2Bit operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , IntConstantOperand ResultBit
                   , IntConstantOperand Value1Bit
                   , IntConstantOperand Value2Bit
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Condition");
    i.changeOperatorTo(o);
    i.putOperand(0, ResultBit);
    i.putOperand(1, Value1Bit);
    i.putOperand(2, Value2Bit);
    return i;
  }
}

##NEW_FILE_STARTS_HERE MIR_Ternary.java##

/*
 * THIS FILE IS MACHINE_GENERATED. DO NOT EDIT.
 * See InstructionFormats.template, InstructionFormatList.dat,
 * OperatorList.dat, etc.
 */

package org.jikesrvm.compilers.opt.ir.ppc;

import org.jikesrvm.Configuration;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCConditionOperand;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCTrapOperand;
import org.jikesrvm.compilers.opt.ir.operand.*;
import org.jikesrvm.compilers.opt.ir.Instruction;
import org.jikesrvm.compilers.opt.ir.Operator;

/**
 * The MIR_Ternary InstructionFormat class.
 *
 * The header comment for {@link Instruction} contains
 * an explanation of the role of InstructionFormats in the
 * opt compiler's IR.
 */
@SuppressWarnings("unused")  // Machine generated code is never 100% clean
public final class MIR_Ternary extends ArchInstructionFormat {
  /**
   * InstructionFormat identification method for MIR_Ternary.
   * @param i an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         instruction is MIR_Ternary or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Instruction i) {
    return conforms(i.operator());
  }
  /**
   * InstructionFormat identification method for MIR_Ternary.
   * @param o an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         operator is MIR_Ternary or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Operator o) {
    return o.format == MIR_Ternary_format;
  }

  /**
   * Get the operand called Result from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Result
   */
  public static RegisterOperand getResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Ternary");
    return (RegisterOperand) i.getOperand(0);
  }
  /**
   * Get the operand called Result from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Result
   */
  public static RegisterOperand getClearResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Ternary");
    return (RegisterOperand) i.getClearOperand(0);
  }
  /**
   * Set the operand called Result in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Result the operand to store
   */
  public static void setResult(Instruction i, RegisterOperand Result) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Ternary");
    i.putOperand(0, Result);
  }
  /**
   * Return the index of the operand called Result
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Result
   *         in the argument instruction
   */
  public static int indexOfResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Ternary");
    return 0;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Result?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Result or <code>false</code>
   *         if it does not.
   */
  public static boolean hasResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Ternary");
    return i.getOperand(0) != null;
  }

  /**
   * Get the operand called Value1 from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value1
   */
  public static RegisterOperand getValue1(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Ternary");
    return (RegisterOperand) i.getOperand(1);
  }
  /**
   * Get the operand called Value1 from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value1
   */
  public static RegisterOperand getClearValue1(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Ternary");
    return (RegisterOperand) i.getClearOperand(1);
  }
  /**
   * Set the operand called Value1 in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Value1 the operand to store
   */
  public static void setValue1(Instruction i, RegisterOperand Value1) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Ternary");
    i.putOperand(1, Value1);
  }
  /**
   * Return the index of the operand called Value1
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Value1
   *         in the argument instruction
   */
  public static int indexOfValue1(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Ternary");
    return 1;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Value1?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Value1 or <code>false</code>
   *         if it does not.
   */
  public static boolean hasValue1(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Ternary");
    return i.getOperand(1) != null;
  }

  /**
   * Get the operand called Value2 from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value2
   */
  public static RegisterOperand getValue2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Ternary");
    return (RegisterOperand) i.getOperand(2);
  }
  /**
   * Get the operand called Value2 from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value2
   */
  public static RegisterOperand getClearValue2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Ternary");
    return (RegisterOperand) i.getClearOperand(2);
  }
  /**
   * Set the operand called Value2 in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Value2 the operand to store
   */
  public static void setValue2(Instruction i, RegisterOperand Value2) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Ternary");
    i.putOperand(2, Value2);
  }
  /**
   * Return the index of the operand called Value2
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Value2
   *         in the argument instruction
   */
  public static int indexOfValue2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Ternary");
    return 2;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Value2?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Value2 or <code>false</code>
   *         if it does not.
   */
  public static boolean hasValue2(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Ternary");
    return i.getOperand(2) != null;
  }

  /**
   * Get the operand called Value3 from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value3
   */
  public static RegisterOperand getValue3(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Ternary");
    return (RegisterOperand) i.getOperand(3);
  }
  /**
   * Get the operand called Value3 from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value3
   */
  public static RegisterOperand getClearValue3(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Ternary");
    return (RegisterOperand) i.getClearOperand(3);
  }
  /**
   * Set the operand called Value3 in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Value3 the operand to store
   */
  public static void setValue3(Instruction i, RegisterOperand Value3) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Ternary");
    i.putOperand(3, Value3);
  }
  /**
   * Return the index of the operand called Value3
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Value3
   *         in the argument instruction
   */
  public static int indexOfValue3(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Ternary");
    return 3;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Value3?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Value3 or <code>false</code>
   *         if it does not.
   */
  public static boolean hasValue3(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_Ternary");
    return i.getOperand(3) != null;
  }


  /**
   * Create an instruction of the MIR_Ternary instruction format.
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Value1 the instruction's Value1 operand
   * @param Value2 the instruction's Value2 operand
   * @param Value3 the instruction's Value3 operand
   * @return the newly created MIR_Ternary instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Result
                   , RegisterOperand Value1
                   , RegisterOperand Value2
                   , RegisterOperand Value3
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Ternary");
    Instruction i = Instruction.create(o, 5);
    i.putOperand(0, Result);
    i.putOperand(1, Value1);
    i.putOperand(2, Value2);
    i.putOperand(3, Value3);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_Ternary instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Value1 the instruction's Value1 operand
   * @param Value2 the instruction's Value2 operand
   * @param Value3 the instruction's Value3 operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Result
                   , RegisterOperand Value1
                   , RegisterOperand Value2
                   , RegisterOperand Value3
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_Ternary");
    i.changeOperatorTo(o);
    i.putOperand(0, Result);
    i.putOperand(1, Value1);
    i.putOperand(2, Value2);
    i.putOperand(3, Value3);
    return i;
  }
}

##NEW_FILE_STARTS_HERE MIR_LowTableSwitch.java##

/*
 * THIS FILE IS MACHINE_GENERATED. DO NOT EDIT.
 * See InstructionFormats.template, InstructionFormatList.dat,
 * OperatorList.dat, etc.
 */

package org.jikesrvm.compilers.opt.ir.ppc;

import org.jikesrvm.Configuration;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCConditionOperand;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCTrapOperand;
import org.jikesrvm.compilers.opt.ir.operand.*;
import org.jikesrvm.compilers.opt.ir.Instruction;
import org.jikesrvm.compilers.opt.ir.Operator;

/**
 * The MIR_LowTableSwitch InstructionFormat class.
 *
 * The header comment for {@link Instruction} contains
 * an explanation of the role of InstructionFormats in the
 * opt compiler's IR.
 */
@SuppressWarnings("unused")  // Machine generated code is never 100% clean
public final class MIR_LowTableSwitch extends ArchInstructionFormat {
  /**
   * InstructionFormat identification method for MIR_LowTableSwitch.
   * @param i an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         instruction is MIR_LowTableSwitch or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Instruction i) {
    return conforms(i.operator());
  }
  /**
   * InstructionFormat identification method for MIR_LowTableSwitch.
   * @param o an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         operator is MIR_LowTableSwitch or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Operator o) {
    return o.format == MIR_LowTableSwitch_format;
  }

  /**
   * Get the operand called Index from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Index
   */
  public static RegisterOperand getIndex(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LowTableSwitch");
    return (RegisterOperand) i.getOperand(0);
  }
  /**
   * Get the operand called Index from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Index
   */
  public static RegisterOperand getClearIndex(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LowTableSwitch");
    return (RegisterOperand) i.getClearOperand(0);
  }
  /**
   * Set the operand called Index in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Index the operand to store
   */
  public static void setIndex(Instruction i, RegisterOperand Index) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LowTableSwitch");
    i.putOperand(0, Index);
  }
  /**
   * Return the index of the operand called Index
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Index
   *         in the argument instruction
   */
  public static int indexOfIndex(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LowTableSwitch");
    return 0;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Index?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Index or <code>false</code>
   *         if it does not.
   */
  public static boolean hasIndex(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LowTableSwitch");
    return i.getOperand(0) != null;
  }

  /**
   * Get the k'th operand called Target from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @param k the index of the operand
   * @return the k'th operand called Target
   */
  public static BranchOperand getTarget(Instruction i, int k) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LowTableSwitch");
    return (BranchOperand) i.getOperand(1+k*2+0);
  }
  /**
   * Get the k'th operand called Target from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @param k the index of the operand
   * @return the k'th operand called Target
   */
  public static BranchOperand getClearTarget(Instruction i, int k) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LowTableSwitch");
    return (BranchOperand) i.getClearOperand(1+k*2+0);
  }
  /**
   * Set the k'th operand called Target in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param k the index of the operand
   * @param o the operand to store
   */
  public static void setTarget(Instruction i, int k, BranchOperand o) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LowTableSwitch");
    i.putOperand(1+k*2+0, o);
  }
  /**
   * Return the index of the k'th operand called Target
   * in the argument instruction.
   * @param i the instruction to access.
   * @param k the index of the operand.
   * @return the index of the k'th operand called Target
   *         in the argument instruction
   */
  public static int indexOfTarget(Instruction i, int k) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LowTableSwitch");
    return 1+k*2+0;
  }
  /**
   * Does the argument instruction have a non-null
   * k'th operand named Target?
   * @param i the instruction to access.
   * @param k the index of the operand.
   * @return <code>true</code> if the instruction has an non-null
   *         k'th operand named Target or <code>false</code>
   *         if it does not.
   */
  public static boolean hasTarget(Instruction i, int k) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LowTableSwitch");
    return i.getOperand(1+k*2+0) != null;
  }

  /**
   * Return the index of the first operand called Target
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the first operand called Target
   *         in the argument instruction
   */
  public static int indexOfTargets(Instruction i)
  {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LowTableSwitch");
    return 1;
  }
  /**
   * Does the argument instruction have any operands
   * named Target?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has operands
   *         named Target or <code>false</code> if it does not.
   */
  public static boolean hasTargets(Instruction i)
  {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LowTableSwitch");
    return i.getNumberOfOperands()-1 > 0 && i.getOperand(1) != null;
  }

  /**
   * How many variable-length operands called Targets
   * does the argument instruction have?
   * @param i the instruction to access
   * @return the number of operands called Targets the instruction has
   */
  public static int getNumberOfTargets(Instruction i)
  {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LowTableSwitch");
    return (i.getNumberOfOperands()-1)/2;
  }

  /**
   * Change the number of Targets that may be stored in
   * the argument instruction to numVarOps.
   * @param i the instruction to access
   * @param numVarOps the new number of variable operands called Targets
   *        that may be stored in the instruction
   */
  public static void resizeNumberOfTargets(Instruction i, int numVarOps)
  {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LowTableSwitch");
  if (1+numVarOps*2>MIN_OPERAND_ARRAY_LENGTH)
    i.resizeNumberOfOperands(1+numVarOps*2);
  else
    for (int j = 1+numVarOps*2; j < MIN_OPERAND_ARRAY_LENGTH; j++)
      i.putOperand(j, null);
  }
  /**
   * Get the k'th operand called BranchProfile from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @param k the index of the operand
   * @return the k'th operand called BranchProfile
   */
  public static BranchProfileOperand getBranchProfile(Instruction i, int k) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LowTableSwitch");
    return (BranchProfileOperand) i.getOperand(1+k*2+1);
  }
  /**
   * Get the k'th operand called BranchProfile from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @param k the index of the operand
   * @return the k'th operand called BranchProfile
   */
  public static BranchProfileOperand getClearBranchProfile(Instruction i, int k) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LowTableSwitch");
    return (BranchProfileOperand) i.getClearOperand(1+k*2+1);
  }
  /**
   * Set the k'th operand called BranchProfile in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param k the index of the operand
   * @param o the operand to store
   */
  public static void setBranchProfile(Instruction i, int k, BranchProfileOperand o) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LowTableSwitch");
    i.putOperand(1+k*2+1, o);
  }
  /**
   * Return the index of the k'th operand called BranchProfile
   * in the argument instruction.
   * @param i the instruction to access.
   * @param k the index of the operand.
   * @return the index of the k'th operand called BranchProfile
   *         in the argument instruction
   */
  public static int indexOfBranchProfile(Instruction i, int k) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LowTableSwitch");
    return 1+k*2+1;
  }
  /**
   * Does the argument instruction have a non-null
   * k'th operand named BranchProfile?
   * @param i the instruction to access.
   * @param k the index of the operand.
   * @return <code>true</code> if the instruction has an non-null
   *         k'th operand named BranchProfile or <code>false</code>
   *         if it does not.
   */
  public static boolean hasBranchProfile(Instruction i, int k) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LowTableSwitch");
    return i.getOperand(1+k*2+1) != null;
  }

  /**
   * Return the index of the first operand called BranchProfile
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the first operand called BranchProfile
   *         in the argument instruction
   */
  public static int indexOfBranchProfiles(Instruction i)
  {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LowTableSwitch");
    return 2;
  }
  /**
   * Does the argument instruction have any operands
   * named BranchProfile?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has operands
   *         named BranchProfile or <code>false</code> if it does not.
   */
  public static boolean hasBranchProfiles(Instruction i)
  {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LowTableSwitch");
    return i.getNumberOfOperands()-2 > 0 && i.getOperand(2) != null;
  }

  /**
   * How many variable-length operands called BranchProfiles
   * does the argument instruction have?
   * @param i the instruction to access
   * @return the number of operands called BranchProfiles the instruction has
   */
  public static int getNumberOfBranchProfiles(Instruction i)
  {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LowTableSwitch");
    return (i.getNumberOfOperands()-1)/2;
  }

  /**
   * Change the number of BranchProfiles that may be stored in
   * the argument instruction to numVarOps.
   * @param i the instruction to access
   * @param numVarOps the new number of variable operands called BranchProfiles
   *        that may be stored in the instruction
   */
  public static void resizeNumberOfBranchProfiles(Instruction i, int numVarOps)
  {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_LowTableSwitch");
  if (1+numVarOps*2>MIN_OPERAND_ARRAY_LENGTH)
    i.resizeNumberOfOperands(1+numVarOps*2);
  else
    for (int j = 1+numVarOps*2; j < MIN_OPERAND_ARRAY_LENGTH; j++)
      i.putOperand(j, null);
  }

  /**
   * Create an instruction of the MIR_LowTableSwitch instruction format.
   * @param o the instruction's operator
   * @param Index the instruction's Index operand
   * @param numVarOps the number of variable length operands that
   *                 will be stored in the insruction.
   * @return the newly created MIR_LowTableSwitch instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Index
                   , int numVarOps
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_LowTableSwitch");
    Instruction i = Instruction.create(o, Math.max(1+numVarOps*2, MIN_OPERAND_ARRAY_LENGTH));
    i.putOperand(0, Index);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_LowTableSwitch instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Index the instruction's Index operand
   * @param numVarOps the number of variable length operands that
   *                  will be stored in the insruction.
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Index
                   , int numVarOps
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_LowTableSwitch");
    if (1+numVarOps*2>MIN_OPERAND_ARRAY_LENGTH)
      i.resizeNumberOfOperands(1+numVarOps*2);

    i.changeOperatorTo(o);
    i.putOperand(0, Index);
    return i;
  }
}

##NEW_FILE_STARTS_HERE MIR_RotateAndMask.java##

/*
 * THIS FILE IS MACHINE_GENERATED. DO NOT EDIT.
 * See InstructionFormats.template, InstructionFormatList.dat,
 * OperatorList.dat, etc.
 */

package org.jikesrvm.compilers.opt.ir.ppc;

import org.jikesrvm.Configuration;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCConditionOperand;
import org.jikesrvm.compilers.opt.ir.operand.ppc.PowerPCTrapOperand;
import org.jikesrvm.compilers.opt.ir.operand.*;
import org.jikesrvm.compilers.opt.ir.Instruction;
import org.jikesrvm.compilers.opt.ir.Operator;

/**
 * The MIR_RotateAndMask InstructionFormat class.
 *
 * The header comment for {@link Instruction} contains
 * an explanation of the role of InstructionFormats in the
 * opt compiler's IR.
 */
@SuppressWarnings("unused")  // Machine generated code is never 100% clean
public final class MIR_RotateAndMask extends ArchInstructionFormat {
  /**
   * InstructionFormat identification method for MIR_RotateAndMask.
   * @param i an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         instruction is MIR_RotateAndMask or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Instruction i) {
    return conforms(i.operator());
  }
  /**
   * InstructionFormat identification method for MIR_RotateAndMask.
   * @param o an instruction
   * @return <code>true</code> if the InstructionFormat of the argument
   *         operator is MIR_RotateAndMask or <code>false</code>
   *         if it is not.
   */
  public static boolean conforms(Operator o) {
    return o.format == MIR_RotateAndMask_format;
  }

  /**
   * Get the operand called Result from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Result
   */
  public static RegisterOperand getResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_RotateAndMask");
    return (RegisterOperand) i.getOperand(0);
  }
  /**
   * Get the operand called Result from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Result
   */
  public static RegisterOperand getClearResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_RotateAndMask");
    return (RegisterOperand) i.getClearOperand(0);
  }
  /**
   * Set the operand called Result in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Result the operand to store
   */
  public static void setResult(Instruction i, RegisterOperand Result) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_RotateAndMask");
    i.putOperand(0, Result);
  }
  /**
   * Return the index of the operand called Result
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Result
   *         in the argument instruction
   */
  public static int indexOfResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_RotateAndMask");
    return 0;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Result?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Result or <code>false</code>
   *         if it does not.
   */
  public static boolean hasResult(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_RotateAndMask");
    return i.getOperand(0) != null;
  }

  /**
   * Get the operand called Source from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Source
   */
  public static RegisterOperand getSource(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_RotateAndMask");
    return (RegisterOperand) i.getOperand(1);
  }
  /**
   * Get the operand called Source from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Source
   */
  public static RegisterOperand getClearSource(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_RotateAndMask");
    return (RegisterOperand) i.getClearOperand(1);
  }
  /**
   * Set the operand called Source in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Source the operand to store
   */
  public static void setSource(Instruction i, RegisterOperand Source) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_RotateAndMask");
    i.putOperand(1, Source);
  }
  /**
   * Return the index of the operand called Source
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Source
   *         in the argument instruction
   */
  public static int indexOfSource(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_RotateAndMask");
    return 1;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Source?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Source or <code>false</code>
   *         if it does not.
   */
  public static boolean hasSource(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_RotateAndMask");
    return i.getOperand(1) != null;
  }

  /**
   * Get the operand called Value from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value
   */
  public static RegisterOperand getValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_RotateAndMask");
    return (RegisterOperand) i.getOperand(2);
  }
  /**
   * Get the operand called Value from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Value
   */
  public static RegisterOperand getClearValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_RotateAndMask");
    return (RegisterOperand) i.getClearOperand(2);
  }
  /**
   * Set the operand called Value in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Value the operand to store
   */
  public static void setValue(Instruction i, RegisterOperand Value) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_RotateAndMask");
    i.putOperand(2, Value);
  }
  /**
   * Return the index of the operand called Value
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Value
   *         in the argument instruction
   */
  public static int indexOfValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_RotateAndMask");
    return 2;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Value?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Value or <code>false</code>
   *         if it does not.
   */
  public static boolean hasValue(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_RotateAndMask");
    return i.getOperand(2) != null;
  }

  /**
   * Get the operand called Shift from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Shift
   */
  public static Operand getShift(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_RotateAndMask");
    return (Operand) i.getOperand(3);
  }
  /**
   * Get the operand called Shift from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called Shift
   */
  public static Operand getClearShift(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_RotateAndMask");
    return (Operand) i.getClearOperand(3);
  }
  /**
   * Set the operand called Shift in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param Shift the operand to store
   */
  public static void setShift(Instruction i, Operand Shift) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_RotateAndMask");
    i.putOperand(3, Shift);
  }
  /**
   * Return the index of the operand called Shift
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called Shift
   *         in the argument instruction
   */
  public static int indexOfShift(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_RotateAndMask");
    return 3;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named Shift?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named Shift or <code>false</code>
   *         if it does not.
   */
  public static boolean hasShift(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_RotateAndMask");
    return i.getOperand(3) != null;
  }

  /**
   * Get the operand called MaskBegin from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called MaskBegin
   */
  public static IntConstantOperand getMaskBegin(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_RotateAndMask");
    return (IntConstantOperand) i.getOperand(4);
  }
  /**
   * Get the operand called MaskBegin from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called MaskBegin
   */
  public static IntConstantOperand getClearMaskBegin(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_RotateAndMask");
    return (IntConstantOperand) i.getClearOperand(4);
  }
  /**
   * Set the operand called MaskBegin in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param MaskBegin the operand to store
   */
  public static void setMaskBegin(Instruction i, IntConstantOperand MaskBegin) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_RotateAndMask");
    i.putOperand(4, MaskBegin);
  }
  /**
   * Return the index of the operand called MaskBegin
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called MaskBegin
   *         in the argument instruction
   */
  public static int indexOfMaskBegin(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_RotateAndMask");
    return 4;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named MaskBegin?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named MaskBegin or <code>false</code>
   *         if it does not.
   */
  public static boolean hasMaskBegin(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_RotateAndMask");
    return i.getOperand(4) != null;
  }

  /**
   * Get the operand called MaskEnd from the
   * argument instruction. Note that the returned operand
   * will still point to its containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called MaskEnd
   */
  public static IntConstantOperand getMaskEnd(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_RotateAndMask");
    return (IntConstantOperand) i.getOperand(5);
  }
  /**
   * Get the operand called MaskEnd from the argument
   * instruction clearing its instruction pointer. The returned
   * operand will not point to any containing instruction.
   * @param i the instruction to fetch the operand from
   * @return the operand called MaskEnd
   */
  public static IntConstantOperand getClearMaskEnd(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_RotateAndMask");
    return (IntConstantOperand) i.getClearOperand(5);
  }
  /**
   * Set the operand called MaskEnd in the argument
   * instruction to the argument operand. The operand will
   * now point to the argument instruction as its containing
   * instruction.
   * @param i the instruction in which to store the operand
   * @param MaskEnd the operand to store
   */
  public static void setMaskEnd(Instruction i, IntConstantOperand MaskEnd) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_RotateAndMask");
    i.putOperand(5, MaskEnd);
  }
  /**
   * Return the index of the operand called MaskEnd
   * in the argument instruction.
   * @param i the instruction to access.
   * @return the index of the operand called MaskEnd
   *         in the argument instruction
   */
  public static int indexOfMaskEnd(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_RotateAndMask");
    return 5;
  }
  /**
   * Does the argument instruction have a non-null
   * operand named MaskEnd?
   * @param i the instruction to access.
   * @return <code>true</code> if the instruction has an non-null
   *         operand named MaskEnd or <code>false</code>
   *         if it does not.
   */
  public static boolean hasMaskEnd(Instruction i) {
    if (Configuration.ExtremeAssertions && !conforms(i)) fail(i, "MIR_RotateAndMask");
    return i.getOperand(5) != null;
  }


  /**
   * Create an instruction of the MIR_RotateAndMask instruction format.
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Source the instruction's Source operand
   * @param Value the instruction's Value operand
   * @param Shift the instruction's Shift operand
   * @param MaskBegin the instruction's MaskBegin operand
   * @param MaskEnd the instruction's MaskEnd operand
   * @return the newly created MIR_RotateAndMask instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Result
                   , RegisterOperand Source
                   , RegisterOperand Value
                   , Operand Shift
                   , IntConstantOperand MaskBegin
                   , IntConstantOperand MaskEnd
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_RotateAndMask");
    Instruction i = Instruction.create(o, 6);
    i.putOperand(0, Result);
    i.putOperand(1, Source);
    i.putOperand(2, Value);
    i.putOperand(3, Shift);
    i.putOperand(4, MaskBegin);
    i.putOperand(5, MaskEnd);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_RotateAndMask instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Source the instruction's Source operand
   * @param Value the instruction's Value operand
   * @param Shift the instruction's Shift operand
   * @param MaskBegin the instruction's MaskBegin operand
   * @param MaskEnd the instruction's MaskEnd operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Result
                   , RegisterOperand Source
                   , RegisterOperand Value
                   , Operand Shift
                   , IntConstantOperand MaskBegin
                   , IntConstantOperand MaskEnd
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_RotateAndMask");
    i.resizeNumberOfOperands(6);

    i.changeOperatorTo(o);
    i.putOperand(0, Result);
    i.putOperand(1, Source);
    i.putOperand(2, Value);
    i.putOperand(3, Shift);
    i.putOperand(4, MaskBegin);
    i.putOperand(5, MaskEnd);
    return i;
  }
  /**
   * Create an instruction of the MIR_RotateAndMask instruction format.
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Value the instruction's Value operand
   * @param Shift the instruction's Shift operand
   * @param MaskBegin the instruction's MaskBegin operand
   * @param MaskEnd the instruction's MaskEnd operand
   * @return the newly created MIR_RotateAndMask instruction
   */
  public static Instruction create(Operator o
                   , RegisterOperand Result
                   , RegisterOperand Value
                   , Operand Shift
                   , IntConstantOperand MaskBegin
                   , IntConstantOperand MaskEnd
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_RotateAndMask");
    Instruction i = Instruction.create(o, 6);
    i.putOperand(0, Result);
    i.putOperand(2, Value);
    i.putOperand(3, Shift);
    i.putOperand(4, MaskBegin);
    i.putOperand(5, MaskEnd);
    return i;
  }

  /**
   * Mutate the argument instruction into an instruction of the
   * MIR_RotateAndMask instruction format having the specified
   * operator and operands.
   * @param i the instruction to mutate
   * @param o the instruction's operator
   * @param Result the instruction's Result operand
   * @param Value the instruction's Value operand
   * @param Shift the instruction's Shift operand
   * @param MaskBegin the instruction's MaskBegin operand
   * @param MaskEnd the instruction's MaskEnd operand
   * @return the mutated instruction
   */
  public static Instruction mutate(Instruction i, Operator o
                   , RegisterOperand Result
                   , RegisterOperand Value
                   , Operand Shift
                   , IntConstantOperand MaskBegin
                   , IntConstantOperand MaskEnd
                )
  {
    if (Configuration.ExtremeAssertions && !conforms(o)) fail(o, "MIR_RotateAndMask");
    i.resizeNumberOfOperands(6);

    i.changeOperatorTo(o);
    i.putOperand(0, Result);
    i.putOperand(1, null);
    i.putOperand(2, Value);
    i.putOperand(3, Shift);
    i.putOperand(4, MaskBegin);
    i.putOperand(5, MaskEnd);
    return i;
  }
}



##NEW_FILE_STARTS_HERE ResultCarrierLookup.java##

/*
 * THIS FILE IS MACHINE_GENERATED. DO NOT EDIT.
 * See InstructionFormats.template, CommonOperands.dat,
 * OperatorList.dat, etc.
 */

package org.jikesrvm.compilers.opt.ir.ppc;

import org.vmmagic.pragma.Pure;

/**
 * Lookup used to see if an operator is a Result (which is RegisterOperand)
 */
public final class ResultCarrierLookup {
  /** Look up table */
  private static final int[] table = {
           -1    // Unassigned
           , 0    // Move
           , -1    // Return
           , -1    // Prologue
           , -1    // InstrumentedCounter
           , -1    // Empty
           , 0    // Nullary
           , 0    // New
           , 0    // NewArray
           , 0    // Multianewarray
           , -1    // Athrow
           , -1    // MonitorOp
           , -1    // CacheOp
           , -1    // NullCheck
           , -1    // ZeroCheck
           , -1    // BoundsCheck
           , -1    // StoreCheck
           , 0    // TypeCheck
           , 0    // InstanceOf
           , -1    // Trap
           , -1    // TrapIf
           , -1    // IfCmp
           , -1    // IfCmp2
           , -1    // InlineGuard
           , 0    // BooleanCmp
           , 0    // CondMove
           , -1    // Goto
           , -1    // Label
           , -1    // BBend
           , 0    // Unary
           , 0    // GuardedUnary
           , 0    // Binary
           , 0    // GuardedBinary
           , -1    // GuardedSet
           , 0    // ALoad
           , 0    // GetField
           , 0    // GetStatic
           , 0    // Load
           , -1    // AStore
           , -1    // PutField
           , -1    // PutStatic
           , -1    // Store
           , 0    // Prepare
           , 0    // Attempt
           , 0    // Call
           , -1    // TableSwitch
           , -1    // LookupSwitch
           , -1    // LowTableSwitch
           , -1    // Phi
           , -1    // OsrBarrier
           , -1    // OsrPoint
           , 0    // MIR_Load
           , 0    // MIR_LoadUpdate
           , -1    // MIR_Store
           , -1    // MIR_StoreUpdate
           , -1    // MIR_CacheOp
           , 0    // MIR_Move
           , -1    // MIR_Trap
           , -1    // MIR_DataInt
           , -1    // MIR_DataLabel
           , -1    // MIR_Branch
           , -1    // MIR_CondBranch
           , -1    // MIR_CondBranch2
           , 0    // MIR_Call
           , 0    // MIR_CondCall
           , -1    // MIR_Return
           , -1    // MIR_Empty
           , 0    // MIR_Nullary
           , 0    // MIR_Unary
           , 0    // MIR_Binary
           , -1    // MIR_Condition
           , 0    // MIR_Ternary
           , -1    // MIR_LowTableSwitch
           , 0    // MIR_RotateAndMask
        };

  /**
   * Perform table lookup
   * @param index the index to lookup
   * @return the index into the instruction operands that carries the Result
   *   or -1 if not carried
   */
  @Pure
  public static int lookup(int index) {
    return table[index];
  }
}

##NEW_FILE_STARTS_HERE GuardResultCarrierLookup.java##

/*
 * THIS FILE IS MACHINE_GENERATED. DO NOT EDIT.
 * See InstructionFormats.template, CommonOperands.dat,
 * OperatorList.dat, etc.
 */

package org.jikesrvm.compilers.opt.ir.ppc;

import org.vmmagic.pragma.Pure;

/**
 * Lookup used to see if an operator is a GuardResult (which is RegisterOperand)
 */
public final class GuardResultCarrierLookup {
  /** Look up table */
  private static final int[] table = {
           -1    // Unassigned
           , -1    // Move
           , -1    // Return
           , -1    // Prologue
           , -1    // InstrumentedCounter
           , -1    // Empty
           , -1    // Nullary
           , -1    // New
           , -1    // NewArray
           , -1    // Multianewarray
           , -1    // Athrow
           , -1    // MonitorOp
           , -1    // CacheOp
           , 0    // NullCheck
           , 0    // ZeroCheck
           , 0    // BoundsCheck
           , 0    // StoreCheck
           , -1    // TypeCheck
           , -1    // InstanceOf
           , 0    // Trap
           , 0    // TrapIf
           , 0    // IfCmp
           , 0    // IfCmp2
           , -1    // InlineGuard
           , -1    // BooleanCmp
           , -1    // CondMove
           , -1    // Goto
           , -1    // Label
           , -1    // BBend
           , -1    // Unary
           , -1    // GuardedUnary
           , -1    // Binary
           , -1    // GuardedBinary
           , -1    // GuardedSet
           , -1    // ALoad
           , -1    // GetField
           , -1    // GetStatic
           , -1    // Load
           , -1    // AStore
           , -1    // PutField
           , -1    // PutStatic
           , -1    // Store
           , -1    // Prepare
           , -1    // Attempt
           , -1    // Call
           , -1    // TableSwitch
           , -1    // LookupSwitch
           , -1    // LowTableSwitch
           , -1    // Phi
           , -1    // OsrBarrier
           , -1    // OsrPoint
           , -1    // MIR_Load
           , -1    // MIR_LoadUpdate
           , -1    // MIR_Store
           , -1    // MIR_StoreUpdate
           , -1    // MIR_CacheOp
           , -1    // MIR_Move
           , 0    // MIR_Trap
           , -1    // MIR_DataInt
           , -1    // MIR_DataLabel
           , -1    // MIR_Branch
           , -1    // MIR_CondBranch
           , -1    // MIR_CondBranch2
           , -1    // MIR_Call
           , -1    // MIR_CondCall
           , -1    // MIR_Return
           , -1    // MIR_Empty
           , -1    // MIR_Nullary
           , -1    // MIR_Unary
           , -1    // MIR_Binary
           , -1    // MIR_Condition
           , -1    // MIR_Ternary
           , -1    // MIR_LowTableSwitch
           , -1    // MIR_RotateAndMask
        };

  /**
   * Perform table lookup
   * @param index the index to lookup
   * @return the index into the instruction operands that carries the GuardResult
   *   or -1 if not carried
   */
  @Pure
  public static int lookup(int index) {
    return table[index];
  }
}

##NEW_FILE_STARTS_HERE LocationCarrierLookup.java##

/*
 * THIS FILE IS MACHINE_GENERATED. DO NOT EDIT.
 * See InstructionFormats.template, CommonOperands.dat,
 * OperatorList.dat, etc.
 */

package org.jikesrvm.compilers.opt.ir.ppc;

import org.vmmagic.pragma.Pure;

/**
 * Lookup used to see if an operator is a Location (which is LocationOperand)
 */
public final class LocationCarrierLookup {
  /** Look up table */
  private static final int[] table = {
           -1    // Unassigned
           , -1    // Move
           , -1    // Return
           , -1    // Prologue
           , -1    // InstrumentedCounter
           , -1    // Empty
           , -1    // Nullary
           , -1    // New
           , -1    // NewArray
           , -1    // Multianewarray
           , -1    // Athrow
           , -1    // MonitorOp
           , -1    // CacheOp
           , -1    // NullCheck
           , -1    // ZeroCheck
           , -1    // BoundsCheck
           , -1    // StoreCheck
           , -1    // TypeCheck
           , -1    // InstanceOf
           , -1    // Trap
           , -1    // TrapIf
           , -1    // IfCmp
           , -1    // IfCmp2
           , -1    // InlineGuard
           , -1    // BooleanCmp
           , -1    // CondMove
           , -1    // Goto
           , -1    // Label
           , -1    // BBend
           , -1    // Unary
           , -1    // GuardedUnary
           , -1    // Binary
           , -1    // GuardedBinary
           , -1    // GuardedSet
           , 3    // ALoad
           , 3    // GetField
           , 2    // GetStatic
           , 3    // Load
           , 3    // AStore
           , 3    // PutField
           , 2    // PutStatic
           , 3    // Store
           , 3    // Prepare
           , 5    // Attempt
           , -1    // Call
           , -1    // TableSwitch
           , -1    // LookupSwitch
           , -1    // LowTableSwitch
           , -1    // Phi
           , -1    // OsrBarrier
           , -1    // OsrPoint
           , 3    // MIR_Load
           , 3    // MIR_LoadUpdate
           , 3    // MIR_Store
           , 3    // MIR_StoreUpdate
           , -1    // MIR_CacheOp
           , -1    // MIR_Move
           , -1    // MIR_Trap
           , -1    // MIR_DataInt
           , -1    // MIR_DataLabel
           , -1    // MIR_Branch
           , -1    // MIR_CondBranch
           , -1    // MIR_CondBranch2
           , -1    // MIR_Call
           , -1    // MIR_CondCall
           , -1    // MIR_Return
           , -1    // MIR_Empty
           , -1    // MIR_Nullary
           , -1    // MIR_Unary
           , -1    // MIR_Binary
           , -1    // MIR_Condition
           , -1    // MIR_Ternary
           , -1    // MIR_LowTableSwitch
           , -1    // MIR_RotateAndMask
        };

  /**
   * Perform table lookup
   * @param index the index to lookup
   * @return the index into the instruction operands that carries the Location
   *   or -1 if not carried
   */
  @Pure
  public static int lookup(int index) {
    return table[index];
  }
}

##NEW_FILE_STARTS_HERE GuardCarrierLookup.java##

/*
 * THIS FILE IS MACHINE_GENERATED. DO NOT EDIT.
 * See InstructionFormats.template, CommonOperands.dat,
 * OperatorList.dat, etc.
 */

package org.jikesrvm.compilers.opt.ir.ppc;

import org.vmmagic.pragma.Pure;

/**
 * Lookup used to see if an operator is a Guard (which is Operand)
 */
public final class GuardCarrierLookup {
  /** Look up table */
  private static final int[] table = {
           -1    // Unassigned
           , -1    // Move
           , -1    // Return
           , -1    // Prologue
           , -1    // InstrumentedCounter
           , -1    // Empty
           , -1    // Nullary
           , -1    // New
           , -1    // NewArray
           , -1    // Multianewarray
           , -1    // Athrow
           , 1    // MonitorOp
           , -1    // CacheOp
           , -1    // NullCheck
           , -1    // ZeroCheck
           , 3    // BoundsCheck
           , 3    // StoreCheck
           , 3    // TypeCheck
           , 3    // InstanceOf
           , -1    // Trap
           , -1    // TrapIf
           , -1    // IfCmp
           , -1    // IfCmp2
           , 1    // InlineGuard
           , -1    // BooleanCmp
           , -1    // CondMove
           , -1    // Goto
           , -1    // Label
           , -1    // BBend
           , -1    // Unary
           , 2    // GuardedUnary
           , -1    // Binary
           , 3    // GuardedBinary
           , 2    // GuardedSet
           , 4    // ALoad
           , 4    // GetField
           , -1    // GetStatic
           , 4    // Load
           , 4    // AStore
           , 4    // PutField
           , -1    // PutStatic
           , 4    // Store
           , 4    // Prepare
           , 6    // Attempt
           , 3    // Call
           , -1    // TableSwitch
           , -1    // LookupSwitch
           , -1    // LowTableSwitch
           , -1    // Phi
           , -1    // OsrBarrier
           , -1    // OsrPoint
           , 4    // MIR_Load
           , 4    // MIR_LoadUpdate
           , 4    // MIR_Store
           , 4    // MIR_StoreUpdate
           , -1    // MIR_CacheOp
           , -1    // MIR_Move
           , -1    // MIR_Trap
           , -1    // MIR_DataInt
           , -1    // MIR_DataLabel
           , -1    // MIR_Branch
           , -1    // MIR_CondBranch
           , -1    // MIR_CondBranch2
           , -1    // MIR_Call
           , -1    // MIR_CondCall
           , -1    // MIR_Return
           , -1    // MIR_Empty
           , -1    // MIR_Nullary
           , -1    // MIR_Unary
           , -1    // MIR_Binary
           , -1    // MIR_Condition
           , -1    // MIR_Ternary
           , -1    // MIR_LowTableSwitch
           , -1    // MIR_RotateAndMask
        };

  /**
   * Perform table lookup
   * @param index the index to lookup
   * @return the index into the instruction operands that carries the Guard
   *   or -1 if not carried
   */
  @Pure
  public static int lookup(int index) {
    return table[index];
  }
}

##NEW_FILE_STARTS_HERE BranchProfileCarrierLookup.java##

/*
 * THIS FILE IS MACHINE_GENERATED. DO NOT EDIT.
 * See InstructionFormats.template, CommonOperands.dat,
 * OperatorList.dat, etc.
 */

package org.jikesrvm.compilers.opt.ir.ppc;

import org.vmmagic.pragma.Pure;

/**
 * Lookup used to see if an operator is a BranchProfile (which is BranchProfileOperand)
 */
public final class BranchProfileCarrierLookup {
  /** Look up table */
  private static final int[] table = {
           -1    // Unassigned
           , -1    // Move
           , -1    // Return
           , -1    // Prologue
           , -1    // InstrumentedCounter
           , -1    // Empty
           , -1    // Nullary
           , -1    // New
           , -1    // NewArray
           , -1    // Multianewarray
           , -1    // Athrow
           , -1    // MonitorOp
           , -1    // CacheOp
           , -1    // NullCheck
           , -1    // ZeroCheck
           , -1    // BoundsCheck
           , -1    // StoreCheck
           , -1    // TypeCheck
           , -1    // InstanceOf
           , -1    // Trap
           , -1    // TrapIf
           , 5    // IfCmp
           , -1    // IfCmp2
           , 4    // InlineGuard
           , 4    // BooleanCmp
           , -1    // CondMove
           , -1    // Goto
           , -1    // Label
           , -1    // BBend
           , -1    // Unary
           , -1    // GuardedUnary
           , -1    // Binary
           , -1    // GuardedBinary
           , -1    // GuardedSet
           , -1    // ALoad
           , -1    // GetField
           , -1    // GetStatic
           , -1    // Load
           , -1    // AStore
           , -1    // PutField
           , -1    // PutStatic
           , -1    // Store
           , -1    // Prepare
           , -1    // Attempt
           , -1    // Call
           , -1    // TableSwitch
           , -1    // LookupSwitch
           , -1    // LowTableSwitch
           , -1    // Phi
           , -1    // OsrBarrier
           , -1    // OsrPoint
           , -1    // MIR_Load
           , -1    // MIR_LoadUpdate
           , -1    // MIR_Store
           , -1    // MIR_StoreUpdate
           , -1    // MIR_CacheOp
           , -1    // MIR_Move
           , -1    // MIR_Trap
           , -1    // MIR_DataInt
           , -1    // MIR_DataLabel
           , -1    // MIR_Branch
           , 3    // MIR_CondBranch
           , -1    // MIR_CondBranch2
           , -1    // MIR_Call
           , -1    // MIR_CondCall
           , -1    // MIR_Return
           , -1    // MIR_Empty
           , -1    // MIR_Nullary
           , -1    // MIR_Unary
           , -1    // MIR_Binary
           , -1    // MIR_Condition
           , -1    // MIR_Ternary
           , -1    // MIR_LowTableSwitch
           , -1    // MIR_RotateAndMask
        };

  /**
   * Perform table lookup
   * @param index the index to lookup
   * @return the index into the instruction operands that carries the BranchProfile
   *   or -1 if not carried
   */
  @Pure
  public static int lookup(int index) {
    return table[index];
  }
}
