%{
/*
 *  This file is part of the Jikes RVM project (http://jikesrvm.org).
 *
 *  This file is licensed to You under the Eclipse Public License (EPL);
 *  You may not use this file except in compliance with the License. You
 *  may obtain a copy of the License at
 *
 *      http://www.opensource.org/licenses/eclipse-1.0.php
 *
 *  See the COPYRIGHT.txt file distributed with this work for information
 *  regarding copyright ownership.
 */
//ir.brg

  /**
   * Generate from ir.template and assembled rules files.
   */
%}
%term GET_CAUGHT_EXCEPTION = 0
%term SET_CAUGHT_EXCEPTION = 1
%term NEW = 2
%term NEW_UNRESOLVED = 3
%term NEWARRAY = 4
%term NEWARRAY_UNRESOLVED = 5
%term ATHROW = 6
%term CHECKCAST = 7
%term CHECKCAST_NOTNULL = 8
%term CHECKCAST_UNRESOLVED = 9
%term MUST_IMPLEMENT_INTERFACE = 10
%term INSTANCEOF = 11
%term INSTANCEOF_NOTNULL = 12
%term INSTANCEOF_UNRESOLVED = 13
%term MONITORENTER = 14
%term MONITOREXIT = 15
%term NEWOBJMULTIARRAY = 16
%term GETSTATIC = 17
%term PUTSTATIC = 18
%term GETFIELD = 19
%term PUTFIELD = 20
%term INT_ZERO_CHECK = 21
%term LONG_ZERO_CHECK = 22
%term BOUNDS_CHECK = 23
%term OBJARRAY_STORE_CHECK = 24
%term OBJARRAY_STORE_CHECK_NOTNULL = 25
%term IG_PATCH_POINT = 26
%term IG_CLASS_TEST = 27
%term IG_METHOD_TEST = 28
%term TABLESWITCH = 29
%term LOOKUPSWITCH = 30
%term INT_ALOAD = 31
%term LONG_ALOAD = 32
%term FLOAT_ALOAD = 33
%term DOUBLE_ALOAD = 34
%term REF_ALOAD = 35
%term UBYTE_ALOAD = 36
%term BYTE_ALOAD = 37
%term USHORT_ALOAD = 38
%term SHORT_ALOAD = 39
%term INT_ASTORE = 40
%term LONG_ASTORE = 41
%term FLOAT_ASTORE = 42
%term DOUBLE_ASTORE = 43
%term REF_ASTORE = 44
%term BYTE_ASTORE = 45
%term SHORT_ASTORE = 46
%term INT_IFCMP = 47
%term INT_IFCMP2 = 48
%term LONG_IFCMP = 49
%term FLOAT_IFCMP = 50
%term DOUBLE_IFCMP = 51
%term REF_IFCMP = 52
%term LABEL = 53
%term BBEND = 54
%term UNINT_BEGIN = 55
%term UNINT_END = 56
%term FENCE = 57
%term READ_CEILING = 58
%term WRITE_FLOOR = 59
%term PHI = 60
%term SPLIT = 61
%term PI = 62
%term NOP = 63
%term INT_MOVE = 64
%term LONG_MOVE = 65
%term FLOAT_MOVE = 66
%term DOUBLE_MOVE = 67
%term REF_MOVE = 68
%term GUARD_MOVE = 69
%term INT_COND_MOVE = 70
%term LONG_COND_MOVE = 71
%term FLOAT_COND_MOVE = 72
%term DOUBLE_COND_MOVE = 73
%term REF_COND_MOVE = 74
%term GUARD_COND_MOVE = 75
%term GUARD_COMBINE = 76
%term REF_ADD = 77
%term INT_ADD = 78
%term LONG_ADD = 79
%term FLOAT_ADD = 80
%term DOUBLE_ADD = 81
%term REF_SUB = 82
%term INT_SUB = 83
%term LONG_SUB = 84
%term FLOAT_SUB = 85
%term DOUBLE_SUB = 86
%term INT_MUL = 87
%term LONG_MUL = 88
%term FLOAT_MUL = 89
%term DOUBLE_MUL = 90
%term INT_DIV = 91
%term LONG_DIV = 92
%term UNSIGNED_DIV_64_32 = 93
%term UNSIGNED_REM_64_32 = 94
%term FLOAT_DIV = 95
%term DOUBLE_DIV = 96
%term INT_REM = 97
%term LONG_REM = 98
%term FLOAT_REM = 99
%term DOUBLE_REM = 100
%term REF_NEG = 101
%term INT_NEG = 102
%term LONG_NEG = 103
%term FLOAT_NEG = 104
%term DOUBLE_NEG = 105
%term FLOAT_SQRT = 106
%term DOUBLE_SQRT = 107
%term REF_SHL = 108
%term INT_SHL = 109
%term LONG_SHL = 110
%term REF_SHR = 111
%term INT_SHR = 112
%term LONG_SHR = 113
%term REF_USHR = 114
%term INT_USHR = 115
%term LONG_USHR = 116
%term REF_AND = 117
%term INT_AND = 118
%term LONG_AND = 119
%term REF_OR = 120
%term INT_OR = 121
%term LONG_OR = 122
%term REF_XOR = 123
%term INT_XOR = 124
%term REF_NOT = 125
%term INT_NOT = 126
%term LONG_NOT = 127
%term LONG_XOR = 128
%term INT_2ADDRSigExt = 129
%term INT_2ADDRZerExt = 130
%term LONG_2ADDR = 131
%term ADDR_2INT = 132
%term ADDR_2LONG = 133
%term INT_2LONG = 134
%term INT_2FLOAT = 135
%term INT_2DOUBLE = 136
%term LONG_2INT = 137
%term LONG_2FLOAT = 138
%term LONG_2DOUBLE = 139
%term FLOAT_2INT = 140
%term FLOAT_2LONG = 141
%term FLOAT_2DOUBLE = 142
%term DOUBLE_2INT = 143
%term DOUBLE_2LONG = 144
%term DOUBLE_2FLOAT = 145
%term INT_2BYTE = 146
%term INT_2USHORT = 147
%term INT_2SHORT = 148
%term LONG_CMP = 149
%term FLOAT_CMPL = 150
%term FLOAT_CMPG = 151
%term DOUBLE_CMPL = 152
%term DOUBLE_CMPG = 153
%term RETURN = 154
%term NULL_CHECK = 155
%term GOTO = 156
%term BOOLEAN_NOT = 157
%term BOOLEAN_CMP_INT = 158
%term BOOLEAN_CMP_ADDR = 159
%term BOOLEAN_CMP_LONG = 160
%term BOOLEAN_CMP_FLOAT = 161
%term BOOLEAN_CMP_DOUBLE = 162
%term BYTE_LOAD = 163
%term UBYTE_LOAD = 164
%term SHORT_LOAD = 165
%term USHORT_LOAD = 166
%term REF_LOAD = 167
%term REF_STORE = 168
%term INT_LOAD = 169
%term LONG_LOAD = 170
%term FLOAT_LOAD = 171
%term DOUBLE_LOAD = 172
%term BYTE_STORE = 173
%term SHORT_STORE = 174
%term INT_STORE = 175
%term LONG_STORE = 176
%term FLOAT_STORE = 177
%term DOUBLE_STORE = 178
%term PREPARE_INT = 179
%term PREPARE_ADDR = 180
%term PREPARE_LONG = 181
%term ATTEMPT_INT = 182
%term ATTEMPT_ADDR = 183
%term ATTEMPT_LONG = 184
%term CALL = 185
%term SYSCALL = 186
%term UNIMPLEMENTED_BUT_UNREACHABLE = 187
%term YIELDPOINT_PROLOGUE = 188
%term YIELDPOINT_EPILOGUE = 189
%term YIELDPOINT_BACKEDGE = 190
%term YIELDPOINT_OSR = 191
%term OSR_BARRIER = 192
%term IR_PROLOGUE = 193
%term RESOLVE = 194
%term RESOLVE_MEMBER = 195
%term GET_TIME_BASE = 196
%term INSTRUMENTED_EVENT_COUNTER = 197
%term TRAP_IF = 198
%term TRAP = 199
%term ILLEGAL_INSTRUCTION = 200
%term FLOAT_AS_INT_BITS = 201
%term INT_BITS_AS_FLOAT = 202
%term DOUBLE_AS_LONG_BITS = 203
%term LONG_BITS_AS_DOUBLE = 204
%term ARRAYLENGTH = 205
%term FRAMESIZE = 206
%term GET_OBJ_TIB = 207
%term GET_CLASS_TIB = 208
%term GET_TYPE_FROM_TIB = 209
%term GET_SUPERCLASS_IDS_FROM_TIB = 210
%term GET_DOES_IMPLEMENT_FROM_TIB = 211
%term GET_ARRAY_ELEMENT_TIB_FROM_TIB = 212
%term LOWTABLESWITCH = 213
%term ADDRESS_CONSTANT = 214
%term INT_CONSTANT = 215
%term LONG_CONSTANT = 216
%term REGISTER = 217
%term OTHER_OPERAND = 218
%term NULL = 219
%term BRANCH_TARGET = 220
%term MATERIALIZE_FP_CONSTANT = 221
%term ROUND_TO_ZERO = 222
%term CLEAR_FLOATING_POINT_STATE = 223
%term PREFETCH = 224
%term PAUSE = 225
%term FP_ADD = 226
%term FP_SUB = 227
%term FP_MUL = 228
%term FP_DIV = 229
%term FP_NEG = 230
%term FP_REM = 231
%term INT_2FP = 232
%term LONG_2FP = 233
%term CMP_CMOV = 234
%term FCMP_CMOV = 235
%term LCMP_CMOV = 236
%term CMP_FCMOV = 237
%term FCMP_FCMOV = 238
%term CALL_SAVE_VOLATILE = 239
%term MIR_START = 240
%term REQUIRE_ESP = 241
%term ADVISE_ESP = 242
%term MIR_LOWTABLESWITCH = 243
%term IA32_METHODSTART = 244
%term IA32_FCLEAR = 245
%term DUMMY_DEF = 246
%term DUMMY_USE = 247
%term IMMQ_MOV = 248
%term IA32_FMOV_ENDING_LIVE_RANGE = 249
%term IA32_FMOV = 250
%term IA32_TRAPIF = 251
%term IA32_OFFSET = 252
%term IA32_LOCK_CMPXCHG = 253
%term IA32_LOCK_CMPXCHG8B = 254
%term IA32_ADC = 255
%term IA32_ADD = 256
%term IA32_AND = 257
%term IA32_BSWAP = 258
%term IA32_BT = 259
%term IA32_BTC = 260
%term IA32_BTR = 261
%term IA32_BTS = 262
%term IA32_SYSCALL = 263
%term IA32_CALL = 264
%term IA32_CDQ = 265
%term IA32_CDO = 266
%term IA32_CDQE = 267
%term IA32_CMOV = 268
%term IA32_CMP = 269
%term IA32_CMPXCHG = 270
%term IA32_CMPXCHG8B = 271
%term IA32_DEC = 272
%term IA32_DIV = 273
%term IA32_FADD = 274
%term IA32_FADDP = 275
%term IA32_FCHS = 276
%term IA32_FCMOV = 277
%term IA32_FCOMI = 278
%term IA32_FCOMIP = 279
%term IA32_FDIV = 280
%term IA32_FDIVP = 281
%term IA32_FDIVR = 282
%term IA32_FDIVRP = 283
%term IA32_FEXAM = 284
%term IA32_FXCH = 285
%term IA32_FFREE = 286
%term IA32_FFREEP = 287
%term IA32_FIADD = 288
%term IA32_FIDIV = 289
%term IA32_FIDIVR = 290
%term IA32_FILD = 291
%term IA32_FIMUL = 292
%term IA32_FINIT = 293
%term IA32_FIST = 294
%term IA32_FISTP = 295
%term IA32_FISUB = 296
%term IA32_FISUBR = 297
%term IA32_FLD = 298
%term IA32_FLDCW = 299
%term IA32_FLD1 = 300
%term IA32_FLDL2T = 301
%term IA32_FLDL2E = 302
%term IA32_FLDPI = 303
%term IA32_FLDLG2 = 304
%term IA32_FLDLN2 = 305
%term IA32_FLDZ = 306
%term IA32_FMUL = 307
%term IA32_FMULP = 308
%term IA32_FNSTCW = 309
%term IA32_FNSTSW = 310
%term IA32_FNINIT = 311
%term IA32_FNSAVE = 312
%term IA32_FPREM = 313
%term IA32_FRSTOR = 314
%term IA32_FST = 315
%term IA32_FSTCW = 316
%term IA32_FSTSW = 317
%term IA32_FSTP = 318
%term IA32_FSUB = 319
%term IA32_FSUBP = 320
%term IA32_FSUBR = 321
%term IA32_FSUBRP = 322
%term IA32_FUCOMI = 323
%term IA32_FUCOMIP = 324
%term IA32_IDIV = 325
%term IA32_IMUL1 = 326
%term IA32_IMUL2 = 327
%term IA32_INC = 328
%term IA32_INT = 329
%term IA32_JCC = 330
%term IA32_JCC2 = 331
%term IA32_JMP = 332
%term IA32_LEA = 333
%term IA32_LOCK = 334
%term IA32_MOV = 335
%term IA32_MOVZX__B = 336
%term IA32_MOVSX__B = 337
%term IA32_MOVZX__W = 338
%term IA32_MOVSX__W = 339
%term IA32_MOVZXQ__B = 340
%term IA32_MOVSXQ__B = 341
%term IA32_MOVZXQ__W = 342
%term IA32_MOVSXQ__W = 343
%term IA32_MOVSXDQ = 344
%term IA32_MUL = 345
%term IA32_NEG = 346
%term IA32_NOT = 347
%term IA32_OR = 348
%term IA32_MFENCE = 349
%term IA32_PAUSE = 350
%term IA32_UD2 = 351
%term IA32_PREFETCHNTA = 352
%term IA32_POP = 353
%term IA32_PUSH = 354
%term IA32_RCL = 355
%term IA32_RCR = 356
%term IA32_ROL = 357
%term IA32_ROR = 358
%term IA32_RET = 359
%term IA32_SAL = 360
%term IA32_SAR = 361
%term IA32_SHL = 362
%term IA32_SHR = 363
%term IA32_SBB = 364
%term IA32_SET__B = 365
%term IA32_SHLD = 366
%term IA32_SHRD = 367
%term IA32_SUB = 368
%term IA32_TEST = 369
%term IA32_XOR = 370
%term IA32_RDTSC = 371
%term IA32_ADDSS = 372
%term IA32_SUBSS = 373
%term IA32_MULSS = 374
%term IA32_DIVSS = 375
%term IA32_ADDSD = 376
%term IA32_SUBSD = 377
%term IA32_MULSD = 378
%term IA32_DIVSD = 379
%term IA32_ANDPS = 380
%term IA32_ANDPD = 381
%term IA32_ANDNPS = 382
%term IA32_ANDNPD = 383
%term IA32_ORPS = 384
%term IA32_ORPD = 385
%term IA32_XORPS = 386
%term IA32_XORPD = 387
%term IA32_UCOMISS = 388
%term IA32_UCOMISD = 389
%term IA32_CMPEQSS = 390
%term IA32_CMPLTSS = 391
%term IA32_CMPLESS = 392
%term IA32_CMPUNORDSS = 393
%term IA32_CMPNESS = 394
%term IA32_CMPNLTSS = 395
%term IA32_CMPNLESS = 396
%term IA32_CMPORDSS = 397
%term IA32_CMPEQSD = 398
%term IA32_CMPLTSD = 399
%term IA32_CMPLESD = 400
%term IA32_CMPUNORDSD = 401
%term IA32_CMPNESD = 402
%term IA32_CMPNLTSD = 403
%term IA32_CMPNLESD = 404
%term IA32_CMPORDSD = 405
%term IA32_MOVAPD = 406
%term IA32_MOVAPS = 407
%term IA32_MOVLPD = 408
%term IA32_MOVLPS = 409
%term IA32_MOVSS = 410
%term IA32_MOVSD = 411
%term IA32_MOVD = 412
%term IA32_MOVQ = 413
%term IA32_PSLLQ = 414
%term IA32_PSRLQ = 415
%term IA32_SQRTSS = 416
%term IA32_SQRTSD = 417
%term IA32_CVTSI2SS = 418
%term IA32_CVTSS2SD = 419
%term IA32_CVTSS2SI = 420
%term IA32_CVTTSS2SI = 421
%term IA32_CVTSI2SD = 422
%term IA32_CVTSD2SS = 423
%term IA32_CVTSD2SI = 424
%term IA32_CVTTSD2SI = 425
%term IA32_CVTSI2SDQ = 426
%term IA32_CVTSD2SIQ = 427
%term IA32_CVTTSD2SIQ = 428
%term MIR_END = 429
%%
stm:	r		"" 0
r:	REGISTER		"" 0
r:	czr		"" 0
cz:	czr		"" 0
r:	szpr		"" 0
szp:	szpr		"" 0
riv:	r		"" 0
riv:	INT_CONSTANT		"" 0
rlv:	r		"" 0
rlv:	LONG_CONSTANT		"" 0
any:	NULL		"" 0
any:	riv		"" 0
any:	ADDRESS_CONSTANT		"" 0
any:	LONG_CONSTANT		"" 0
any:	OTHER_OPERAND(any, any)		"" 0
stm:	IG_PATCH_POINT		"" 10
stm:	UNINT_BEGIN		"" 10
stm:	UNINT_END		"" 10
stm:	YIELDPOINT_PROLOGUE		"" 10
stm:	YIELDPOINT_EPILOGUE		"" 10
stm:	YIELDPOINT_BACKEDGE		"" 10
r: FRAMESIZE		"" 10
stm:	LOWTABLESWITCH(r)		"" 10
stm:	RESOLVE		"" 10
stm:	NOP		"" 10
r:	GUARD_MOVE		"" 11
r:	GUARD_COMBINE		"" 11
stm:	NULL_CHECK(riv)		"" 11
stm:	IR_PROLOGUE		"" 11
r:	GET_CAUGHT_EXCEPTION		"" 11
stm:	SET_CAUGHT_EXCEPTION(r)		"" 11
stm: SET_CAUGHT_EXCEPTION(INT_CONSTANT)		"" 20
stm: SET_CAUGHT_EXCEPTION(LONG_CONSTANT)		"" 20
stm:	TRAP		"" 10
stm:	TRAP_IF(r, INT_CONSTANT)		"" 10
stm:	TRAP_IF(r, LONG_CONSTANT)		"" 10
stm:	TRAP_IF(r, r)		"" 10
stm:	TRAP_IF(load32, riv)		"" 15
stm:	TRAP_IF(riv, load32)		"" 15
uload8:	INT_AND(load8_16_32, INT_CONSTANT)		"" (VR(p) == 0xff ? 0 : INFINITE)
r:	INT_AND(load8_16_32, INT_CONSTANT)		"" (VR(p) == 0xff ? 15 : INFINITE)
r:	INT_2BYTE(load8_16_32)		"" 20
r:	INT_USHR(INT_SHL(load8_16_32, INT_CONSTANT), INT_CONSTANT)		"" (VR(p) == 24 && VLLR(p) == 24 ? 15 : INFINITE)
r:	INT_AND(load16_32, INT_CONSTANT)		"" (VR(p) == 0xffff ? 15 : INFINITE)
r:	INT_USHR(INT_SHL(load16_32, INT_CONSTANT), INT_CONSTANT)		"" (VR(p) == 16 && VLR(p) == 16 ? 15 : INFINITE)
stm:	SHORT_STORE(riv, OTHER_OPERAND(riv, riv))		"" 15
stm:	SHORT_STORE(load16, OTHER_OPERAND(riv, riv))		"" 25
stm:    SHORT_STORE(rlv, OTHER_OPERAND(rlv, rlv))		"" 15
stm:    SHORT_STORE(riv, OTHER_OPERAND(rlv, rlv))		"" 15
stm:	SHORT_ASTORE(riv, OTHER_OPERAND(riv, riv))		"" 15
stm:	SHORT_ASTORE(load16, OTHER_OPERAND(riv, riv))		"" 25
stm:	SHORT_ASTORE(riv, OTHER_OPERAND(r, r))		"" 10
stm:	INT_ASTORE(riv, OTHER_OPERAND(riv, riv))		"" 15
stm:	INT_ASTORE(riv, OTHER_OPERAND(r, r))		"" 10
stm:	INT_ASTORE(riv, OTHER_OPERAND(rlv, rlv))		"" 15
stm:	INT_ASTORE(riv, OTHER_OPERAND(rlv, riv))		"" 15
stm:	INT_ASTORE(riv, OTHER_OPERAND(riv, rlv))		"" 15
stm:	LONG_ASTORE(r, OTHER_OPERAND(riv, riv))		"" 30
stm:	LONG_ASTORE(r, OTHER_OPERAND(rlv, rlv))		"" 15
stm:	LONG_ASTORE(r, OTHER_OPERAND(r, r))		"" 10
stm:	LONG_ASTORE(LONG_CONSTANT, OTHER_OPERAND(riv, riv))		"" 26
stm:	LONG_ASTORE(LONG_CONSTANT, OTHER_OPERAND(rlv, riv))		"" 26
r:	LONG_CMP(rlv,rlv)		"" 10*13
stm:	GOTO		"" 11
stm:	PREFETCH(r)		"" 11
stm:	WRITE_FLOOR		"" 11
stm:	READ_CEILING		"" 11
stm:	FENCE		"" 11
stm:	PAUSE		"" 11
stm:	ILLEGAL_INSTRUCTION		"" 11
stm:	RETURN(NULL)		"" 13
stm:	RETURN(INT_CONSTANT)		"" 11
stm:	RETURN(r)		"" 13
stm:	RETURN(LONG_CONSTANT)		"" 11
r:	CALL(r, any)		"" 13
r:	CALL(BRANCH_TARGET, any)		"" 13
r:	CALL(INT_LOAD(riv, riv), any)		"" 11
r:	CALL(INT_CONSTANT, any)		"" 23
r:	CALL(LONG_LOAD(rlv, rlv), any)		"" 11
r:	SYSCALL(r, any)		"" 13
r:	SYSCALL(INT_LOAD(riv, riv), any)		"" 11
r:	SYSCALL(INT_CONSTANT, any)		"" 23
r:      GET_TIME_BASE		"" 15
stm:	YIELDPOINT_OSR(any, any)		"" 10
address1scaledreg:	address1reg		"" 0
address:	address1scaledreg		"" 0
address1scaledreg:	INT_SHL(r, INT_CONSTANT)		"" LEA_SHIFT(Binary.getVal2(P(p)), 0)
address1reg:	INT_ADD(r, LONG_CONSTANT)		"" 0
address1reg:	INT_MOVE(r)		"" 0
address:	INT_ADD(r, r)		"" 0
address1reg:	INT_ADD(address1reg, LONG_CONSTANT)		"" 0
address1scaledreg:	INT_ADD(address1scaledreg, LONG_CONSTANT)		"" 0
address:	INT_ADD(r, address1scaledreg)		"" 0
address:	INT_ADD(address1scaledreg, r)		"" 0
address:	INT_ADD(address1scaledreg, LONG_CONSTANT)		"" 0
address:	INT_ADD(address1scaledreg, address1reg)		"" 0
address:	INT_ADD(address1reg, address1scaledreg)		"" 0
address1scaledreg:	LONG_SHL(r, INT_CONSTANT)		"" LEA_SHIFT(Binary.getVal2(P(p)), 0)
address1reg:	LONG_ADD(r, LONG_CONSTANT)		"" 0
address1reg:	LONG_MOVE(r)		"" 0
address:	LONG_ADD(r, r)		"" 0
address1reg:	LONG_ADD(address1reg, LONG_CONSTANT)		"" 0
address1scaledreg:	LONG_ADD(address1scaledreg, LONG_CONSTANT)		"" 0
address:	LONG_ADD(r, address1scaledreg)		"" 0
address:	LONG_ADD(address1scaledreg, r)		"" 0
address:	LONG_ADD(address1scaledreg, LONG_CONSTANT)		"" 0
address:	LONG_ADD(address1scaledreg, address1reg)		"" 0
address:	LONG_ADD(address1reg, address1scaledreg)		"" 0
r:	ATTEMPT_INT(riv, OTHER_OPERAND(riv, OTHER_OPERAND(riv, riv)))		"" 67
r:	ATTEMPT_INT(riv, OTHER_OPERAND(rlv, OTHER_OPERAND(riv, riv)))		"" 67
r:	ATTEMPT_INT(rlv, OTHER_OPERAND(rlv, OTHER_OPERAND(riv, riv)))		"" 67
r:	ATTEMPT_INT(r, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv, riv)))		"" 67
r:	ATTEMPT_INT(address1scaledreg, OTHER_OPERAND(r, OTHER_OPERAND(riv, riv)))		"" 67
r:	ATTEMPT_INT(address1scaledreg, OTHER_OPERAND(address1reg, OTHER_OPERAND(riv, riv)))		"" 67
r:	ATTEMPT_INT(address1reg, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv, riv)))		"" 67
r:	ATTEMPT_INT(address, OTHER_OPERAND(INT_CONSTANT, OTHER_OPERAND(riv, riv)))		"" 67
r:	ATTEMPT_INT(INT_CONSTANT, OTHER_OPERAND(address, OTHER_OPERAND(riv, riv)))		"" 67
stm:	INT_IFCMP(ATTEMPT_INT(riv, OTHER_OPERAND(riv, OTHER_OPERAND(riv,riv))),INT_CONSTANT)		"" isZERO(VR(p), 54)
stm:	INT_IFCMP(ATTEMPT_INT(r, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv,riv))),INT_CONSTANT)		"" isZERO(VR(p), 54)
stm:	INT_IFCMP(ATTEMPT_INT(address1scaledreg, OTHER_OPERAND(r, OTHER_OPERAND(riv,riv))),INT_CONSTANT)		"" isZERO(VR(p), 54)
stm:	INT_IFCMP(ATTEMPT_INT(address1scaledreg, OTHER_OPERAND(address1reg, OTHER_OPERAND(riv,riv))),INT_CONSTANT)		"" isZERO(VR(p),54)
stm:	INT_IFCMP(ATTEMPT_INT(address1reg, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv,riv))),INT_CONSTANT)		"" isZERO(VR(p),54)
stm:	INT_IFCMP(ATTEMPT_INT(address, OTHER_OPERAND(INT_CONSTANT, OTHER_OPERAND(riv,riv))),INT_CONSTANT)		"" isZERO(VR(p), 54)
stm:	INT_IFCMP(ATTEMPT_INT(INT_CONSTANT, OTHER_OPERAND(address, OTHER_OPERAND(riv,riv))),INT_CONSTANT)		"" isZERO(VR(p),54)
stm:	INT_IFCMP(ATTEMPT_INT(riv, OTHER_OPERAND(riv, OTHER_OPERAND(riv,riv))), INT_CONSTANT)		"" isONE(VR(p), 54)
stm:	INT_IFCMP(ATTEMPT_INT(r, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv,riv))),INT_CONSTANT)		"" isONE(VR(p), 54)
stm:	INT_IFCMP(ATTEMPT_INT(address1scaledreg, OTHER_OPERAND(r, OTHER_OPERAND(riv,riv))),INT_CONSTANT)		"" isONE(VR(p), 54)
stm:	INT_IFCMP(ATTEMPT_INT(address1scaledreg, OTHER_OPERAND(address1reg, OTHER_OPERAND(riv,riv))),INT_CONSTANT)		"" isONE(VR(p), 54)
stm:	INT_IFCMP(ATTEMPT_INT(address1reg, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv,riv))),INT_CONSTANT)		"" isONE(VR(p), 54)
stm:	INT_IFCMP(ATTEMPT_INT(address, OTHER_OPERAND(INT_CONSTANT, OTHER_OPERAND(riv,riv))),INT_CONSTANT)		"" isONE(VR(p), 54)
stm:	INT_IFCMP(ATTEMPT_INT(INT_CONSTANT, OTHER_OPERAND(address, OTHER_OPERAND(riv,riv))),INT_CONSTANT)		"" isONE(VR(p), 54)
r:	ATTEMPT_LONG(rlv, OTHER_OPERAND(rlv, OTHER_OPERAND(rlv, rlv)))		"" 67
r:	ATTEMPT_LONG(r, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(rlv, rlv)))		"" 67
r:	ATTEMPT_LONG(address1scaledreg, OTHER_OPERAND(r, OTHER_OPERAND(rlv, rlv)))		"" 67
r:	ATTEMPT_LONG(address1scaledreg, OTHER_OPERAND(address1reg, OTHER_OPERAND(rlv, rlv)))		"" 67
r:	ATTEMPT_LONG(address1reg, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(rlv, rlv)))		"" 67
r:	ATTEMPT_LONG(address, OTHER_OPERAND(LONG_CONSTANT, OTHER_OPERAND(rlv, rlv)))		"" 67
r:	ATTEMPT_LONG(LONG_CONSTANT, OTHER_OPERAND(address, OTHER_OPERAND(rlv, rlv)))		"" 67
stm:	INT_IFCMP(ATTEMPT_LONG(rlv, OTHER_OPERAND(rlv, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)		"" isZERO(VR(p), 54)
stm:	INT_IFCMP(ATTEMPT_LONG(r, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)		"" isZERO(VR(p), 54)
stm:	INT_IFCMP(ATTEMPT_LONG(address1scaledreg, OTHER_OPERAND(r, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)		"" isZERO(VR(p), 54)
stm:	INT_IFCMP(ATTEMPT_LONG(address1scaledreg, OTHER_OPERAND(address1reg, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)		"" isZERO(VR(p),54)
stm:	INT_IFCMP(ATTEMPT_LONG(address1reg, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)		"" isZERO(VR(p),54)
stm:	INT_IFCMP(ATTEMPT_LONG(address, OTHER_OPERAND(LONG_CONSTANT, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)		"" isZERO(VR(p), 54)
stm:	INT_IFCMP(ATTEMPT_LONG(LONG_CONSTANT, OTHER_OPERAND(address, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)		"" isZERO(VR(p),54)
stm:	INT_IFCMP(ATTEMPT_LONG(rlv, OTHER_OPERAND(rlv, OTHER_OPERAND(rlv,rlv))), INT_CONSTANT)		"" isONE(VR(p), 54)
stm:	INT_IFCMP(ATTEMPT_LONG(r, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)		"" isONE(VR(p), 54)
stm:	INT_IFCMP(ATTEMPT_LONG(address1scaledreg, OTHER_OPERAND(r, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)		"" isONE(VR(p), 54)
stm:	INT_IFCMP(ATTEMPT_LONG(address1scaledreg, OTHER_OPERAND(address1reg, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)		"" isONE(VR(p), 54)
stm:	INT_IFCMP(ATTEMPT_LONG(address1reg, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)		"" isONE(VR(p), 54)
stm:	INT_IFCMP(ATTEMPT_LONG(address, OTHER_OPERAND(LONG_CONSTANT, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)		"" isONE(VR(p), 54)
stm:	INT_IFCMP(ATTEMPT_LONG(LONG_CONSTANT, OTHER_OPERAND(address, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)		"" isONE(VR(p), 54)
bittest:	INT_AND(INT_USHR(r,INT_AND(r,INT_CONSTANT)),INT_CONSTANT)		"" ((VR(p) == 1) && (VLRR(p) == 31) ? 13:INFINITE)
bittest:	INT_AND(INT_USHR(load32,INT_AND(r,INT_CONSTANT)),INT_CONSTANT)		"" (VR(p) == 1 ? 31:INFINITE)
bittest:	INT_AND(INT_USHR(r,INT_CONSTANT),INT_CONSTANT)		"" ((VR(p) == 1) && (VLR(p) <= 31) ? 13:INFINITE)
bittest:	INT_AND(INT_SHR(r,INT_AND(r,INT_CONSTANT)),INT_CONSTANT)		"" ((VR(p) == 1) && (VLRR(p) == 31) ? 13:INFINITE)
bittest:	INT_AND(INT_SHR(load32,INT_AND(r,INT_CONSTANT)),INT_CONSTANT)		"" (VR(p) == 1 ? 31:INFINITE)
bittest:	INT_AND(INT_SHR(r,INT_CONSTANT),INT_CONSTANT)		"" ((VR(p) == 1) && (VLR(p) <= 31) ? 13:INFINITE)
bittest:	INT_AND(INT_SHL(INT_CONSTANT,INT_AND(riv,INT_CONSTANT)),r)		"" ((VLL(p) == 1) && (VLRR(p) == 31)? 13:INFINITE)
bittest:	INT_AND(INT_SHL(INT_CONSTANT,INT_AND(r, INT_CONSTANT)),load32)		"" (VLL(p) == 1 ? 31:INFINITE)
bittest:	INT_AND(r,INT_SHL(INT_CONSTANT,INT_AND(r, INT_CONSTANT)))		"" ((VRL(p) == 1) && (VRRR(p) == 31) ? 13:INFINITE)
bittest:	INT_AND(load32,INT_SHL(INT_CONSTANT,INT_AND(r, INT_CONSTANT)))		"" (VRL(p) == 1 ? 31:INFINITE)
r:	BOOLEAN_CMP_INT(r,riv)		"" 39
boolcmp: BOOLEAN_CMP_INT(r,riv)		"" 13
r:	BOOLEAN_CMP_INT(r,INT_CONSTANT)		"" (VR(p) == 0 && CMP_TO_TEST(BooleanCmp.getCond(P(p))) ? 37:INFINITE)
boolcmp: BOOLEAN_CMP_INT(r,INT_CONSTANT)		"" (VR(p) == 0 && CMP_TO_TEST(BooleanCmp.getCond(P(p))) ? 11:INFINITE)
r:	BOOLEAN_CMP_INT(r,INT_CONSTANT)		"" (VR(p) == 0 && BooleanCmp.getCond(P(p)).isLESS() ? 11 : INFINITE)
r:	BOOLEAN_CMP_INT(load32,INT_CONSTANT)		"" (VR(p) == 0 && BooleanCmp.getCond(P(p)).isLESS() ? 16 : INFINITE)
r:	BOOLEAN_CMP_INT(r,INT_CONSTANT)		"" (VR(p) == 0 && BooleanCmp.getCond(P(p)).isGREATER_EQUAL() ? 22 : INFINITE)
r:	BOOLEAN_CMP_INT(load32,INT_CONSTANT)		"" (VR(p) == 0 && BooleanCmp.getCond(P(p)).isGREATER_EQUAL() ? 27 : INFINITE)
r:	BOOLEAN_CMP_INT(cz, INT_CONSTANT)		"" isZERO(VR(p), 26)
boolcmp: BOOLEAN_CMP_INT(cz, INT_CONSTANT)		"" isZERO(VR(p), 0)
r:	BOOLEAN_CMP_INT(szp, INT_CONSTANT)		"" (VR(p) == 0 && EQ_NE(BooleanCmp.getCond(P(p)))?26:INFINITE)
boolcmp: BOOLEAN_CMP_INT(szp, INT_CONSTANT)		"" (VR(p) == 0 && EQ_NE(BooleanCmp.getCond(P(p)))?0:INFINITE)
r:	BOOLEAN_CMP_INT(bittest, INT_CONSTANT)		"" ((VR(p) == 0 || VR(p) == 1) && EQ_NE(BooleanCmp.getCond(P(p))) ? 26 : INFINITE)
boolcmp:	BOOLEAN_CMP_INT(bittest, INT_CONSTANT)		"" ((VR(p) == 0 || VR(p) == 1) && EQ_NE(BooleanCmp.getCond(P(p))) ? 0 : INFINITE)
r:	BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)		"" ((VR(p) == 0 && BooleanCmp.getCond(P(p)).isNOT_EQUAL()) || (VR(p) == 1 && BooleanCmp.getCond(P(p)).isEQUAL()) ? 26 : INFINITE)
boolcmp:	BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)		"" ((VR(p) == 0 && BooleanCmp.getCond(P(p)).isNOT_EQUAL()) || (VR(p) == 1 && BooleanCmp.getCond(P(p)).isEQUAL()) ? 0 : INFINITE)
r:	BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)		"" ((VR(p) == 1 && BooleanCmp.getCond(P(p)).isNOT_EQUAL()) || (VR(p) == 0 && BooleanCmp.getCond(P(p)).isEQUAL()) ? 26 : INFINITE)
boolcmp:	BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)		"" ((VR(p) == 1 && BooleanCmp.getCond(P(p)).isNOT_EQUAL()) || (VR(p) == 0 && BooleanCmp.getCond(P(p)).isEQUAL()) ? 0 : INFINITE)
r:	BOOLEAN_CMP_INT(load32,riv)		"" 41
boolcmp: BOOLEAN_CMP_INT(load32,riv)		"" 15
r:	BOOLEAN_CMP_INT(r,load32)		"" 41
boolcmp: BOOLEAN_CMP_INT(riv,load32)		"" 15
stm:	BYTE_STORE(boolcmp, OTHER_OPERAND(riv,riv))		"" 15
stm:	BYTE_ASTORE(boolcmp, OTHER_OPERAND(riv, riv))		"" 15
r:	BOOLEAN_CMP_LONG(r,rlv)		"" 39
boolcmp: BOOLEAN_CMP_LONG(r,rlv)		"" 13
r:	BOOLEAN_CMP_LONG(r,LONG_CONSTANT)		"" ((LV(BooleanCmp.getVal2(P(p))) == 0) && CMP_TO_TEST(BooleanCmp.getCond(P(p))) ? 37:INFINITE)
boolcmp: BOOLEAN_CMP_LONG(r,LONG_CONSTANT)		"" ((LV(BooleanCmp.getVal2(P(p))) == 0) && CMP_TO_TEST(BooleanCmp.getCond(P(p))) ? 11:INFINITE)
r:	BOOLEAN_CMP_LONG(r,LONG_CONSTANT)		"" ((LV(BooleanCmp.getVal2(P(p))) == 0) && BooleanCmp.getCond(P(p)).isLESS() ? 11 : INFINITE)
r:	BOOLEAN_CMP_LONG(load64,LONG_CONSTANT)		"" ((LV(BooleanCmp.getVal2(P(p))) == 0) && BooleanCmp.getCond(P(p)).isLESS() ? 16 : INFINITE)
r:	BOOLEAN_CMP_LONG(r,LONG_CONSTANT)		"" ((LV(BooleanCmp.getVal2(P(p))) == 0) && BooleanCmp.getCond(P(p)).isGREATER_EQUAL() ? 22 : INFINITE)
r:	BOOLEAN_CMP_LONG(load64,LONG_CONSTANT)		"" ((LV(BooleanCmp.getVal2(P(p))) == 0) && BooleanCmp.getCond(P(p)).isGREATER_EQUAL() ? 27 : INFINITE)
r:	BOOLEAN_CMP_LONG(cz, LONG_CONSTANT)		"" ((LV(BooleanCmp.getVal2(P(p))) == 0) ? 26 : INFINITE)
r:	BOOLEAN_CMP_LONG(load64,rlv)		"" 41
boolcmp: BOOLEAN_CMP_LONG(load64,rlv)		"" 15
r:	BOOLEAN_CMP_LONG(r,load64)		"" 41
boolcmp: BOOLEAN_CMP_LONG(rlv,load64)		"" 15
r:	BOOLEAN_NOT(r)		"" 13
stm:	BYTE_STORE(BOOLEAN_NOT(UBYTE_LOAD(rlv,rlv)),OTHER_OPERAND(rlv, rlv))		"" ADDRESS_EQUAL(P(p), PLL(p), 17)
stm:	BYTE_ASTORE(BOOLEAN_NOT(UBYTE_ALOAD(rlv,riv)),OTHER_OPERAND(rlv, riv))		"" ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
stm:    BYTE_STORE(riv, OTHER_OPERAND(rlv, rlv))		"" 15
stm:    BYTE_STORE(load8, OTHER_OPERAND(rlv, rlv))		"" 25
stm:    BYTE_ASTORE(riv, OTHER_OPERAND(rlv, riv))		"" 15
stm:    BYTE_ASTORE(load8, OTHER_OPERAND(rlv, riv))		"" 25
r: CMP_CMOV(r, OTHER_OPERAND(riv, any))		"" (13 + 30)
r: CMP_CMOV(r, OTHER_OPERAND(INT_CONSTANT, any))		"" (VRL(p) == 0 && CMP_TO_TEST(CondMove.getCond(P(p))) ? (11 + 30):INFINITE)
r: CMP_CMOV(r, OTHER_OPERAND(INT_CONSTANT, OTHER_OPERAND(INT_CONSTANT, INT_CONSTANT)))		"" ((VRL(p) == 0 && CondMove.getCond(P(p)).isLESS() && VRRL(p) == -1 && VRRR(p) == 0) || (VRL(p) == 0 && CondMove.getCond(P(p)).isGREATER_EQUAL() && VRRL(p) == 0 && VRRR(p) == -1) ? 13 : INFINITE)
r: CMP_CMOV(load32, OTHER_OPERAND(INT_CONSTANT, OTHER_OPERAND(INT_CONSTANT, INT_CONSTANT)))		"" ((VRL(p) == 0 && CondMove.getCond(P(p)).isLESS() && VRRL(p) == -1 && VRRR(p) == 0) || (VRL(p) == 0 && CondMove.getCond(P(p)).isGREATER_EQUAL() && VRRL(p) == 0 && VRRR(p) == -1) ? 18 : INFINITE)
r: CMP_CMOV(r, OTHER_OPERAND(INT_CONSTANT, OTHER_OPERAND(INT_CONSTANT, INT_CONSTANT)))		"" ((VRL(p) == 0 && CondMove.getCond(P(p)).isLESS() && VRRL(p) == 0 && VRRR(p) == -1) || (VRL(p) == 0 && CondMove.getCond(P(p)).isGREATER_EQUAL() && VRRL(p) == -1 && VRRR(p) == 0) ? 26 : INFINITE)
r: CMP_CMOV(load32, OTHER_OPERAND(INT_CONSTANT, OTHER_OPERAND(INT_CONSTANT, INT_CONSTANT)))		"" ((VRL(p) == 0 && CondMove.getCond(P(p)).isLESS() && VRRL(p) == 0 && VRRR(p) == -1) || (VRL(p) == 0 && CondMove.getCond(P(p)).isGREATER_EQUAL() && VRRL(p) == -1 && VRRR(p) == 0) ? 31 : INFINITE)
r: CMP_CMOV(load8, OTHER_OPERAND(INT_CONSTANT, any))		"" FITS(CondMove.getVal2(P(p)), 8, (15 + 30))
r: CMP_CMOV(uload8, OTHER_OPERAND(riv, any))		"" (15 + 30)
r: CMP_CMOV(riv, OTHER_OPERAND(uload8, any))		"" (15 + 30)
r: CMP_CMOV(sload16, OTHER_OPERAND(INT_CONSTANT, any))		"" FITS(CondMove.getVal2(P(p)), 8, (15 + 30))
r: CMP_CMOV(load32, OTHER_OPERAND(riv, any))		"" (15 + 30)
r: CMP_CMOV(riv, OTHER_OPERAND(load32, any))		"" (15 + 30)
r: CMP_CMOV(boolcmp, OTHER_OPERAND(INT_CONSTANT, any))		"" ((VRL(p) == 0 && CondMove.getCond(P(p)).isNOT_EQUAL()) || (VRL(p) == 1 && CondMove.getCond(P(p)).isEQUAL()) ? 30 : INFINITE)
r: CMP_CMOV(boolcmp, OTHER_OPERAND(INT_CONSTANT, any))		"" ((VRL(p) == 1 && CondMove.getCond(P(p)).isNOT_EQUAL()) || (VRL(p) == 0 && CondMove.getCond(P(p)).isEQUAL()) ? 30 : INFINITE)
r: CMP_CMOV(bittest, OTHER_OPERAND(INT_CONSTANT, any))		"" ((VRL(p) == 0 || VRL(p) == 1) && EQ_NE(CondMove.getCond(P(p))) ? 30 : INFINITE)
r: CMP_CMOV(cz, OTHER_OPERAND(INT_CONSTANT, any))		"" isZERO(VRL(p), 30)
r: CMP_CMOV(szp, OTHER_OPERAND(INT_CONSTANT, any))		"" isZERO(VRL(p), 30)
r:	INT_2BYTE(r)		"" 15
r:	INT_2BYTE(load8_16_32)		"" 17
stm:	BYTE_STORE(INT_2BYTE(r),OTHER_OPERAND(riv, riv))		"" 15
stm:	BYTE_ASTORE(INT_2BYTE(r),OTHER_OPERAND(riv, riv))		"" 15
r:	INT_2LONG(r)		"" 15
r:	INT_2LONG(load32)		"" 13
r:      LONG_AND(INT_2LONG(r), LONG_CONSTANT)		"" ((Binary.getVal2(P(p)).asLongConstant().upper32() == 0) && (Binary.getVal2(P(p)).asLongConstant().lower32() == -1)? 11 : INFINITE)
r:      LONG_AND(INT_2LONG(load32), LONG_CONSTANT)		"" ((Binary.getVal2(P(p)).asLongConstant().upper32() == 0) && (Binary.getVal2(P(p)).asLongConstant().lower32() == -1)? 13 : INFINITE)
r:	INT_2ADDRZerExt(r)		"" 15
r:	INT_2SHORT(r)		"" 15
r:	INT_2SHORT(load16_32)		"" 17
sload16:	INT_2SHORT(load16_32)		"" 0
stm:	SHORT_STORE(INT_2SHORT(r), OTHER_OPERAND(riv,riv))		"" 15
stm:	SHORT_ASTORE(INT_2SHORT(r), OTHER_OPERAND(riv, riv))		"" 15
szpr:	INT_2USHORT(r)		"" 23
uload16:	INT_2USHORT(load16_32)		"" 0
r:	INT_2USHORT(load16_32)		"" 15
stm:	SHORT_STORE(INT_2USHORT(r), OTHER_OPERAND(riv,riv))		"" 15
stm:	SHORT_ASTORE(INT_2USHORT(r), OTHER_OPERAND(riv, riv))		"" 15
czr:	INT_ADD(r, riv)		"" 13
r:	INT_ADD(r, riv)		"" 11
czr:	INT_ADD(r, load32)		"" 15
czr:	INT_ADD(load32, riv)		"" 15
stm:	INT_STORE(INT_ADD(INT_LOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))		"" ADDRESS_EQUAL(P(p), PLL(p), 17)
stm:	INT_STORE(INT_ADD(riv,INT_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))		"" ADDRESS_EQUAL(P(p), PLR(p), 17)
stm:	INT_ASTORE(INT_ADD(INT_ALOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))		"" ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
stm:	INT_ASTORE(INT_ADD(riv,INT_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))		"" ARRAY_ADDRESS_EQUAL(P(p), PLR(p), 17)
szpr:	INT_AND(r, riv)		"" 13
szp:	INT_AND(r, riv)		"" 11
szpr:	INT_AND(r, load32)		"" 15
szpr:	INT_AND(load32, riv)		"" 15
szp:	INT_AND(load8_16_32, riv)		"" 11
szp:	INT_AND(r, load8_16_32)		"" 11
stm:	INT_STORE(INT_AND(INT_LOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))		"" ADDRESS_EQUAL(P(p), PLL(p), 17)
stm:	INT_STORE(INT_AND(r,INT_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))		"" ADDRESS_EQUAL(P(p), PLR(p), 17)
stm:	INT_ASTORE(INT_AND(INT_ALOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))		"" ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
stm:	INT_ASTORE(INT_AND(r,INT_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))		"" ARRAY_ADDRESS_EQUAL(P(p), PLR(p), 17)
r:	INT_DIV(riv, riv)		"" 52
r:	INT_DIV(riv, load32)		"" 55
r:     UNSIGNED_DIV_64_32(rlv, riv)		"" 52
r:     UNSIGNED_DIV_64_32(rlv, load32)		"" 55
stm:	INT_IFCMP(r,riv)		"" 26
stm:	INT_IFCMP(r, INT_CONSTANT)		"" (VR(p) == 0 && CMP_TO_TEST(IfCmp.getCond(P(p))) ? 24:INFINITE)
stm:	INT_IFCMP(load8, INT_CONSTANT)		"" FITS(IfCmp.getVal2(P(p)), 8, 28)
stm:	INT_IFCMP(uload8, r)		"" 28
stm:	INT_IFCMP(r, uload8)		"" 28
stm:	INT_IFCMP(sload16, INT_CONSTANT)		"" FITS(IfCmp.getVal2(P(p)), 8, 28)
stm:	INT_IFCMP(load32, riv)		"" 28
stm:	INT_IFCMP(r, load32)		"" 28
stm:	INT_IFCMP(boolcmp, INT_CONSTANT)		"" ((VR(p) == 0 && IfCmp.getCond(P(p)).isNOT_EQUAL()) || (VR(p) == 1 && IfCmp.getCond(P(p)).isEQUAL()) ? 13:INFINITE)
stm:	INT_IFCMP(boolcmp, INT_CONSTANT)		"" ((VR(p) == 0 && IfCmp.getCond(P(p)).isEQUAL()) || (VR(p) == 1 && IfCmp.getCond(P(p)).isNOT_EQUAL()) ? 13:INFINITE)
stm:	INT_IFCMP(cz, INT_CONSTANT)		"" isZERO(VR(p), 11)
stm:	INT_IFCMP(szp, INT_CONSTANT)		"" (VR(p) == 0 && EQ_NE(IfCmp.getCond(P(p)))?11:INFINITE)
stm:	INT_IFCMP(bittest, INT_CONSTANT)		"" ((VR(p) == 0 || VR(p) == 1) && EQ_NE(IfCmp.getCond(P(p))) ? 11 : INFINITE)
stm:	INT_IFCMP2(r,riv)		"" 26
stm:	INT_IFCMP2(load32,riv)		"" 28
stm:	INT_IFCMP2(riv,load32)		"" 28
r:	INT_LOAD(rlv, rlv)		"" 15
r:	INT_LOAD(rlv, address1scaledreg)		"" 15
r:	INT_LOAD(address1scaledreg, rlv)		"" 15
r:	INT_LOAD(address1scaledreg, address1reg)		"" 15
r:	INT_LOAD(address1reg, address1scaledreg)		"" 15
r:	INT_LOAD(address, LONG_CONSTANT)		"" 15
r:      INT_ALOAD(rlv, riv)		"" 15
r:	INT_MOVE(riv)		"" 13
czr:	INT_MOVE(czr)		"" 11
cz:	INT_MOVE(cz)		"" 0
szpr:	INT_MOVE(szpr)		"" 11
szp:	INT_MOVE(szp)		"" 0
sload8:	INT_MOVE(sload8)		"" 0
uload8:	INT_MOVE(uload8)		"" 0
load8:	INT_MOVE(load8)		"" 0
sload16: INT_MOVE(sload16)		"" 0
uload16: INT_MOVE(uload16)		"" 0
load16:	INT_MOVE(load16)		"" 0
load32:	INT_MOVE(load32)		"" 0
r:	INT_MUL(r, riv)		"" 13
r:	INT_MUL(r, load32)		"" 15
r:	INT_MUL(load32, riv)		"" 15
szpr:	INT_NEG(r)		"" 13
stm:	INT_STORE(INT_NEG(INT_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))		"" ADDRESS_EQUAL(P(p), PLL(p), 17)
stm:	INT_ASTORE(INT_NEG(INT_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))		"" ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
r:	INT_NOT(r)		"" 13
stm:	INT_STORE(INT_NOT(INT_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))		"" ADDRESS_EQUAL(P(p), PLL(p), 17)
stm:	INT_ASTORE(INT_NOT(INT_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))		"" ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
szpr:	INT_OR(r, riv)		"" 13
szpr:	INT_OR(r, load32)		"" 15
szpr:	INT_OR(load32, riv)		"" 15
stm:	INT_STORE(INT_OR(INT_LOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))		"" ADDRESS_EQUAL(P(p), PLL(p), 17)
stm:	INT_STORE(INT_OR(r, INT_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))		"" ADDRESS_EQUAL(P(p), PLR(p), 17)
stm:	INT_ASTORE(INT_OR(INT_ALOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))		"" ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
stm:	INT_ASTORE(INT_OR(r, INT_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))		"" ARRAY_ADDRESS_EQUAL(P(p), PLR(p), 17)
r:	INT_REM(riv, riv)		"" 52
r:	INT_REM(riv, load32)		"" 55
r:     UNSIGNED_REM_64_32(rlv, riv)		"" 52
r:     UNSIGNED_REM_64_32(rlv, load32)		"" 55
r:	INT_OR(INT_SHL(r,INT_CONSTANT),INT_USHR(r,INT_CONSTANT))		"" (Binary.getVal1(PL(p)).similar(Binary.getVal1(PR(p))) && ((-VLR(p)) & 0x1f) == (VRR(p)&0x1f) ? 13 : INFINITE)
r:      INT_OR(INT_USHR(r,INT_CONSTANT),INT_SHL(r,INT_CONSTANT))		"" (Binary.getVal1(PL(p)).similar(Binary.getVal1(PR(p))) && ((-VRR(p)) & 0x1f) == (VLR(p)&0x1f) ? 13 : INFINITE)
r:      INT_OR(INT_SHL(r,INT_CONSTANT),INT_USHR(r,INT_CONSTANT))		"" (Binary.getVal1(PL(p)).similar(Binary.getVal1(PR(p))) && ((-VLR(p)) & 0x1f) == (VRR(p)&0x1f) && ((VLR(p)&0x1f) == 31) ? 11 : INFINITE)
r:      INT_OR(INT_USHR(r,INT_CONSTANT),INT_SHL(r,INT_CONSTANT))		"" (Binary.getVal1(PL(p)).similar(Binary.getVal1(PR(p))) && ((-VRR(p)) & 0x1f) == (VLR(p)&0x1f) && ((VRR(p)&0x1f) == 31) ? 11 : INFINITE)
r:      INT_OR(INT_SHL(r,INT_AND(r,INT_CONSTANT)),INT_USHR(r,INT_AND(INT_NEG(r),INT_CONSTANT)))		"" (Binary.getVal1(PL(p)).similar(Binary.getVal1(PR(p))) && (VLRR(p) == 31) && (VRRR(p) == 31) && Binary.getVal1(PLR(p)).similar(Unary.getVal(PRRL(p))) ? 23 : INFINITE)
r:      INT_OR(INT_USHR(r,INT_AND(INT_NEG(r),INT_CONSTANT)),INT_SHL(r,INT_AND(r,INT_CONSTANT)))		"" (Binary.getVal1(PL(p)).similar(Binary.getVal1(PR(p))) && (VLRR(p) == 31) && (VRRR(p) == 31) && Binary.getVal1(PRR(p)).similar(Unary.getVal(PLRL(p))) ? 23 : INFINITE)
r:      INT_OR(INT_SHL(r,INT_AND(INT_NEG(r),INT_CONSTANT)),INT_USHR(r,INT_AND(r,INT_CONSTANT)))		"" (Binary.getVal1(PL(p)).similar(Binary.getVal1(PR(p))) && (VLRR(p) == 31) && (VRRR(p) == 31) && Binary.getVal1(PRR(p)).similar(Unary.getVal(PLRL(p))) ? 23 : INFINITE)
r:      INT_OR(INT_USHR(r,INT_AND(r,INT_CONSTANT)),INT_SHL(r,INT_AND(INT_NEG(r),INT_CONSTANT)))		"" (Binary.getVal1(PL(p)).similar(Binary.getVal1(PR(p))) && (VLRR(p) == 31) && (VRRR(p) == 31) && Binary.getVal1(PLR(p)).similar(Unary.getVal(PRRL(p))) ? 23 : INFINITE)
szpr:	INT_SHL(riv, INT_AND(r, INT_CONSTANT))		"" (VRR(p) == 31 ? 23 : INFINITE)
szpr:	INT_SHL(riv, riv)		"" 23
szpr:	INT_SHL(r, INT_CONSTANT)		"" 13
r:	INT_SHL(r, INT_CONSTANT)		"" (!Binary.getResult(P(p)).similar(Binary.getVal1(P(p))) && (Binary.getVal2(P(p)).asIntConstant().value & 0x1f) <= 3 ? 11 : INFINITE)
szpr:	INT_SHL(INT_SHR(r, INT_CONSTANT), INT_CONSTANT)		"" ((VR(p) == VLR(p)) ? 23 : INFINITE)
stm:	INT_STORE(INT_SHL(INT_LOAD(riv,riv),INT_AND(r,INT_CONSTANT)),OTHER_OPERAND(riv, riv))		"" (ADDRESS_EQUAL(P(p), PLL(p), VLRR(p) == 31 ? 27 : INFINITE))
stm:	INT_STORE(INT_SHL(INT_LOAD(riv,riv), INT_CONSTANT),OTHER_OPERAND(riv, riv))		"" ADDRESS_EQUAL(P(p), PLL(p), 17)
stm:	INT_ASTORE(INT_SHL(INT_ALOAD(riv,riv),INT_AND(r, INT_CONSTANT)),OTHER_OPERAND(riv, riv))		"" (ARRAY_ADDRESS_EQUAL(P(p), PLL(p), VLRR(p) == 31 ? 27 : INFINITE))
stm:	INT_ASTORE(INT_SHL(INT_ALOAD(riv,riv), INT_CONSTANT),OTHER_OPERAND(riv, riv))		"" (ARRAY_ADDRESS_EQUAL(P(p), PLL(p), VLR(p) == 31 ? 17 : INFINITE))
szpr:	INT_SHR(riv, INT_AND(r, INT_CONSTANT))		"" (VRR(p) == 31 ? 23 : INFINITE)
szpr:	INT_SHR(riv, riv)		"" 23
szpr:	INT_SHR(riv, INT_CONSTANT)		"" 13
stm:	INT_STORE(INT_SHR(INT_LOAD(riv,riv),INT_AND(r,INT_CONSTANT)),OTHER_OPERAND(riv, riv))		"" (ADDRESS_EQUAL(P(p), PLL(p), VLRR(p) == 31 ? 27 : INFINITE))
stm:	INT_STORE(INT_SHR(INT_LOAD(riv,riv), INT_CONSTANT),OTHER_OPERAND(riv, riv))		"" ADDRESS_EQUAL(P(p), PLL(p), 17)
stm:	INT_ASTORE(INT_SHR(INT_ALOAD(riv,riv),INT_AND(r, INT_CONSTANT)),OTHER_OPERAND(riv, riv))		"" (ARRAY_ADDRESS_EQUAL(P(p), PLL(p), VLRR(p) == 31 ? 27 : INFINITE))
stm:	INT_ASTORE(INT_SHR(INT_ALOAD(riv,riv), INT_CONSTANT),OTHER_OPERAND(riv, riv))		"" (ARRAY_ADDRESS_EQUAL(P(p), PLL(p), VLR(p) == 31 ? 17 : INFINITE))
stm:	INT_STORE(riv, OTHER_OPERAND(rlv, rlv))		"" 15
stm:	INT_STORE(riv, OTHER_OPERAND(rlv, address1scaledreg))		"" 15
stm:	INT_STORE(riv, OTHER_OPERAND(address1scaledreg, rlv))		"" 15
stm:	INT_STORE(riv, OTHER_OPERAND(address1scaledreg, address1reg))		"" 15
stm:	INT_STORE(riv, OTHER_OPERAND(address1reg, address1scaledreg))		"" 15
stm:	INT_STORE(riv, OTHER_OPERAND(address, LONG_CONSTANT))		"" 15
czr:	INT_SUB(riv, r)		"" 13
r:	INT_SUB(riv, r)		"" (Binary.getResult(P(p)).similar(Binary.getVal2(P(p))) ? 13-2 : INFINITE)
r:	INT_SUB(load32, r)		"" (Binary.getResult(P(p)).similar(Binary.getVal2(P(p))) ? 15-2 : INFINITE)
czr:	INT_SUB(riv, load32)		"" 15
czr:	INT_SUB(load32, riv)		"" 15
stm:	INT_STORE(INT_SUB(INT_LOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))		"" ADDRESS_EQUAL(P(p), PLL(p), 17)
stm:	INT_STORE(INT_SUB(riv, INT_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))		"" ADDRESS_EQUAL(P(p), PLR(p), 27)
stm:	INT_ASTORE(INT_SUB(INT_ALOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))		"" ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
stm:	INT_ASTORE(INT_SUB(riv, INT_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))		"" ARRAY_ADDRESS_EQUAL(P(p), PLR(p), 27)
szpr:	INT_USHR(riv, INT_AND(r, INT_CONSTANT))		"" (VRR(p) == 31 ? 23 : INFINITE)
szpr:	INT_USHR(riv, riv)		"" 23
szpr:	INT_USHR(riv, INT_CONSTANT)		"" 13
stm:	INT_STORE(INT_USHR(INT_LOAD(riv,riv),INT_AND(r,INT_CONSTANT)),OTHER_OPERAND(riv, riv))		"" (ADDRESS_EQUAL(P(p), PLL(p), VLRR(p) == 31 ? 27 : INFINITE))
stm:	INT_STORE(INT_USHR(INT_LOAD(riv,riv), INT_CONSTANT),OTHER_OPERAND(riv, riv))		"" ADDRESS_EQUAL(P(p), PLL(p), 17)
stm:	INT_ASTORE(INT_USHR(INT_ALOAD(riv,riv),INT_AND(r, INT_CONSTANT)),OTHER_OPERAND(riv, riv))		"" (ARRAY_ADDRESS_EQUAL(P(p), PLL(p), VLRR(p) == 31 ? 27 : INFINITE))
stm:	INT_ASTORE(INT_USHR(INT_ALOAD(riv,riv), INT_CONSTANT),OTHER_OPERAND(riv, riv))		"" (ARRAY_ADDRESS_EQUAL(P(p), PLL(p), VLR(p) == 31 ? 17 : INFINITE))
szpr:	INT_XOR(r, riv)		"" 13
szpr:	INT_XOR(r, load32)		"" 15
szpr:	INT_XOR(load32, riv)		"" 15
stm:	INT_STORE(INT_XOR(INT_LOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))		"" ADDRESS_EQUAL(P(p), PLL(p), 17)
stm:	INT_STORE(INT_XOR(r,INT_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))		"" ADDRESS_EQUAL(P(p), PLR(p), 17)
stm:	INT_ASTORE(INT_XOR(INT_ALOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))		"" ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
stm:	INT_ASTORE(INT_XOR(r,INT_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))		"" ARRAY_ADDRESS_EQUAL(P(p), PLR(p), 17)
r: LCMP_CMOV(r, OTHER_OPERAND(rlv, any))		"" (13 + 30)
r: LCMP_CMOV(r, OTHER_OPERAND(INT_CONSTANT, any))		"" (VRL(p) == 0 && CMP_TO_TEST(CondMove.getCond(P(p))) ? (11 + 30):INFINITE)
r: LCMP_CMOV(load64, OTHER_OPERAND(rlv, any))		"" (15 + 30)
r: LCMP_CMOV(rlv, OTHER_OPERAND(load64, any))		"" (15 + 30)
r:	LONG_ADD(address1scaledreg, r)		"" 11
r:	LONG_ADD(r, address1scaledreg)		"" 11
r:	LONG_ADD(address1scaledreg, address1reg)		"" 11
r:	LONG_ADD(address1reg, address1scaledreg)		"" 11
r:	LONG_ADD(address, LONG_CONSTANT)		"" 11
r:	LONG_MOVE(address)		"" 20
r:      BYTE_LOAD(rlv, rlv)		"" 20
sload8:	BYTE_LOAD(rlv, rlv)		"" 0
r:      BYTE_ALOAD(rlv, riv)		"" 20
r:      BYTE_ALOAD(rlv, r)		"" 15
sload8:	BYTE_ALOAD(rlv, riv)		"" 0
r:      UBYTE_LOAD(rlv, rlv)		"" 15
uload8:	UBYTE_LOAD(rlv, rlv)		"" 0
r:	UBYTE_ALOAD(rlv, riv)		"" 15
r:      UBYTE_ALOAD(rlv, r)		"" 10
uload8:	UBYTE_ALOAD(rlv, riv)		"" 0
load8:	sload8		"" 0
load8:	uload8		"" 0
r:      SHORT_LOAD(rlv, rlv)		"" 20
sload16: SHORT_LOAD(rlv, rlv)		"" 0
r:      SHORT_ALOAD(rlv, riv)		"" 20
r:      SHORT_ALOAD(rlv, r)		"" 15
sload16: SHORT_ALOAD(rlv, riv)		"" 0
r:      USHORT_LOAD(rlv, rlv)		"" 15
uload16: USHORT_LOAD(rlv, rlv)		"" 0
r:      USHORT_ALOAD(rlv, riv)		"" 15
r:      USHORT_ALOAD(rlv, r)		"" 10
uload16: USHORT_ALOAD(rlv, riv)		"" 0
load16:	sload16		"" 0
load16:	uload16		"" 0
load32:	INT_LOAD(rlv, rlv)		"" 0
load32:	INT_ALOAD(rlv, riv)		"" 0
load16_32:      load16		"" 0
load16_32:      load32		"" 0
load8_16_32:	load16_32		"" 0
load8_16_32:	load8		"" 0
load64:	LONG_LOAD(rlv, rlv)		"" 0
load64:	LONG_ALOAD(rlv, rlv)		"" 0
load64:	LONG_ALOAD(rlv, r)		"" 0
load8_16_32_64:	load64		"" 0
load8_16_32_64:	load8_16_32		"" 0
r:	LONG_2INT(r)		"" 13
stm:	INT_STORE(LONG_2INT(r), OTHER_OPERAND(riv,riv))		"" 15
stm:	INT_ASTORE(LONG_2INT(r), OTHER_OPERAND(riv, riv))		"" 15
r:	LONG_2INT(load64)		"" 15
load32:      LONG_2INT(load64)		"" 0
r:	LONG_2INT(LONG_USHR(r, INT_CONSTANT))		"" (VLR(p) == 32 ? 13 : INFINITE)
r:      LONG_2INT(LONG_SHR(r, INT_CONSTANT))		"" (VLR(p) == 32 ? 13 : INFINITE)
r:      LONG_2INT(LONG_USHR(load64, INT_CONSTANT))		"" (VLR(p) == 32 ? 15 : INFINITE)
r:      LONG_2INT(LONG_SHR(load64, INT_CONSTANT))		"" (VLR(p) == 32 ? 15 : INFINITE)
load32:      LONG_2INT(LONG_USHR(load64, INT_CONSTANT))		"" (VLR(p) == 32 ? 0 : INFINITE)
load32:      LONG_2INT(LONG_SHR(load64, INT_CONSTANT))		"" (VLR(p) == 32 ? 0 : INFINITE)
czr:	LONG_ADD(r, rlv)		"" 11
czr:	LONG_ADD(r, riv)		"" 11
czr:    LONG_ADD(r,r)		"" 9
r:	LONG_ADD(r, rlv)		"" 13
czr:	LONG_ADD(rlv, load64)		"" 15
czr:	LONG_ADD(load64, rlv)		"" 15
stm:	LONG_STORE(LONG_ADD(LONG_LOAD(rlv,rlv),rlv),OTHER_OPERAND(rlv, rlv))		"" ADDRESS_EQUAL(P(p), PLL(p), 17)
stm:	LONG_STORE(LONG_ADD(rlv,LONG_LOAD(rlv,rlv)),OTHER_OPERAND(rlv, rlv))		"" ADDRESS_EQUAL(P(p), PLR(p), 17)
stm:	LONG_ASTORE(LONG_ADD(LONG_ALOAD(rlv,rlv),rlv),OTHER_OPERAND(rlv, rlv))		"" ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
stm:	LONG_ASTORE(LONG_ADD(rlv,LONG_ALOAD(rlv,rlv)),OTHER_OPERAND(rlv, rlv))		"" ARRAY_ADDRESS_EQUAL(P(p), PLR(p), 17)
szpr:	LONG_AND(r, rlv)		"" 13
szpr:    LONG_AND(r,r)		"" 9
szp:	LONG_AND(r, rlv)		"" 11
szpr:	LONG_AND(rlv, load64)		"" 15
szpr:	LONG_AND(load64, rlv)		"" 15
szp:	LONG_AND(load8_16_32_64, rlv)		"" 11
szp:	LONG_AND(r, load8_16_32_64)		"" 11
stm:	LONG_STORE(LONG_AND(LONG_LOAD(rlv,rlv),rlv),OTHER_OPERAND(rlv, rlv))		"" ADDRESS_EQUAL(P(p), PLL(p), 17)
stm:	LONG_STORE(LONG_AND(r,LONG_LOAD(rlv,rlv)),OTHER_OPERAND(rlv, rlv))		"" ADDRESS_EQUAL(P(p), PLR(p), 17)
stm:	LONG_ASTORE(LONG_AND(LONG_ALOAD(rlv,rlv),rlv),OTHER_OPERAND(rlv, rlv))		"" ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
stm:	LONG_ASTORE(LONG_AND(r,LONG_ALOAD(rlv,rlv)),OTHER_OPERAND(rlv, rlv))		"" ARRAY_ADDRESS_EQUAL(P(p), PLR(p), 17)
r:  LONG_DIV(rlv, rlv)		"" 52
r:  LONG_DIV(rlv, riv)		"" 52
r:  LONG_DIV(riv, rlv)		"" 52
r:  LONG_DIV(rlv, load64)		"" 55
r:  LONG_DIV(load64,rlv)		"" 55
stm:	LONG_IFCMP(rlv,rlv)		"" 26
stm:	LONG_IFCMP(r, LONG_CONSTANT)		"" (LV(IfCmp.getVal2(P(p))) == 0 && CMP_TO_TEST(IfCmp.getCond(P(p))) ? 24:INFINITE)
r:	LONG_LOAD(rlv, rlv)		"" 15
r:	LONG_LOAD(rlv, address1scaledreg)		"" 15
r:	LONG_LOAD(address1scaledreg, rlv)		"" 15
r:	LONG_LOAD(address1scaledreg, address1reg)		"" 15
r:	LONG_LOAD(address1reg, address1scaledreg)		"" 15
r:	LONG_LOAD(address, LONG_CONSTANT)		"" 15
r:      LONG_ALOAD(rlv, riv)		"" 30
r:      LONG_ALOAD(rlv, r)		"" 20
r:	LONG_MOVE(rlv)		"" 13
r:  LONG_MOVE(riv)		"" 13
load64:	LONG_MOVE(load64)		"" 0
r:	LONG_MUL(r, rlv)		"" 13
r:	INT_MUL(r, load64)		"" 15
r:	INT_MUL(load64, rlv)		"" 15
szpr:	LONG_NEG(r)		"" 13
stm:	LONG_STORE(LONG_NEG(LONG_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))		"" ADDRESS_EQUAL(P(p), PLL(p), 17)
stm:	LONG_ASTORE(LONG_NEG(LONG_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))		"" ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
r:	LONG_NOT(r)		"" 13
stm:	LONG_STORE(LONG_NOT(LONG_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))		"" ADDRESS_EQUAL(P(p), PLL(p), 17)
stm:	LONG_ASTORE(LONG_NOT(LONG_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))		"" ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
szpr:	LONG_OR(r, rlv)		"" 13
szpr:	LONG_OR(r, load64)		"" 15
szpr:	LONG_OR(load64, rlv)		"" 15
stm:	LONG_STORE(LONG_OR(LONG_LOAD(rlv,rlv),rlv),OTHER_OPERAND(rlv, rlv))		"" ADDRESS_EQUAL(P(p), PLL(p), 17)
stm:	LONG_STORE(LONG_OR(r,LONG_LOAD(rlv,rlv)),OTHER_OPERAND(rlv, rlv))		"" ADDRESS_EQUAL(P(p), PLR(p), 17)
stm:	LONG_ASTORE(LONG_OR(LONG_ALOAD(rlv,rlv),rlv),OTHER_OPERAND(rlv, rlv))		"" ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
stm:	LONG_ASTORE(LONG_OR(r,LONG_ALOAD(rlv,rlv)),OTHER_OPERAND(rlv, rlv))		"" ARRAY_ADDRESS_EQUAL(P(p), PLR(p), 17)
r:  LONG_REM(rlv, rlv)		"" 52
r:  LONG_REM(rlv, riv)		"" 52
r:  LONG_REM(riv, rlv)		"" 52
r:  LONG_REM(rlv, load64)		"" 55
r:  LONG_REM(load64,rlv)		"" 55
szpr:	LONG_SHL(rlv, INT_AND(r, INT_CONSTANT))		"" (VRR(p) == 63 ? 23 : INFINITE)
szpr:	LONG_SHL(rlv, riv)		"" 23
szpr:	LONG_SHL(r, INT_CONSTANT)		"" 13
r:	LONG_SHL(r, INT_CONSTANT)		"" (!Binary.getResult(P(p)).similar(Binary.getVal1(P(p))) && (Binary.getVal2(P(p)).asIntConstant().value & 0x3f) <= 3 ? 11 : INFINITE)
szpr:	LONG_SHL(LONG_SHR(r, INT_CONSTANT), INT_CONSTANT)		"" (((VR(p) == VLR(p)) && (VR(p) < 32)) ? 23 : INFINITE)
stm:	LONG_STORE(LONG_SHL(LONG_LOAD(riv,riv),INT_AND(r,INT_CONSTANT)),OTHER_OPERAND(riv, riv))		"" (ADDRESS_EQUAL(P(p), PLL(p), VLRR(p) == 63 ? 27 : INFINITE))
stm:	LONG_STORE(LONG_SHL(LONG_LOAD(riv,riv), INT_CONSTANT),OTHER_OPERAND(riv, riv))		"" ADDRESS_EQUAL(P(p), PLL(p), 17)
stm:	LONG_ASTORE(LONG_SHL(LONG_ALOAD(riv,riv),INT_AND(r, INT_CONSTANT)),OTHER_OPERAND(riv, riv))		"" (ARRAY_ADDRESS_EQUAL(P(p), PLL(p), VLRR(p) == 63 ? 27 : INFINITE))
stm:	LONG_ASTORE(LONG_SHL(LONG_ALOAD(riv,riv), INT_CONSTANT),OTHER_OPERAND(riv, riv))		"" (ARRAY_ADDRESS_EQUAL(P(p), PLL(p), VLR(p) == 63 ? 17 : INFINITE))
szpr:	LONG_SHR(rlv, INT_AND(r, LONG_CONSTANT))		"" (VRR(p) == 63 ? 23 : INFINITE)
szpr:	LONG_SHR(rlv, riv)		"" 23
szpr:	LONG_SHR(rlv, LONG_CONSTANT)		"" 13
stm:	LONG_STORE(LONG_SHR(LONG_LOAD(riv,riv),INT_AND(r,LONG_CONSTANT)),OTHER_OPERAND(riv, riv))		"" (ADDRESS_EQUAL(P(p), PLL(p), VLRR(p) == 63 ? 27 : INFINITE))
stm:	LONG_STORE(LONG_SHR(LONG_LOAD(riv,riv), LONG_CONSTANT),OTHER_OPERAND(riv, riv))		"" ADDRESS_EQUAL(P(p), PLL(p), 17)
stm:	LONG_ASTORE(LONG_SHR(LONG_ALOAD(riv,riv),INT_AND(r, LONG_CONSTANT)),OTHER_OPERAND(riv, riv))		"" (ARRAY_ADDRESS_EQUAL(P(p), PLL(p), VLRR(p) == 63 ? 27 : INFINITE))
stm:	LONG_ASTORE(LONG_SHR(LONG_ALOAD(riv,riv), LONG_CONSTANT),OTHER_OPERAND(riv, riv))		"" (ARRAY_ADDRESS_EQUAL(P(p), PLL(p), VLR(p) == 63 ? 17 : INFINITE))
stm:	LONG_STORE(rlv, OTHER_OPERAND(rlv, rlv))		"" 15
stm:	LONG_STORE(rlv, OTHER_OPERAND(rlv, address1scaledreg))		"" 15
stm:	LONG_STORE(rlv, OTHER_OPERAND(address1scaledreg, rlv))		"" 15
stm:	LONG_STORE(rlv, OTHER_OPERAND(address1scaledreg, address1reg))		"" 15
stm:	LONG_STORE(rlv, OTHER_OPERAND(address1reg, address1scaledreg))		"" 15
stm:	LONG_STORE(rlv, OTHER_OPERAND(address, LONG_CONSTANT))		"" 15
czr:	LONG_SUB(rlv, r)		"" 13
r:	LONG_SUB(rlv, r)		"" (Binary.getResult(P(p)).similar(Binary.getVal2(P(p))) ? 13-2 : INFINITE)
r:	LONG_SUB(load64, r)		"" (Binary.getResult(P(p)).similar(Binary.getVal2(P(p))) ? 15-2 : INFINITE)
czr:	LONG_SUB(rlv, load64)		"" 15
czr:	LONG_SUB(load64, rlv)		"" 15
stm:	LONG_STORE(LONG_SUB(LONG_LOAD(rlv,rlv),rlv),OTHER_OPERAND(rlv, rlv))		"" ADDRESS_EQUAL(P(p), PLL(p), 17)
stm:	LONG_STORE(LONG_SUB(rlv, LONG_LOAD(rlv,rlv)),OTHER_OPERAND(rlv, rlv))		"" ADDRESS_EQUAL(P(p), PLR(p), 27)
stm:	LONG_ASTORE(LONG_SUB(LONG_ALOAD(rlv,rlv),rlv),OTHER_OPERAND(rlv, rlv))		"" ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
stm:	LONG_ASTORE(LONG_SUB(rlv, LONG_ALOAD(rlv,rlv)),OTHER_OPERAND(rlv, rlv))		"" ARRAY_ADDRESS_EQUAL(P(p), PLR(p), 27)
szpr:	LONG_USHR(rlv, LONG_AND(r, LONG_CONSTANT))		"" (VRR(p) == 63 ? 23 : INFINITE)
szpr:	LONG_USHR(rlv, riv)		"" 23
szpr:	LONG_USHR(rlv, LONG_CONSTANT)		"" 13
stm:	LONG_STORE(LONG_USHR(LONG_LOAD(riv,riv),LONG_AND(r,LONG_CONSTANT)),OTHER_OPERAND(riv, riv))		"" (ADDRESS_EQUAL(P(p), PLL(p), VLRR(p) == 63 ? 27 : INFINITE))
stm:	LONG_STORE(LONG_USHR(LONG_LOAD(riv,riv), LONG_CONSTANT),OTHER_OPERAND(riv, riv))		"" ADDRESS_EQUAL(P(p), PLL(p), 17)
stm:	LONG_ASTORE(LONG_USHR(LONG_ALOAD(riv,riv),LONG_AND(r, LONG_CONSTANT)),OTHER_OPERAND(riv, riv))		"" (ARRAY_ADDRESS_EQUAL(P(p), PLL(p), VLRR(p) == 63 ? 27 : INFINITE))
stm:	LONG_ASTORE(LONG_USHR(LONG_ALOAD(riv,riv), LONG_CONSTANT),OTHER_OPERAND(riv, riv))		"" (ARRAY_ADDRESS_EQUAL(P(p), PLL(p), VLR(p) == 63 ? 17 : INFINITE))
szpr:	LONG_XOR(r, rlv)		"" 13
szpr:	LONG_XOR(r, load64)		"" 15
szpr:	LONG_XOR(load64, rlv)		"" 15
stm:	LONG_STORE(LONG_XOR(LONG_LOAD(rlv,rlv),rlv),OTHER_OPERAND(rlv, rlv))		"" ADDRESS_EQUAL(P(p), PLL(p), 17)
stm:	LONG_STORE(LONG_XOR(r,LONG_LOAD(rlv,rlv)),OTHER_OPERAND(rlv, rlv))		"" ADDRESS_EQUAL(P(p), PLR(p), 17)
stm:	LONG_ASTORE(LONG_XOR(LONG_ALOAD(rlv,rlv),rlv),OTHER_OPERAND(rlv, rlv))		"" ARRAY_ADDRESS_EQUAL(P(p), PLL(p), 17)
stm:	LONG_ASTORE(LONG_XOR(r,LONG_ALOAD(rlv,rlv)),OTHER_OPERAND(rlv, rlv))		"" ARRAY_ADDRESS_EQUAL(P(p), PLR(p), 17)
r: FLOAT_ADD(r, r)		"" 13
r: FLOAT_ADD(r, float_load)		"" 15
r: FLOAT_ADD(float_load,r)		"" 15
r: DOUBLE_ADD(r, r)		"" 13
r: DOUBLE_ADD(r, double_load)		"" 15
r: DOUBLE_ADD(double_load,r)		"" 15
r: FLOAT_SUB(r, r)		"" 13
r: FLOAT_SUB(r, float_load)		"" 15
r: DOUBLE_SUB(r, r)		"" 13
r: DOUBLE_SUB(r, double_load)		"" 15
r: FLOAT_MUL(r, r)		"" 13
r: FLOAT_MUL(r, float_load)		"" 15
r: FLOAT_MUL(float_load, r)		"" 15
r: DOUBLE_MUL(r, r)		"" 13
r: DOUBLE_MUL(r, double_load)		"" 15
r: DOUBLE_MUL(double_load, r)		"" 15
r: FLOAT_DIV(r, r)		"" 13
r: FLOAT_DIV(r, float_load)		"" 15
r: DOUBLE_DIV(r, r)		"" 13
r: DOUBLE_DIV(r, double_load)		"" 15
r: FLOAT_NEG(r)		"" 26
r: DOUBLE_NEG(r)		"" 26
r: FLOAT_SQRT(r)		"" 13
r: DOUBLE_SQRT(r)		"" 13
r: FLOAT_REM(r, r)		"" 13
r: DOUBLE_REM(r, r)		"" 13
r: LONG_2FLOAT(r)		"" 13
r: LONG_2DOUBLE(r)		"" 13
r: FLOAT_MOVE(r)		"" 13
r: DOUBLE_MOVE(r)		"" 13
r: DOUBLE_LOAD(riv, riv)		"" 15
r: DOUBLE_LOAD(riv, rlv)		"" 15
r: DOUBLE_LOAD(rlv, rlv)		"" 15
double_load: DOUBLE_LOAD(riv, riv)		"" 0
r: DOUBLE_ALOAD(riv, riv)		"" 15
r: DOUBLE_ALOAD(rlv, riv)		"" 15
double_load: DOUBLE_LOAD(rlv, rlv)		"" 0
r: DOUBLE_ALOAD(riv, r)		"" 10
r: DOUBLE_ALOAD(rlv, rlv)		"" 10
double_load: DOUBLE_ALOAD(rlv, riv)		"" 0
double_load: DOUBLE_ALOAD(riv, riv)		"" 0
r: FLOAT_LOAD(riv, riv)		"" 15
r: FLOAT_LOAD(rlv, rlv)		"" 15
float_load: FLOAT_LOAD(riv, riv)		"" 0
float_load: FLOAT_ALOAD(rlv, riv)		"" 0
r: FLOAT_ALOAD(riv, riv)		"" 15
r: FLOAT_ALOAD(rlv, riv)		"" 15
r: FLOAT_ALOAD(riv, r)		"" 10
r: FLOAT_ALOAD(rlv, rlv)		"" 15
float_load: FLOAT_ALOAD(riv, riv)		"" 0
stm: DOUBLE_STORE(r, OTHER_OPERAND(riv, riv))		"" 17
stm: DOUBLE_STORE(r, OTHER_OPERAND(riv, rlv))		"" 17
stm: DOUBLE_STORE(r, OTHER_OPERAND(rlv, riv))		"" 17
stm: DOUBLE_STORE(r, OTHER_OPERAND(rlv, rlv))		"" 17
stm: DOUBLE_ASTORE(r, OTHER_OPERAND(riv, riv))		"" 17
stm: DOUBLE_ASTORE(r, OTHER_OPERAND(rlv, riv))		"" 17
stm: DOUBLE_ASTORE(r, OTHER_OPERAND(riv, rlv))		"" 17
stm: DOUBLE_ASTORE(r, OTHER_OPERAND(rlv, rlv))		"" 17
stm: DOUBLE_ASTORE(r, OTHER_OPERAND(r, r))		"" 12
stm: FLOAT_STORE(r, OTHER_OPERAND(riv, riv))		"" 17
stm: FLOAT_STORE(r, OTHER_OPERAND(rlv, rlv))		"" 17
stm: FLOAT_STORE(r, OTHER_OPERAND(rlv, riv))		"" 17
stm: FLOAT_STORE(r, OTHER_OPERAND(riv, rlv))		"" 17
stm: FLOAT_ASTORE(r, OTHER_OPERAND(riv, riv))		"" 17
stm: FLOAT_ASTORE(r, OTHER_OPERAND(rlv, riv))		"" 17
stm: FLOAT_ASTORE(r, OTHER_OPERAND(riv, rlv))		"" 17
stm: FLOAT_ASTORE(r, OTHER_OPERAND(rlv, rlv))		"" 17
stm: FLOAT_ASTORE(r, OTHER_OPERAND(r, r))		"" 12
r: INT_2FLOAT(riv)		"" 13
r: INT_2FLOAT(load32)		"" 15
r: INT_2DOUBLE(riv)		"" 13
r: INT_2DOUBLE(load32)		"" 15
r: FLOAT_2DOUBLE(r)		"" 13
r: FLOAT_2DOUBLE(float_load)		"" 15
r: DOUBLE_2FLOAT(r)		"" 13
r: DOUBLE_2FLOAT(double_load)		"" 15
r: FLOAT_2INT(r)		"" 13
r: FLOAT_2LONG(r)		"" 13
r: DOUBLE_2INT(r)		"" 13
r: DOUBLE_2LONG(r)		"" 13
r: FLOAT_AS_INT_BITS(r)		"" 13
load32: FLOAT_AS_INT_BITS(float_load)		"" 0
r: DOUBLE_AS_LONG_BITS(r)		"" 13
load64: DOUBLE_AS_LONG_BITS(double_load)		"" 0
r: INT_BITS_AS_FLOAT(riv)		"" 13
float_load: INT_BITS_AS_FLOAT(load32)		"" 0
r: LONG_BITS_AS_DOUBLE(rlv)		"" 13
double_load: LONG_BITS_AS_DOUBLE(load64)		"" 0
r: MATERIALIZE_FP_CONSTANT(any)		"" 15
float_load: MATERIALIZE_FP_CONSTANT(any)		"" (Binary.getResult(P(p)).isFloat() ? 0 : INFINITE)
double_load: MATERIALIZE_FP_CONSTANT(any)		"" (Binary.getResult(P(p)).isDouble() ? 0 : INFINITE)
stm: CLEAR_FLOATING_POINT_STATE		"" 0
stm: FLOAT_IFCMP(r,r)		"" 13
stm: FLOAT_IFCMP(r,float_load)		"" 15
stm: FLOAT_IFCMP(float_load,r)		"" 15
stm: DOUBLE_IFCMP(r,r)		"" 13
stm: DOUBLE_IFCMP(r,double_load)		"" 15
stm: DOUBLE_IFCMP(double_load,r)		"" 15
r: FCMP_CMOV(r, OTHER_OPERAND(r, any))		"" 13*2
r: FCMP_CMOV(r, OTHER_OPERAND(float_load, any))		"" 13+15
r: FCMP_CMOV(r, OTHER_OPERAND(double_load, any))		"" 13+15
r: FCMP_CMOV(float_load, OTHER_OPERAND(r, any))		"" 13+15
r: FCMP_CMOV(double_load, OTHER_OPERAND(r, any))		"" 13+15
r: FCMP_FCMOV(r, OTHER_OPERAND(r, any))		"" 13*4
r: FCMP_FCMOV(r, OTHER_OPERAND(r, OTHER_OPERAND(r, float_load)))		"" 15+13*3
r: FCMP_FCMOV(r, OTHER_OPERAND(r, OTHER_OPERAND(r, double_load)))		"" 15+13*3
r: FCMP_FCMOV(r, OTHER_OPERAND(r, OTHER_OPERAND(float_load, r)))		"" 15+13*3
r: FCMP_FCMOV(r, OTHER_OPERAND(r, OTHER_OPERAND(double_load, r)))		"" 15+13*3
r: FCMP_FCMOV(r, OTHER_OPERAND(float_load, any))		"" (SSE2_CMP_OP(CondMove.getCond(P(p)), true) != null ? 15+13*3 : INFINITE)
r: FCMP_FCMOV(r, OTHER_OPERAND(double_load, any))		"" (SSE2_CMP_OP(CondMove.getCond(P(p)), false) != null ? 15+13*3 : INFINITE)
r: FCMP_FCMOV(r, OTHER_OPERAND(MATERIALIZE_FP_CONSTANT(INT_CONSTANT), OTHER_OPERAND(r, FLOAT_NEG(r))))		"" (IS_MATERIALIZE_ZERO(PRL(p)) && SSE2_IS_GT_OR_GE(CondMove.getCond(P(p))) && SIMILAR_REGISTERS(CondMove.getVal1(P(p)), CondMove.getTrueValue(P(p)), Unary.getVal(PRRR(p))) ? 11 : INFINITE )
r: FCMP_FCMOV(r, OTHER_OPERAND(MATERIALIZE_FP_CONSTANT(LONG_CONSTANT), OTHER_OPERAND(r, FLOAT_NEG(r))))		"" (IS_MATERIALIZE_ZERO(PRL(p)) && SSE2_IS_GT_OR_GE(CondMove.getCond(P(p))) && SIMILAR_REGISTERS(CondMove.getVal1(P(p)), CondMove.getTrueValue(P(p)), Unary.getVal(PRRR(p))) ? 11 : INFINITE )
r: FCMP_FCMOV(r, OTHER_OPERAND(MATERIALIZE_FP_CONSTANT(INT_CONSTANT), OTHER_OPERAND(FLOAT_NEG(r), r)))		"" (IS_MATERIALIZE_ZERO(PRL(p)) && SSE2_IS_LT_OR_LE(CondMove.getCond(P(p))) && SIMILAR_REGISTERS(CondMove.getVal1(P(p)), CondMove.getClearFalseValue(P(p)), Unary.getVal(PRRL(p))) ? 11 : INFINITE )
r: FCMP_FCMOV(r, OTHER_OPERAND(MATERIALIZE_FP_CONSTANT(LONG_CONSTANT), OTHER_OPERAND(FLOAT_NEG(r), r)))		"" (IS_MATERIALIZE_ZERO(PRL(p)) && SSE2_IS_LT_OR_LE(CondMove.getCond(P(p))) && SIMILAR_REGISTERS(CondMove.getVal1(P(p)), CondMove.getClearFalseValue(P(p)), Unary.getVal(PRRL(p))) ? 11 : INFINITE )
r: FCMP_FCMOV(MATERIALIZE_FP_CONSTANT(INT_CONSTANT), OTHER_OPERAND(r, OTHER_OPERAND(FLOAT_NEG(r), r)))		"" (IS_MATERIALIZE_ZERO(PRL(p)) && SSE2_IS_GT_OR_GE(CondMove.getCond(P(p))) && SIMILAR_REGISTERS(CondMove.getVal2(P(p)), CondMove.getClearFalseValue(P(p)), Unary.getVal(PRRL(p))) ? 11 : INFINITE )
r: FCMP_FCMOV(MATERIALIZE_FP_CONSTANT(LONG_CONSTANT), OTHER_OPERAND(r, OTHER_OPERAND(FLOAT_NEG(r), r)))		"" (IS_MATERIALIZE_ZERO(PRL(p)) && SSE2_IS_GT_OR_GE(CondMove.getCond(P(p))) && SIMILAR_REGISTERS(CondMove.getVal2(P(p)), CondMove.getClearFalseValue(P(p)), Unary.getVal(PRRL(p))) ? 11 : INFINITE )
r: FCMP_FCMOV(MATERIALIZE_FP_CONSTANT(INT_CONSTANT), OTHER_OPERAND(r, OTHER_OPERAND(r, FLOAT_NEG(r))))		"" (IS_MATERIALIZE_ZERO(PRL(p)) && SSE2_IS_LT_OR_LE(CondMove.getCond(P(p))) && SIMILAR_REGISTERS(CondMove.getVal2(P(p)), CondMove.getTrueValue(P(p)), Unary.getVal(PRRR(p))) ? 11 : INFINITE )
r: FCMP_FCMOV(MATERIALIZE_FP_CONSTANT(LONG_CONSTANT), OTHER_OPERAND(r, OTHER_OPERAND(r, FLOAT_NEG(r))))		"" (IS_MATERIALIZE_ZERO(PRL(p)) && SSE2_IS_LT_OR_LE(CondMove.getCond(P(p))) && SIMILAR_REGISTERS(CondMove.getVal2(P(p)), CondMove.getTrueValue(P(p)), Unary.getVal(PRRR(p))) ? 11 : INFINITE )
r: FCMP_FCMOV(r, OTHER_OPERAND(MATERIALIZE_FP_CONSTANT(INT_CONSTANT), OTHER_OPERAND(r, DOUBLE_NEG(r))))		"" (IS_MATERIALIZE_ZERO(PRL(p)) && SSE2_IS_GT_OR_GE(CondMove.getCond(P(p))) && SIMILAR_REGISTERS(CondMove.getVal1(P(p)), CondMove.getTrueValue(P(p)), Unary.getVal(PRRR(p))) ? 11 : INFINITE )
r: FCMP_FCMOV(r, OTHER_OPERAND(MATERIALIZE_FP_CONSTANT(LONG_CONSTANT), OTHER_OPERAND(r, DOUBLE_NEG(r))))		"" (IS_MATERIALIZE_ZERO(PRL(p)) && SSE2_IS_GT_OR_GE(CondMove.getCond(P(p))) && SIMILAR_REGISTERS(CondMove.getVal1(P(p)), CondMove.getTrueValue(P(p)), Unary.getVal(PRRR(p))) ? 11 : INFINITE )
r: FCMP_FCMOV(r, OTHER_OPERAND(MATERIALIZE_FP_CONSTANT(INT_CONSTANT), OTHER_OPERAND(DOUBLE_NEG(r), r)))		"" (IS_MATERIALIZE_ZERO(PRL(p)) && SSE2_IS_LT_OR_LE(CondMove.getCond(P(p))) && SIMILAR_REGISTERS(CondMove.getVal1(P(p)), CondMove.getClearFalseValue(P(p)), Unary.getVal(PRRL(p))) ? 11 : INFINITE )
r: FCMP_FCMOV(r, OTHER_OPERAND(MATERIALIZE_FP_CONSTANT(LONG_CONSTANT), OTHER_OPERAND(DOUBLE_NEG(r), r)))		"" (IS_MATERIALIZE_ZERO(PRL(p)) && SSE2_IS_LT_OR_LE(CondMove.getCond(P(p))) && SIMILAR_REGISTERS(CondMove.getVal1(P(p)), CondMove.getClearFalseValue(P(p)), Unary.getVal(PRRL(p))) ? 11 : INFINITE )
r: FCMP_FCMOV(MATERIALIZE_FP_CONSTANT(INT_CONSTANT), OTHER_OPERAND(r, OTHER_OPERAND(DOUBLE_NEG(r), r)))		"" (IS_MATERIALIZE_ZERO(PRL(p)) && SSE2_IS_GT_OR_GE(CondMove.getCond(P(p))) && SIMILAR_REGISTERS(CondMove.getVal2(P(p)), CondMove.getClearFalseValue(P(p)), Unary.getVal(PRRL(p))) ? 11 : INFINITE )
r: FCMP_FCMOV(MATERIALIZE_FP_CONSTANT(LONG_CONSTANT), OTHER_OPERAND(r, OTHER_OPERAND(DOUBLE_NEG(r), r)))		"" (IS_MATERIALIZE_ZERO(PRL(p)) && SSE2_IS_GT_OR_GE(CondMove.getCond(P(p))) && SIMILAR_REGISTERS(CondMove.getVal2(P(p)), CondMove.getClearFalseValue(P(p)), Unary.getVal(PRRL(p))) ? 11 : INFINITE )
r: FCMP_FCMOV(MATERIALIZE_FP_CONSTANT(INT_CONSTANT), OTHER_OPERAND(r, OTHER_OPERAND(r, DOUBLE_NEG(r))))		"" (IS_MATERIALIZE_ZERO(PRL(p)) && SSE2_IS_LT_OR_LE(CondMove.getCond(P(p))) && SIMILAR_REGISTERS(CondMove.getVal2(P(p)), CondMove.getTrueValue(P(p)), Unary.getVal(PRRR(p))) ? 11 : INFINITE )
r: FCMP_FCMOV(MATERIALIZE_FP_CONSTANT(LONG_CONSTANT), OTHER_OPERAND(r, OTHER_OPERAND(r, DOUBLE_NEG(r))))		"" (IS_MATERIALIZE_ZERO(PRL(p)) && SSE2_IS_LT_OR_LE(CondMove.getCond(P(p))) && SIMILAR_REGISTERS(CondMove.getVal2(P(p)), CondMove.getTrueValue(P(p)), Unary.getVal(PRRR(p))) ? 11 : INFINITE )
stm: LONG_ASTORE(load64, OTHER_OPERAND(riv, riv))		"" 32
stm: LONG_ASTORE(load64, OTHER_OPERAND(rlv, riv))		"" 32
stm: LONG_STORE(load64, OTHER_OPERAND(riv, riv))		"" 32
stm: LONG_STORE(load64, OTHER_OPERAND(rlv, riv))		"" 32
%%
  /**
   * For each BURS rule (the number of which provides the index) give its flags byte
   */
  private static final byte[] action={
    0,
    NOFLAGS, // 1 - stm:	r
    NOFLAGS, // 2 - r:	REGISTER
    NOFLAGS, // 3 - r:	czr
    NOFLAGS, // 4 - cz:	czr
    NOFLAGS, // 5 - r:	szpr
    NOFLAGS, // 6 - szp:	szpr
    NOFLAGS, // 7 - riv:	r
    NOFLAGS, // 8 - riv:	INT_CONSTANT
    NOFLAGS, // 9 - rlv:	r
    NOFLAGS, // 10 - rlv:	LONG_CONSTANT
    NOFLAGS, // 11 - any:	NULL
    NOFLAGS, // 12 - any:	riv
    NOFLAGS, // 13 - any:	ADDRESS_CONSTANT
    NOFLAGS, // 14 - any:	LONG_CONSTANT
    NOFLAGS, // 15 - any:	OTHER_OPERAND(any, any)
    EMIT_INSTRUCTION, // 16 - stm:	IG_PATCH_POINT
    EMIT_INSTRUCTION, // 17 - stm:	UNINT_BEGIN
    EMIT_INSTRUCTION, // 18 - stm:	UNINT_END
    EMIT_INSTRUCTION, // 19 - stm:	YIELDPOINT_PROLOGUE
    EMIT_INSTRUCTION, // 20 - stm:	YIELDPOINT_EPILOGUE
    EMIT_INSTRUCTION, // 21 - stm:	YIELDPOINT_BACKEDGE
    EMIT_INSTRUCTION, // 22 - r: FRAMESIZE
    EMIT_INSTRUCTION, // 23 - stm:	LOWTABLESWITCH(r)
    EMIT_INSTRUCTION, // 24 - stm:	RESOLVE
    NOFLAGS, // 25 - stm:	NOP
    EMIT_INSTRUCTION, // 26 - r:	GUARD_MOVE
    EMIT_INSTRUCTION, // 27 - r:	GUARD_COMBINE
    EMIT_INSTRUCTION, // 28 - stm:	NULL_CHECK(riv)
    EMIT_INSTRUCTION, // 29 - stm:	IR_PROLOGUE
    EMIT_INSTRUCTION, // 30 - r:	GET_CAUGHT_EXCEPTION
    EMIT_INSTRUCTION, // 31 - stm:	SET_CAUGHT_EXCEPTION(r)
    EMIT_INSTRUCTION, // 32 - stm: SET_CAUGHT_EXCEPTION(INT_CONSTANT)
    EMIT_INSTRUCTION, // 33 - stm: SET_CAUGHT_EXCEPTION(LONG_CONSTANT)
    EMIT_INSTRUCTION, // 34 - stm:	TRAP
    EMIT_INSTRUCTION, // 35 - stm:	TRAP_IF(r, INT_CONSTANT)
    EMIT_INSTRUCTION, // 36 - stm:	TRAP_IF(r, LONG_CONSTANT)
    EMIT_INSTRUCTION, // 37 - stm:	TRAP_IF(r, r)
    EMIT_INSTRUCTION, // 38 - stm:	TRAP_IF(load32, riv)
    EMIT_INSTRUCTION, // 39 - stm:	TRAP_IF(riv, load32)
    EMIT_INSTRUCTION, // 40 - uload8:	INT_AND(load8_16_32, INT_CONSTANT)
    EMIT_INSTRUCTION, // 41 - r:	INT_AND(load8_16_32, INT_CONSTANT)
    EMIT_INSTRUCTION, // 42 - r:	INT_2BYTE(load8_16_32)
    EMIT_INSTRUCTION, // 43 - r:	INT_USHR(INT_SHL(load8_16_32, INT_CONSTANT), INT_CONSTANT)
    EMIT_INSTRUCTION, // 44 - r:	INT_AND(load16_32, INT_CONSTANT)
    EMIT_INSTRUCTION, // 45 - r:	INT_USHR(INT_SHL(load16_32, INT_CONSTANT), INT_CONSTANT)
    EMIT_INSTRUCTION, // 46 - stm:	SHORT_STORE(riv, OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 47 - stm:	SHORT_STORE(load16, OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 48 - stm:    SHORT_STORE(rlv, OTHER_OPERAND(rlv, rlv))
    EMIT_INSTRUCTION, // 49 - stm:    SHORT_STORE(riv, OTHER_OPERAND(rlv, rlv))
    EMIT_INSTRUCTION, // 50 - stm:	SHORT_ASTORE(riv, OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 51 - stm:	SHORT_ASTORE(load16, OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 52 - stm:	SHORT_ASTORE(riv, OTHER_OPERAND(r, r))
    EMIT_INSTRUCTION, // 53 - stm:	INT_ASTORE(riv, OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 54 - stm:	INT_ASTORE(riv, OTHER_OPERAND(r, r))
    EMIT_INSTRUCTION, // 55 - stm:	INT_ASTORE(riv, OTHER_OPERAND(rlv, rlv))
    EMIT_INSTRUCTION, // 56 - stm:	INT_ASTORE(riv, OTHER_OPERAND(rlv, riv))
    EMIT_INSTRUCTION, // 57 - stm:	INT_ASTORE(riv, OTHER_OPERAND(riv, rlv))
    EMIT_INSTRUCTION, // 58 - stm:	LONG_ASTORE(r, OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 59 - stm:	LONG_ASTORE(r, OTHER_OPERAND(rlv, rlv))
    EMIT_INSTRUCTION, // 60 - stm:	LONG_ASTORE(r, OTHER_OPERAND(r, r))
    EMIT_INSTRUCTION, // 61 - stm:	LONG_ASTORE(LONG_CONSTANT, OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 62 - stm:	LONG_ASTORE(LONG_CONSTANT, OTHER_OPERAND(rlv, riv))
    EMIT_INSTRUCTION, // 63 - r:	LONG_CMP(rlv,rlv)
    EMIT_INSTRUCTION, // 64 - stm:	GOTO
    EMIT_INSTRUCTION, // 65 - stm:	PREFETCH(r)
    EMIT_INSTRUCTION, // 66 - stm:	WRITE_FLOOR
    EMIT_INSTRUCTION, // 67 - stm:	READ_CEILING
    EMIT_INSTRUCTION, // 68 - stm:	FENCE
    EMIT_INSTRUCTION, // 69 - stm:	PAUSE
    EMIT_INSTRUCTION, // 70 - stm:	ILLEGAL_INSTRUCTION
    EMIT_INSTRUCTION, // 71 - stm:	RETURN(NULL)
    EMIT_INSTRUCTION, // 72 - stm:	RETURN(INT_CONSTANT)
    EMIT_INSTRUCTION, // 73 - stm:	RETURN(r)
    EMIT_INSTRUCTION, // 74 - stm:	RETURN(LONG_CONSTANT)
    EMIT_INSTRUCTION, // 75 - r:	CALL(r, any)
    EMIT_INSTRUCTION, // 76 - r:	CALL(BRANCH_TARGET, any)
    EMIT_INSTRUCTION, // 77 - r:	CALL(INT_LOAD(riv, riv), any)
    EMIT_INSTRUCTION, // 78 - r:	CALL(INT_CONSTANT, any)
    EMIT_INSTRUCTION, // 79 - r:	CALL(LONG_LOAD(rlv, rlv), any)
    EMIT_INSTRUCTION, // 80 - r:	SYSCALL(r, any)
    EMIT_INSTRUCTION, // 81 - r:	SYSCALL(INT_LOAD(riv, riv), any)
    EMIT_INSTRUCTION, // 82 - r:	SYSCALL(INT_CONSTANT, any)
    EMIT_INSTRUCTION, // 83 - r:      GET_TIME_BASE
    EMIT_INSTRUCTION, // 84 - stm:	YIELDPOINT_OSR(any, any)
    NOFLAGS, // 85 - address1scaledreg:	address1reg
    NOFLAGS, // 86 - address:	address1scaledreg
    EMIT_INSTRUCTION, // 87 - address1scaledreg:	INT_SHL(r, INT_CONSTANT)
    EMIT_INSTRUCTION, // 88 - address1reg:	INT_ADD(r, LONG_CONSTANT)
    EMIT_INSTRUCTION, // 89 - address1reg:	INT_MOVE(r)
    EMIT_INSTRUCTION, // 90 - address:	INT_ADD(r, r)
    EMIT_INSTRUCTION, // 91 - address1reg:	INT_ADD(address1reg, LONG_CONSTANT)
    EMIT_INSTRUCTION, // 92 - address1scaledreg:	INT_ADD(address1scaledreg, LONG_CONSTANT)
    EMIT_INSTRUCTION, // 93 - address:	INT_ADD(r, address1scaledreg)
    EMIT_INSTRUCTION, // 94 - address:	INT_ADD(address1scaledreg, r)
    EMIT_INSTRUCTION, // 95 - address:	INT_ADD(address1scaledreg, LONG_CONSTANT)
    EMIT_INSTRUCTION, // 96 - address:	INT_ADD(address1scaledreg, address1reg)
    EMIT_INSTRUCTION, // 97 - address:	INT_ADD(address1reg, address1scaledreg)
    EMIT_INSTRUCTION, // 98 - address1scaledreg:	LONG_SHL(r, INT_CONSTANT)
    EMIT_INSTRUCTION, // 99 - address1reg:	LONG_ADD(r, LONG_CONSTANT)
    EMIT_INSTRUCTION, // 100 - address1reg:	LONG_MOVE(r)
    EMIT_INSTRUCTION, // 101 - address:	LONG_ADD(r, r)
    EMIT_INSTRUCTION, // 102 - address1reg:	LONG_ADD(address1reg, LONG_CONSTANT)
    EMIT_INSTRUCTION, // 103 - address1scaledreg:	LONG_ADD(address1scaledreg, LONG_CONSTANT)
    EMIT_INSTRUCTION, // 104 - address:	LONG_ADD(r, address1scaledreg)
    EMIT_INSTRUCTION, // 105 - address:	LONG_ADD(address1scaledreg, r)
    EMIT_INSTRUCTION, // 106 - address:	LONG_ADD(address1scaledreg, LONG_CONSTANT)
    EMIT_INSTRUCTION, // 107 - address:	LONG_ADD(address1scaledreg, address1reg)
    EMIT_INSTRUCTION, // 108 - address:	LONG_ADD(address1reg, address1scaledreg)
    EMIT_INSTRUCTION, // 109 - r:	ATTEMPT_INT(riv, OTHER_OPERAND(riv, OTHER_OPERAND(riv, riv)))
    EMIT_INSTRUCTION, // 110 - r:	ATTEMPT_INT(riv, OTHER_OPERAND(rlv, OTHER_OPERAND(riv, riv)))
    EMIT_INSTRUCTION, // 111 - r:	ATTEMPT_INT(rlv, OTHER_OPERAND(rlv, OTHER_OPERAND(riv, riv)))
    EMIT_INSTRUCTION, // 112 - r:	ATTEMPT_INT(r, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv, riv)))
    EMIT_INSTRUCTION, // 113 - r:	ATTEMPT_INT(address1scaledreg, OTHER_OPERAND(r, OTHER_OPERAND(riv, riv)))
    EMIT_INSTRUCTION, // 114 - r:	ATTEMPT_INT(address1scaledreg, OTHER_OPERAND(address1reg, OTHER_OPERAND(riv, riv)))
    EMIT_INSTRUCTION, // 115 - r:	ATTEMPT_INT(address1reg, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv, riv)))
    EMIT_INSTRUCTION, // 116 - r:	ATTEMPT_INT(address, OTHER_OPERAND(INT_CONSTANT, OTHER_OPERAND(riv, riv)))
    EMIT_INSTRUCTION, // 117 - r:	ATTEMPT_INT(INT_CONSTANT, OTHER_OPERAND(address, OTHER_OPERAND(riv, riv)))
    EMIT_INSTRUCTION, // 118 - stm:	INT_IFCMP(ATTEMPT_INT(riv, OTHER_OPERAND(riv, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
    EMIT_INSTRUCTION, // 119 - stm:	INT_IFCMP(ATTEMPT_INT(r, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
    EMIT_INSTRUCTION, // 120 - stm:	INT_IFCMP(ATTEMPT_INT(address1scaledreg, OTHER_OPERAND(r, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
    EMIT_INSTRUCTION, // 121 - stm:	INT_IFCMP(ATTEMPT_INT(address1scaledreg, OTHER_OPERAND(address1reg, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
    EMIT_INSTRUCTION, // 122 - stm:	INT_IFCMP(ATTEMPT_INT(address1reg, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
    EMIT_INSTRUCTION, // 123 - stm:	INT_IFCMP(ATTEMPT_INT(address, OTHER_OPERAND(INT_CONSTANT, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
    EMIT_INSTRUCTION, // 124 - stm:	INT_IFCMP(ATTEMPT_INT(INT_CONSTANT, OTHER_OPERAND(address, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
    EMIT_INSTRUCTION, // 125 - stm:	INT_IFCMP(ATTEMPT_INT(riv, OTHER_OPERAND(riv, OTHER_OPERAND(riv,riv))), INT_CONSTANT)
    EMIT_INSTRUCTION, // 126 - stm:	INT_IFCMP(ATTEMPT_INT(r, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
    EMIT_INSTRUCTION, // 127 - stm:	INT_IFCMP(ATTEMPT_INT(address1scaledreg, OTHER_OPERAND(r, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
    EMIT_INSTRUCTION, // 128 - stm:	INT_IFCMP(ATTEMPT_INT(address1scaledreg, OTHER_OPERAND(address1reg, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
    EMIT_INSTRUCTION, // 129 - stm:	INT_IFCMP(ATTEMPT_INT(address1reg, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
    EMIT_INSTRUCTION, // 130 - stm:	INT_IFCMP(ATTEMPT_INT(address, OTHER_OPERAND(INT_CONSTANT, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
    EMIT_INSTRUCTION, // 131 - stm:	INT_IFCMP(ATTEMPT_INT(INT_CONSTANT, OTHER_OPERAND(address, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
    EMIT_INSTRUCTION, // 132 - r:	ATTEMPT_LONG(rlv, OTHER_OPERAND(rlv, OTHER_OPERAND(rlv, rlv)))
    EMIT_INSTRUCTION, // 133 - r:	ATTEMPT_LONG(r, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(rlv, rlv)))
    EMIT_INSTRUCTION, // 134 - r:	ATTEMPT_LONG(address1scaledreg, OTHER_OPERAND(r, OTHER_OPERAND(rlv, rlv)))
    EMIT_INSTRUCTION, // 135 - r:	ATTEMPT_LONG(address1scaledreg, OTHER_OPERAND(address1reg, OTHER_OPERAND(rlv, rlv)))
    EMIT_INSTRUCTION, // 136 - r:	ATTEMPT_LONG(address1reg, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(rlv, rlv)))
    EMIT_INSTRUCTION, // 137 - r:	ATTEMPT_LONG(address, OTHER_OPERAND(LONG_CONSTANT, OTHER_OPERAND(rlv, rlv)))
    EMIT_INSTRUCTION, // 138 - r:	ATTEMPT_LONG(LONG_CONSTANT, OTHER_OPERAND(address, OTHER_OPERAND(rlv, rlv)))
    EMIT_INSTRUCTION, // 139 - stm:	INT_IFCMP(ATTEMPT_LONG(rlv, OTHER_OPERAND(rlv, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)
    EMIT_INSTRUCTION, // 140 - stm:	INT_IFCMP(ATTEMPT_LONG(r, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)
    EMIT_INSTRUCTION, // 141 - stm:	INT_IFCMP(ATTEMPT_LONG(address1scaledreg, OTHER_OPERAND(r, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)
    EMIT_INSTRUCTION, // 142 - stm:	INT_IFCMP(ATTEMPT_LONG(address1scaledreg, OTHER_OPERAND(address1reg, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)
    EMIT_INSTRUCTION, // 143 - stm:	INT_IFCMP(ATTEMPT_LONG(address1reg, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)
    EMIT_INSTRUCTION, // 144 - stm:	INT_IFCMP(ATTEMPT_LONG(address, OTHER_OPERAND(LONG_CONSTANT, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)
    EMIT_INSTRUCTION, // 145 - stm:	INT_IFCMP(ATTEMPT_LONG(LONG_CONSTANT, OTHER_OPERAND(address, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)
    EMIT_INSTRUCTION, // 146 - stm:	INT_IFCMP(ATTEMPT_LONG(rlv, OTHER_OPERAND(rlv, OTHER_OPERAND(rlv,rlv))), INT_CONSTANT)
    EMIT_INSTRUCTION, // 147 - stm:	INT_IFCMP(ATTEMPT_LONG(r, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)
    EMIT_INSTRUCTION, // 148 - stm:	INT_IFCMP(ATTEMPT_LONG(address1scaledreg, OTHER_OPERAND(r, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)
    EMIT_INSTRUCTION, // 149 - stm:	INT_IFCMP(ATTEMPT_LONG(address1scaledreg, OTHER_OPERAND(address1reg, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)
    EMIT_INSTRUCTION, // 150 - stm:	INT_IFCMP(ATTEMPT_LONG(address1reg, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)
    EMIT_INSTRUCTION, // 151 - stm:	INT_IFCMP(ATTEMPT_LONG(address, OTHER_OPERAND(LONG_CONSTANT, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)
    EMIT_INSTRUCTION, // 152 - stm:	INT_IFCMP(ATTEMPT_LONG(LONG_CONSTANT, OTHER_OPERAND(address, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)
    EMIT_INSTRUCTION, // 153 - bittest:	INT_AND(INT_USHR(r,INT_AND(r,INT_CONSTANT)),INT_CONSTANT)
    EMIT_INSTRUCTION, // 154 - bittest:	INT_AND(INT_USHR(load32,INT_AND(r,INT_CONSTANT)),INT_CONSTANT)
    EMIT_INSTRUCTION, // 155 - bittest:	INT_AND(INT_USHR(r,INT_CONSTANT),INT_CONSTANT)
    EMIT_INSTRUCTION, // 156 - bittest:	INT_AND(INT_SHR(r,INT_AND(r,INT_CONSTANT)),INT_CONSTANT)
    EMIT_INSTRUCTION, // 157 - bittest:	INT_AND(INT_SHR(load32,INT_AND(r,INT_CONSTANT)),INT_CONSTANT)
    EMIT_INSTRUCTION, // 158 - bittest:	INT_AND(INT_SHR(r,INT_CONSTANT),INT_CONSTANT)
    EMIT_INSTRUCTION, // 159 - bittest:	INT_AND(INT_SHL(INT_CONSTANT,INT_AND(riv,INT_CONSTANT)),r)
    EMIT_INSTRUCTION, // 160 - bittest:	INT_AND(INT_SHL(INT_CONSTANT,INT_AND(r, INT_CONSTANT)),load32)
    EMIT_INSTRUCTION, // 161 - bittest:	INT_AND(r,INT_SHL(INT_CONSTANT,INT_AND(r, INT_CONSTANT)))
    EMIT_INSTRUCTION, // 162 - bittest:	INT_AND(load32,INT_SHL(INT_CONSTANT,INT_AND(r, INT_CONSTANT)))
    EMIT_INSTRUCTION, // 163 - r:	BOOLEAN_CMP_INT(r,riv)
    EMIT_INSTRUCTION, // 164 - boolcmp: BOOLEAN_CMP_INT(r,riv)
    EMIT_INSTRUCTION, // 165 - r:	BOOLEAN_CMP_INT(r,INT_CONSTANT)
    EMIT_INSTRUCTION, // 166 - boolcmp: BOOLEAN_CMP_INT(r,INT_CONSTANT)
    EMIT_INSTRUCTION, // 167 - r:	BOOLEAN_CMP_INT(r,INT_CONSTANT)
    EMIT_INSTRUCTION, // 168 - r:	BOOLEAN_CMP_INT(load32,INT_CONSTANT)
    EMIT_INSTRUCTION, // 169 - r:	BOOLEAN_CMP_INT(r,INT_CONSTANT)
    EMIT_INSTRUCTION, // 170 - r:	BOOLEAN_CMP_INT(load32,INT_CONSTANT)
    EMIT_INSTRUCTION, // 171 - r:	BOOLEAN_CMP_INT(cz, INT_CONSTANT)
    EMIT_INSTRUCTION, // 172 - boolcmp: BOOLEAN_CMP_INT(cz, INT_CONSTANT)
    EMIT_INSTRUCTION, // 173 - r:	BOOLEAN_CMP_INT(szp, INT_CONSTANT)
    EMIT_INSTRUCTION, // 174 - boolcmp: BOOLEAN_CMP_INT(szp, INT_CONSTANT)
    EMIT_INSTRUCTION, // 175 - r:	BOOLEAN_CMP_INT(bittest, INT_CONSTANT)
    EMIT_INSTRUCTION, // 176 - boolcmp:	BOOLEAN_CMP_INT(bittest, INT_CONSTANT)
    EMIT_INSTRUCTION, // 177 - r:	BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
    NOFLAGS, // 178 - boolcmp:	BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
    EMIT_INSTRUCTION, // 179 - r:	BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
    EMIT_INSTRUCTION, // 180 - boolcmp:	BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
    EMIT_INSTRUCTION, // 181 - r:	BOOLEAN_CMP_INT(load32,riv)
    EMIT_INSTRUCTION, // 182 - boolcmp: BOOLEAN_CMP_INT(load32,riv)
    EMIT_INSTRUCTION, // 183 - r:	BOOLEAN_CMP_INT(r,load32)
    EMIT_INSTRUCTION, // 184 - boolcmp: BOOLEAN_CMP_INT(riv,load32)
    EMIT_INSTRUCTION | RIGHT_CHILD_FIRST, // 185 - stm:	BYTE_STORE(boolcmp, OTHER_OPERAND(riv,riv))
    EMIT_INSTRUCTION | RIGHT_CHILD_FIRST, // 186 - stm:	BYTE_ASTORE(boolcmp, OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 187 - r:	BOOLEAN_CMP_LONG(r,rlv)
    EMIT_INSTRUCTION, // 188 - boolcmp: BOOLEAN_CMP_LONG(r,rlv)
    EMIT_INSTRUCTION, // 189 - r:	BOOLEAN_CMP_LONG(r,LONG_CONSTANT)
    EMIT_INSTRUCTION, // 190 - boolcmp: BOOLEAN_CMP_LONG(r,LONG_CONSTANT)
    EMIT_INSTRUCTION, // 191 - r:	BOOLEAN_CMP_LONG(r,LONG_CONSTANT)
    EMIT_INSTRUCTION, // 192 - r:	BOOLEAN_CMP_LONG(load64,LONG_CONSTANT)
    EMIT_INSTRUCTION, // 193 - r:	BOOLEAN_CMP_LONG(r,LONG_CONSTANT)
    EMIT_INSTRUCTION, // 194 - r:	BOOLEAN_CMP_LONG(load64,LONG_CONSTANT)
    EMIT_INSTRUCTION, // 195 - r:	BOOLEAN_CMP_LONG(cz, LONG_CONSTANT)
    EMIT_INSTRUCTION, // 196 - r:	BOOLEAN_CMP_LONG(load64,rlv)
    EMIT_INSTRUCTION, // 197 - boolcmp: BOOLEAN_CMP_LONG(load64,rlv)
    EMIT_INSTRUCTION, // 198 - r:	BOOLEAN_CMP_LONG(r,load64)
    EMIT_INSTRUCTION, // 199 - boolcmp: BOOLEAN_CMP_LONG(rlv,load64)
    EMIT_INSTRUCTION, // 200 - r:	BOOLEAN_NOT(r)
    EMIT_INSTRUCTION, // 201 - stm:	BYTE_STORE(BOOLEAN_NOT(UBYTE_LOAD(rlv,rlv)),OTHER_OPERAND(rlv, rlv))
    EMIT_INSTRUCTION, // 202 - stm:	BYTE_ASTORE(BOOLEAN_NOT(UBYTE_ALOAD(rlv,riv)),OTHER_OPERAND(rlv, riv))
    EMIT_INSTRUCTION, // 203 - stm:    BYTE_STORE(riv, OTHER_OPERAND(rlv, rlv))
    EMIT_INSTRUCTION, // 204 - stm:    BYTE_STORE(load8, OTHER_OPERAND(rlv, rlv))
    EMIT_INSTRUCTION, // 205 - stm:    BYTE_ASTORE(riv, OTHER_OPERAND(rlv, riv))
    EMIT_INSTRUCTION, // 206 - stm:    BYTE_ASTORE(load8, OTHER_OPERAND(rlv, riv))
    EMIT_INSTRUCTION, // 207 - r: CMP_CMOV(r, OTHER_OPERAND(riv, any))
    EMIT_INSTRUCTION, // 208 - r: CMP_CMOV(r, OTHER_OPERAND(INT_CONSTANT, any))
    EMIT_INSTRUCTION, // 209 - r: CMP_CMOV(r, OTHER_OPERAND(INT_CONSTANT, OTHER_OPERAND(INT_CONSTANT, INT_CONSTANT)))
    EMIT_INSTRUCTION, // 210 - r: CMP_CMOV(load32, OTHER_OPERAND(INT_CONSTANT, OTHER_OPERAND(INT_CONSTANT, INT_CONSTANT)))
    EMIT_INSTRUCTION, // 211 - r: CMP_CMOV(r, OTHER_OPERAND(INT_CONSTANT, OTHER_OPERAND(INT_CONSTANT, INT_CONSTANT)))
    EMIT_INSTRUCTION, // 212 - r: CMP_CMOV(load32, OTHER_OPERAND(INT_CONSTANT, OTHER_OPERAND(INT_CONSTANT, INT_CONSTANT)))
    EMIT_INSTRUCTION, // 213 - r: CMP_CMOV(load8, OTHER_OPERAND(INT_CONSTANT, any))
    EMIT_INSTRUCTION, // 214 - r: CMP_CMOV(uload8, OTHER_OPERAND(riv, any))
    EMIT_INSTRUCTION, // 215 - r: CMP_CMOV(riv, OTHER_OPERAND(uload8, any))
    EMIT_INSTRUCTION, // 216 - r: CMP_CMOV(sload16, OTHER_OPERAND(INT_CONSTANT, any))
    EMIT_INSTRUCTION, // 217 - r: CMP_CMOV(load32, OTHER_OPERAND(riv, any))
    EMIT_INSTRUCTION, // 218 - r: CMP_CMOV(riv, OTHER_OPERAND(load32, any))
    EMIT_INSTRUCTION | RIGHT_CHILD_FIRST, // 219 - r: CMP_CMOV(boolcmp, OTHER_OPERAND(INT_CONSTANT, any))
    EMIT_INSTRUCTION | RIGHT_CHILD_FIRST, // 220 - r: CMP_CMOV(boolcmp, OTHER_OPERAND(INT_CONSTANT, any))
    EMIT_INSTRUCTION | RIGHT_CHILD_FIRST, // 221 - r: CMP_CMOV(bittest, OTHER_OPERAND(INT_CONSTANT, any))
    EMIT_INSTRUCTION | RIGHT_CHILD_FIRST, // 222 - r: CMP_CMOV(cz, OTHER_OPERAND(INT_CONSTANT, any))
    EMIT_INSTRUCTION | RIGHT_CHILD_FIRST, // 223 - r: CMP_CMOV(szp, OTHER_OPERAND(INT_CONSTANT, any))
    EMIT_INSTRUCTION, // 224 - r:	INT_2BYTE(r)
    EMIT_INSTRUCTION, // 225 - r:	INT_2BYTE(load8_16_32)
    EMIT_INSTRUCTION, // 226 - stm:	BYTE_STORE(INT_2BYTE(r),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 227 - stm:	BYTE_ASTORE(INT_2BYTE(r),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 228 - r:	INT_2LONG(r)
    EMIT_INSTRUCTION, // 229 - r:	INT_2LONG(load32)
    EMIT_INSTRUCTION, // 230 - r:      LONG_AND(INT_2LONG(r), LONG_CONSTANT)
    EMIT_INSTRUCTION, // 231 - r:      LONG_AND(INT_2LONG(load32), LONG_CONSTANT)
    EMIT_INSTRUCTION, // 232 - r:	INT_2ADDRZerExt(r)
    EMIT_INSTRUCTION, // 233 - r:	INT_2SHORT(r)
    EMIT_INSTRUCTION, // 234 - r:	INT_2SHORT(load16_32)
    EMIT_INSTRUCTION, // 235 - sload16:	INT_2SHORT(load16_32)
    EMIT_INSTRUCTION, // 236 - stm:	SHORT_STORE(INT_2SHORT(r), OTHER_OPERAND(riv,riv))
    EMIT_INSTRUCTION, // 237 - stm:	SHORT_ASTORE(INT_2SHORT(r), OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 238 - szpr:	INT_2USHORT(r)
    EMIT_INSTRUCTION, // 239 - uload16:	INT_2USHORT(load16_32)
    EMIT_INSTRUCTION, // 240 - r:	INT_2USHORT(load16_32)
    EMIT_INSTRUCTION, // 241 - stm:	SHORT_STORE(INT_2USHORT(r), OTHER_OPERAND(riv,riv))
    EMIT_INSTRUCTION, // 242 - stm:	SHORT_ASTORE(INT_2USHORT(r), OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 243 - czr:	INT_ADD(r, riv)
    EMIT_INSTRUCTION, // 244 - r:	INT_ADD(r, riv)
    EMIT_INSTRUCTION, // 245 - czr:	INT_ADD(r, load32)
    EMIT_INSTRUCTION, // 246 - czr:	INT_ADD(load32, riv)
    EMIT_INSTRUCTION, // 247 - stm:	INT_STORE(INT_ADD(INT_LOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 248 - stm:	INT_STORE(INT_ADD(riv,INT_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 249 - stm:	INT_ASTORE(INT_ADD(INT_ALOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 250 - stm:	INT_ASTORE(INT_ADD(riv,INT_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 251 - szpr:	INT_AND(r, riv)
    EMIT_INSTRUCTION, // 252 - szp:	INT_AND(r, riv)
    EMIT_INSTRUCTION, // 253 - szpr:	INT_AND(r, load32)
    EMIT_INSTRUCTION, // 254 - szpr:	INT_AND(load32, riv)
    EMIT_INSTRUCTION, // 255 - szp:	INT_AND(load8_16_32, riv)
    EMIT_INSTRUCTION, // 256 - szp:	INT_AND(r, load8_16_32)
    EMIT_INSTRUCTION, // 257 - stm:	INT_STORE(INT_AND(INT_LOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 258 - stm:	INT_STORE(INT_AND(r,INT_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 259 - stm:	INT_ASTORE(INT_AND(INT_ALOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 260 - stm:	INT_ASTORE(INT_AND(r,INT_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 261 - r:	INT_DIV(riv, riv)
    EMIT_INSTRUCTION, // 262 - r:	INT_DIV(riv, load32)
    EMIT_INSTRUCTION, // 263 - r:     UNSIGNED_DIV_64_32(rlv, riv)
    EMIT_INSTRUCTION, // 264 - r:     UNSIGNED_DIV_64_32(rlv, load32)
    EMIT_INSTRUCTION, // 265 - stm:	INT_IFCMP(r,riv)
    EMIT_INSTRUCTION, // 266 - stm:	INT_IFCMP(r, INT_CONSTANT)
    EMIT_INSTRUCTION, // 267 - stm:	INT_IFCMP(load8, INT_CONSTANT)
    EMIT_INSTRUCTION, // 268 - stm:	INT_IFCMP(uload8, r)
    EMIT_INSTRUCTION, // 269 - stm:	INT_IFCMP(r, uload8)
    EMIT_INSTRUCTION, // 270 - stm:	INT_IFCMP(sload16, INT_CONSTANT)
    EMIT_INSTRUCTION, // 271 - stm:	INT_IFCMP(load32, riv)
    EMIT_INSTRUCTION, // 272 - stm:	INT_IFCMP(r, load32)
    EMIT_INSTRUCTION, // 273 - stm:	INT_IFCMP(boolcmp, INT_CONSTANT)
    EMIT_INSTRUCTION, // 274 - stm:	INT_IFCMP(boolcmp, INT_CONSTANT)
    EMIT_INSTRUCTION, // 275 - stm:	INT_IFCMP(cz, INT_CONSTANT)
    EMIT_INSTRUCTION, // 276 - stm:	INT_IFCMP(szp, INT_CONSTANT)
    EMIT_INSTRUCTION, // 277 - stm:	INT_IFCMP(bittest, INT_CONSTANT)
    EMIT_INSTRUCTION, // 278 - stm:	INT_IFCMP2(r,riv)
    EMIT_INSTRUCTION, // 279 - stm:	INT_IFCMP2(load32,riv)
    EMIT_INSTRUCTION, // 280 - stm:	INT_IFCMP2(riv,load32)
    EMIT_INSTRUCTION, // 281 - r:	INT_LOAD(rlv, rlv)
    EMIT_INSTRUCTION, // 282 - r:	INT_LOAD(rlv, address1scaledreg)
    EMIT_INSTRUCTION, // 283 - r:	INT_LOAD(address1scaledreg, rlv)
    EMIT_INSTRUCTION, // 284 - r:	INT_LOAD(address1scaledreg, address1reg)
    EMIT_INSTRUCTION, // 285 - r:	INT_LOAD(address1reg, address1scaledreg)
    EMIT_INSTRUCTION, // 286 - r:	INT_LOAD(address, LONG_CONSTANT)
    EMIT_INSTRUCTION, // 287 - r:      INT_ALOAD(rlv, riv)
    EMIT_INSTRUCTION, // 288 - r:	INT_MOVE(riv)
    EMIT_INSTRUCTION, // 289 - czr:	INT_MOVE(czr)
    NOFLAGS, // 290 - cz:	INT_MOVE(cz)
    EMIT_INSTRUCTION, // 291 - szpr:	INT_MOVE(szpr)
    NOFLAGS, // 292 - szp:	INT_MOVE(szp)
    NOFLAGS, // 293 - sload8:	INT_MOVE(sload8)
    NOFLAGS, // 294 - uload8:	INT_MOVE(uload8)
    NOFLAGS, // 295 - load8:	INT_MOVE(load8)
    NOFLAGS, // 296 - sload16: INT_MOVE(sload16)
    NOFLAGS, // 297 - uload16: INT_MOVE(uload16)
    NOFLAGS, // 298 - load16:	INT_MOVE(load16)
    NOFLAGS, // 299 - load32:	INT_MOVE(load32)
    EMIT_INSTRUCTION, // 300 - r:	INT_MUL(r, riv)
    EMIT_INSTRUCTION, // 301 - r:	INT_MUL(r, load32)
    EMIT_INSTRUCTION, // 302 - r:	INT_MUL(load32, riv)
    EMIT_INSTRUCTION, // 303 - szpr:	INT_NEG(r)
    EMIT_INSTRUCTION, // 304 - stm:	INT_STORE(INT_NEG(INT_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 305 - stm:	INT_ASTORE(INT_NEG(INT_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 306 - r:	INT_NOT(r)
    EMIT_INSTRUCTION, // 307 - stm:	INT_STORE(INT_NOT(INT_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 308 - stm:	INT_ASTORE(INT_NOT(INT_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 309 - szpr:	INT_OR(r, riv)
    EMIT_INSTRUCTION, // 310 - szpr:	INT_OR(r, load32)
    EMIT_INSTRUCTION, // 311 - szpr:	INT_OR(load32, riv)
    EMIT_INSTRUCTION, // 312 - stm:	INT_STORE(INT_OR(INT_LOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 313 - stm:	INT_STORE(INT_OR(r, INT_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 314 - stm:	INT_ASTORE(INT_OR(INT_ALOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 315 - stm:	INT_ASTORE(INT_OR(r, INT_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 316 - r:	INT_REM(riv, riv)
    EMIT_INSTRUCTION, // 317 - r:	INT_REM(riv, load32)
    EMIT_INSTRUCTION, // 318 - r:     UNSIGNED_REM_64_32(rlv, riv)
    EMIT_INSTRUCTION, // 319 - r:     UNSIGNED_REM_64_32(rlv, load32)
    EMIT_INSTRUCTION, // 320 - r:	INT_OR(INT_SHL(r,INT_CONSTANT),INT_USHR(r,INT_CONSTANT))
    EMIT_INSTRUCTION, // 321 - r:      INT_OR(INT_USHR(r,INT_CONSTANT),INT_SHL(r,INT_CONSTANT))
    EMIT_INSTRUCTION, // 322 - r:      INT_OR(INT_SHL(r,INT_CONSTANT),INT_USHR(r,INT_CONSTANT))
    EMIT_INSTRUCTION, // 323 - r:      INT_OR(INT_USHR(r,INT_CONSTANT),INT_SHL(r,INT_CONSTANT))
    EMIT_INSTRUCTION, // 324 - r:      INT_OR(INT_SHL(r,INT_AND(r,INT_CONSTANT)),INT_USHR(r,INT_AND(INT_NEG(r),INT_CONSTANT)))
    EMIT_INSTRUCTION, // 325 - r:      INT_OR(INT_USHR(r,INT_AND(INT_NEG(r),INT_CONSTANT)),INT_SHL(r,INT_AND(r,INT_CONSTANT)))
    EMIT_INSTRUCTION, // 326 - r:      INT_OR(INT_SHL(r,INT_AND(INT_NEG(r),INT_CONSTANT)),INT_USHR(r,INT_AND(r,INT_CONSTANT)))
    EMIT_INSTRUCTION, // 327 - r:      INT_OR(INT_USHR(r,INT_AND(r,INT_CONSTANT)),INT_SHL(r,INT_AND(INT_NEG(r),INT_CONSTANT)))
    EMIT_INSTRUCTION, // 328 - szpr:	INT_SHL(riv, INT_AND(r, INT_CONSTANT))
    EMIT_INSTRUCTION, // 329 - szpr:	INT_SHL(riv, riv)
    EMIT_INSTRUCTION, // 330 - szpr:	INT_SHL(r, INT_CONSTANT)
    EMIT_INSTRUCTION, // 331 - r:	INT_SHL(r, INT_CONSTANT)
    EMIT_INSTRUCTION, // 332 - szpr:	INT_SHL(INT_SHR(r, INT_CONSTANT), INT_CONSTANT)
    EMIT_INSTRUCTION, // 333 - stm:	INT_STORE(INT_SHL(INT_LOAD(riv,riv),INT_AND(r,INT_CONSTANT)),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 334 - stm:	INT_STORE(INT_SHL(INT_LOAD(riv,riv), INT_CONSTANT),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 335 - stm:	INT_ASTORE(INT_SHL(INT_ALOAD(riv,riv),INT_AND(r, INT_CONSTANT)),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 336 - stm:	INT_ASTORE(INT_SHL(INT_ALOAD(riv,riv), INT_CONSTANT),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 337 - szpr:	INT_SHR(riv, INT_AND(r, INT_CONSTANT))
    EMIT_INSTRUCTION, // 338 - szpr:	INT_SHR(riv, riv)
    EMIT_INSTRUCTION, // 339 - szpr:	INT_SHR(riv, INT_CONSTANT)
    EMIT_INSTRUCTION, // 340 - stm:	INT_STORE(INT_SHR(INT_LOAD(riv,riv),INT_AND(r,INT_CONSTANT)),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 341 - stm:	INT_STORE(INT_SHR(INT_LOAD(riv,riv), INT_CONSTANT),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 342 - stm:	INT_ASTORE(INT_SHR(INT_ALOAD(riv,riv),INT_AND(r, INT_CONSTANT)),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 343 - stm:	INT_ASTORE(INT_SHR(INT_ALOAD(riv,riv), INT_CONSTANT),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 344 - stm:	INT_STORE(riv, OTHER_OPERAND(rlv, rlv))
    EMIT_INSTRUCTION, // 345 - stm:	INT_STORE(riv, OTHER_OPERAND(rlv, address1scaledreg))
    EMIT_INSTRUCTION, // 346 - stm:	INT_STORE(riv, OTHER_OPERAND(address1scaledreg, rlv))
    EMIT_INSTRUCTION, // 347 - stm:	INT_STORE(riv, OTHER_OPERAND(address1scaledreg, address1reg))
    EMIT_INSTRUCTION, // 348 - stm:	INT_STORE(riv, OTHER_OPERAND(address1reg, address1scaledreg))
    EMIT_INSTRUCTION, // 349 - stm:	INT_STORE(riv, OTHER_OPERAND(address, LONG_CONSTANT))
    EMIT_INSTRUCTION, // 350 - czr:	INT_SUB(riv, r)
    EMIT_INSTRUCTION, // 351 - r:	INT_SUB(riv, r)
    EMIT_INSTRUCTION, // 352 - r:	INT_SUB(load32, r)
    EMIT_INSTRUCTION, // 353 - czr:	INT_SUB(riv, load32)
    EMIT_INSTRUCTION, // 354 - czr:	INT_SUB(load32, riv)
    EMIT_INSTRUCTION, // 355 - stm:	INT_STORE(INT_SUB(INT_LOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 356 - stm:	INT_STORE(INT_SUB(riv, INT_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 357 - stm:	INT_ASTORE(INT_SUB(INT_ALOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 358 - stm:	INT_ASTORE(INT_SUB(riv, INT_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 359 - szpr:	INT_USHR(riv, INT_AND(r, INT_CONSTANT))
    EMIT_INSTRUCTION, // 360 - szpr:	INT_USHR(riv, riv)
    EMIT_INSTRUCTION, // 361 - szpr:	INT_USHR(riv, INT_CONSTANT)
    EMIT_INSTRUCTION, // 362 - stm:	INT_STORE(INT_USHR(INT_LOAD(riv,riv),INT_AND(r,INT_CONSTANT)),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 363 - stm:	INT_STORE(INT_USHR(INT_LOAD(riv,riv), INT_CONSTANT),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 364 - stm:	INT_ASTORE(INT_USHR(INT_ALOAD(riv,riv),INT_AND(r, INT_CONSTANT)),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 365 - stm:	INT_ASTORE(INT_USHR(INT_ALOAD(riv,riv), INT_CONSTANT),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 366 - szpr:	INT_XOR(r, riv)
    EMIT_INSTRUCTION, // 367 - szpr:	INT_XOR(r, load32)
    EMIT_INSTRUCTION, // 368 - szpr:	INT_XOR(load32, riv)
    EMIT_INSTRUCTION, // 369 - stm:	INT_STORE(INT_XOR(INT_LOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 370 - stm:	INT_STORE(INT_XOR(r,INT_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 371 - stm:	INT_ASTORE(INT_XOR(INT_ALOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 372 - stm:	INT_ASTORE(INT_XOR(r,INT_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 373 - r: LCMP_CMOV(r, OTHER_OPERAND(rlv, any))
    EMIT_INSTRUCTION, // 374 - r: LCMP_CMOV(r, OTHER_OPERAND(INT_CONSTANT, any))
    EMIT_INSTRUCTION, // 375 - r: LCMP_CMOV(load64, OTHER_OPERAND(rlv, any))
    EMIT_INSTRUCTION, // 376 - r: LCMP_CMOV(rlv, OTHER_OPERAND(load64, any))
    EMIT_INSTRUCTION, // 377 - r:	LONG_ADD(address1scaledreg, r)
    EMIT_INSTRUCTION, // 378 - r:	LONG_ADD(r, address1scaledreg)
    EMIT_INSTRUCTION, // 379 - r:	LONG_ADD(address1scaledreg, address1reg)
    EMIT_INSTRUCTION, // 380 - r:	LONG_ADD(address1reg, address1scaledreg)
    EMIT_INSTRUCTION, // 381 - r:	LONG_ADD(address, LONG_CONSTANT)
    EMIT_INSTRUCTION, // 382 - r:	LONG_MOVE(address)
    EMIT_INSTRUCTION, // 383 - r:      BYTE_LOAD(rlv, rlv)
    EMIT_INSTRUCTION, // 384 - sload8:	BYTE_LOAD(rlv, rlv)
    EMIT_INSTRUCTION, // 385 - r:      BYTE_ALOAD(rlv, riv)
    EMIT_INSTRUCTION, // 386 - r:      BYTE_ALOAD(rlv, r)
    EMIT_INSTRUCTION, // 387 - sload8:	BYTE_ALOAD(rlv, riv)
    EMIT_INSTRUCTION, // 388 - r:      UBYTE_LOAD(rlv, rlv)
    EMIT_INSTRUCTION, // 389 - uload8:	UBYTE_LOAD(rlv, rlv)
    EMIT_INSTRUCTION, // 390 - r:	UBYTE_ALOAD(rlv, riv)
    EMIT_INSTRUCTION, // 391 - r:      UBYTE_ALOAD(rlv, r)
    EMIT_INSTRUCTION, // 392 - uload8:	UBYTE_ALOAD(rlv, riv)
    NOFLAGS, // 393 - load8:	sload8
    NOFLAGS, // 394 - load8:	uload8
    EMIT_INSTRUCTION, // 395 - r:      SHORT_LOAD(rlv, rlv)
    EMIT_INSTRUCTION, // 396 - sload16: SHORT_LOAD(rlv, rlv)
    EMIT_INSTRUCTION, // 397 - r:      SHORT_ALOAD(rlv, riv)
    EMIT_INSTRUCTION, // 398 - r:      SHORT_ALOAD(rlv, r)
    EMIT_INSTRUCTION, // 399 - sload16: SHORT_ALOAD(rlv, riv)
    EMIT_INSTRUCTION, // 400 - r:      USHORT_LOAD(rlv, rlv)
    EMIT_INSTRUCTION, // 401 - uload16: USHORT_LOAD(rlv, rlv)
    EMIT_INSTRUCTION, // 402 - r:      USHORT_ALOAD(rlv, riv)
    EMIT_INSTRUCTION, // 403 - r:      USHORT_ALOAD(rlv, r)
    EMIT_INSTRUCTION, // 404 - uload16: USHORT_ALOAD(rlv, riv)
    NOFLAGS, // 405 - load16:	sload16
    NOFLAGS, // 406 - load16:	uload16
    EMIT_INSTRUCTION, // 407 - load32:	INT_LOAD(rlv, rlv)
    EMIT_INSTRUCTION, // 408 - load32:	INT_ALOAD(rlv, riv)
    NOFLAGS, // 409 - load16_32:      load16
    NOFLAGS, // 410 - load16_32:      load32
    NOFLAGS, // 411 - load8_16_32:	load16_32
    NOFLAGS, // 412 - load8_16_32:	load8
    EMIT_INSTRUCTION, // 413 - load64:	LONG_LOAD(rlv, rlv)
    EMIT_INSTRUCTION, // 414 - load64:	LONG_ALOAD(rlv, rlv)
    EMIT_INSTRUCTION, // 415 - load64:	LONG_ALOAD(rlv, r)
    NOFLAGS, // 416 - load8_16_32_64:	load64
    NOFLAGS, // 417 - load8_16_32_64:	load8_16_32
    EMIT_INSTRUCTION, // 418 - r:	LONG_2INT(r)
    EMIT_INSTRUCTION, // 419 - stm:	INT_STORE(LONG_2INT(r), OTHER_OPERAND(riv,riv))
    EMIT_INSTRUCTION, // 420 - stm:	INT_ASTORE(LONG_2INT(r), OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 421 - r:	LONG_2INT(load64)
    EMIT_INSTRUCTION, // 422 - load32:      LONG_2INT(load64)
    EMIT_INSTRUCTION, // 423 - r:	LONG_2INT(LONG_USHR(r, INT_CONSTANT))
    EMIT_INSTRUCTION, // 424 - r:      LONG_2INT(LONG_SHR(r, INT_CONSTANT))
    EMIT_INSTRUCTION, // 425 - r:      LONG_2INT(LONG_USHR(load64, INT_CONSTANT))
    EMIT_INSTRUCTION, // 426 - r:      LONG_2INT(LONG_SHR(load64, INT_CONSTANT))
    EMIT_INSTRUCTION, // 427 - load32:      LONG_2INT(LONG_USHR(load64, INT_CONSTANT))
    EMIT_INSTRUCTION, // 428 - load32:      LONG_2INT(LONG_SHR(load64, INT_CONSTANT))
    EMIT_INSTRUCTION, // 429 - czr:	LONG_ADD(r, rlv)
    EMIT_INSTRUCTION, // 430 - czr:	LONG_ADD(r, riv)
    EMIT_INSTRUCTION, // 431 - czr:    LONG_ADD(r,r)
    EMIT_INSTRUCTION, // 432 - r:	LONG_ADD(r, rlv)
    EMIT_INSTRUCTION, // 433 - czr:	LONG_ADD(rlv, load64)
    EMIT_INSTRUCTION, // 434 - czr:	LONG_ADD(load64, rlv)
    EMIT_INSTRUCTION, // 435 - stm:	LONG_STORE(LONG_ADD(LONG_LOAD(rlv,rlv),rlv),OTHER_OPERAND(rlv, rlv))
    EMIT_INSTRUCTION, // 436 - stm:	LONG_STORE(LONG_ADD(rlv,LONG_LOAD(rlv,rlv)),OTHER_OPERAND(rlv, rlv))
    EMIT_INSTRUCTION, // 437 - stm:	LONG_ASTORE(LONG_ADD(LONG_ALOAD(rlv,rlv),rlv),OTHER_OPERAND(rlv, rlv))
    EMIT_INSTRUCTION, // 438 - stm:	LONG_ASTORE(LONG_ADD(rlv,LONG_ALOAD(rlv,rlv)),OTHER_OPERAND(rlv, rlv))
    EMIT_INSTRUCTION, // 439 - szpr:	LONG_AND(r, rlv)
    EMIT_INSTRUCTION, // 440 - szpr:    LONG_AND(r,r)
    EMIT_INSTRUCTION, // 441 - szp:	LONG_AND(r, rlv)
    EMIT_INSTRUCTION, // 442 - szpr:	LONG_AND(rlv, load64)
    EMIT_INSTRUCTION, // 443 - szpr:	LONG_AND(load64, rlv)
    EMIT_INSTRUCTION, // 444 - szp:	LONG_AND(load8_16_32_64, rlv)
    EMIT_INSTRUCTION, // 445 - szp:	LONG_AND(r, load8_16_32_64)
    EMIT_INSTRUCTION, // 446 - stm:	LONG_STORE(LONG_AND(LONG_LOAD(rlv,rlv),rlv),OTHER_OPERAND(rlv, rlv))
    EMIT_INSTRUCTION, // 447 - stm:	LONG_STORE(LONG_AND(r,LONG_LOAD(rlv,rlv)),OTHER_OPERAND(rlv, rlv))
    EMIT_INSTRUCTION, // 448 - stm:	LONG_ASTORE(LONG_AND(LONG_ALOAD(rlv,rlv),rlv),OTHER_OPERAND(rlv, rlv))
    EMIT_INSTRUCTION, // 449 - stm:	LONG_ASTORE(LONG_AND(r,LONG_ALOAD(rlv,rlv)),OTHER_OPERAND(rlv, rlv))
    EMIT_INSTRUCTION, // 450 - r:  LONG_DIV(rlv, rlv)
    EMIT_INSTRUCTION, // 451 - r:  LONG_DIV(rlv, riv)
    EMIT_INSTRUCTION, // 452 - r:  LONG_DIV(riv, rlv)
    EMIT_INSTRUCTION, // 453 - r:  LONG_DIV(rlv, load64)
    EMIT_INSTRUCTION, // 454 - r:  LONG_DIV(load64,rlv)
    EMIT_INSTRUCTION, // 455 - stm:	LONG_IFCMP(rlv,rlv)
    EMIT_INSTRUCTION, // 456 - stm:	LONG_IFCMP(r, LONG_CONSTANT)
    EMIT_INSTRUCTION, // 457 - r:	LONG_LOAD(rlv, rlv)
    EMIT_INSTRUCTION, // 458 - r:	LONG_LOAD(rlv, address1scaledreg)
    EMIT_INSTRUCTION, // 459 - r:	LONG_LOAD(address1scaledreg, rlv)
    EMIT_INSTRUCTION, // 460 - r:	LONG_LOAD(address1scaledreg, address1reg)
    EMIT_INSTRUCTION, // 461 - r:	LONG_LOAD(address1reg, address1scaledreg)
    EMIT_INSTRUCTION, // 462 - r:	LONG_LOAD(address, LONG_CONSTANT)
    EMIT_INSTRUCTION, // 463 - r:      LONG_ALOAD(rlv, riv)
    EMIT_INSTRUCTION, // 464 - r:      LONG_ALOAD(rlv, r)
    EMIT_INSTRUCTION, // 465 - r:	LONG_MOVE(rlv)
    EMIT_INSTRUCTION, // 466 - r:  LONG_MOVE(riv)
    NOFLAGS, // 467 - load64:	LONG_MOVE(load64)
    EMIT_INSTRUCTION, // 468 - r:	LONG_MUL(r, rlv)
    EMIT_INSTRUCTION, // 469 - r:	INT_MUL(r, load64)
    EMIT_INSTRUCTION, // 470 - r:	INT_MUL(load64, rlv)
    EMIT_INSTRUCTION, // 471 - szpr:	LONG_NEG(r)
    EMIT_INSTRUCTION, // 472 - stm:	LONG_STORE(LONG_NEG(LONG_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 473 - stm:	LONG_ASTORE(LONG_NEG(LONG_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 474 - r:	LONG_NOT(r)
    EMIT_INSTRUCTION, // 475 - stm:	LONG_STORE(LONG_NOT(LONG_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 476 - stm:	LONG_ASTORE(LONG_NOT(LONG_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 477 - szpr:	LONG_OR(r, rlv)
    EMIT_INSTRUCTION, // 478 - szpr:	LONG_OR(r, load64)
    EMIT_INSTRUCTION, // 479 - szpr:	LONG_OR(load64, rlv)
    EMIT_INSTRUCTION, // 480 - stm:	LONG_STORE(LONG_OR(LONG_LOAD(rlv,rlv),rlv),OTHER_OPERAND(rlv, rlv))
    EMIT_INSTRUCTION, // 481 - stm:	LONG_STORE(LONG_OR(r,LONG_LOAD(rlv,rlv)),OTHER_OPERAND(rlv, rlv))
    EMIT_INSTRUCTION, // 482 - stm:	LONG_ASTORE(LONG_OR(LONG_ALOAD(rlv,rlv),rlv),OTHER_OPERAND(rlv, rlv))
    EMIT_INSTRUCTION, // 483 - stm:	LONG_ASTORE(LONG_OR(r,LONG_ALOAD(rlv,rlv)),OTHER_OPERAND(rlv, rlv))
    EMIT_INSTRUCTION, // 484 - r:  LONG_REM(rlv, rlv)
    EMIT_INSTRUCTION, // 485 - r:  LONG_REM(rlv, riv)
    EMIT_INSTRUCTION, // 486 - r:  LONG_REM(riv, rlv)
    EMIT_INSTRUCTION, // 487 - r:  LONG_REM(rlv, load64)
    EMIT_INSTRUCTION, // 488 - r:  LONG_REM(load64,rlv)
    EMIT_INSTRUCTION, // 489 - szpr:	LONG_SHL(rlv, INT_AND(r, INT_CONSTANT))
    EMIT_INSTRUCTION, // 490 - szpr:	LONG_SHL(rlv, riv)
    EMIT_INSTRUCTION, // 491 - szpr:	LONG_SHL(r, INT_CONSTANT)
    EMIT_INSTRUCTION, // 492 - r:	LONG_SHL(r, INT_CONSTANT)
    EMIT_INSTRUCTION, // 493 - szpr:	LONG_SHL(LONG_SHR(r, INT_CONSTANT), INT_CONSTANT)
    EMIT_INSTRUCTION, // 494 - stm:	LONG_STORE(LONG_SHL(LONG_LOAD(riv,riv),INT_AND(r,INT_CONSTANT)),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 495 - stm:	LONG_STORE(LONG_SHL(LONG_LOAD(riv,riv), INT_CONSTANT),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 496 - stm:	LONG_ASTORE(LONG_SHL(LONG_ALOAD(riv,riv),INT_AND(r, INT_CONSTANT)),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 497 - stm:	LONG_ASTORE(LONG_SHL(LONG_ALOAD(riv,riv), INT_CONSTANT),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 498 - szpr:	LONG_SHR(rlv, INT_AND(r, LONG_CONSTANT))
    EMIT_INSTRUCTION, // 499 - szpr:	LONG_SHR(rlv, riv)
    EMIT_INSTRUCTION, // 500 - szpr:	LONG_SHR(rlv, LONG_CONSTANT)
    EMIT_INSTRUCTION, // 501 - stm:	LONG_STORE(LONG_SHR(LONG_LOAD(riv,riv),INT_AND(r,LONG_CONSTANT)),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 502 - stm:	LONG_STORE(LONG_SHR(LONG_LOAD(riv,riv), LONG_CONSTANT),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 503 - stm:	LONG_ASTORE(LONG_SHR(LONG_ALOAD(riv,riv),INT_AND(r, LONG_CONSTANT)),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 504 - stm:	LONG_ASTORE(LONG_SHR(LONG_ALOAD(riv,riv), LONG_CONSTANT),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 505 - stm:	LONG_STORE(rlv, OTHER_OPERAND(rlv, rlv))
    EMIT_INSTRUCTION, // 506 - stm:	LONG_STORE(rlv, OTHER_OPERAND(rlv, address1scaledreg))
    EMIT_INSTRUCTION, // 507 - stm:	LONG_STORE(rlv, OTHER_OPERAND(address1scaledreg, rlv))
    EMIT_INSTRUCTION, // 508 - stm:	LONG_STORE(rlv, OTHER_OPERAND(address1scaledreg, address1reg))
    EMIT_INSTRUCTION, // 509 - stm:	LONG_STORE(rlv, OTHER_OPERAND(address1reg, address1scaledreg))
    EMIT_INSTRUCTION, // 510 - stm:	LONG_STORE(rlv, OTHER_OPERAND(address, LONG_CONSTANT))
    EMIT_INSTRUCTION, // 511 - czr:	LONG_SUB(rlv, r)
    EMIT_INSTRUCTION, // 512 - r:	LONG_SUB(rlv, r)
    EMIT_INSTRUCTION, // 513 - r:	LONG_SUB(load64, r)
    EMIT_INSTRUCTION, // 514 - czr:	LONG_SUB(rlv, load64)
    EMIT_INSTRUCTION, // 515 - czr:	LONG_SUB(load64, rlv)
    EMIT_INSTRUCTION, // 516 - stm:	LONG_STORE(LONG_SUB(LONG_LOAD(rlv,rlv),rlv),OTHER_OPERAND(rlv, rlv))
    EMIT_INSTRUCTION, // 517 - stm:	LONG_STORE(LONG_SUB(rlv, LONG_LOAD(rlv,rlv)),OTHER_OPERAND(rlv, rlv))
    EMIT_INSTRUCTION, // 518 - stm:	LONG_ASTORE(LONG_SUB(LONG_ALOAD(rlv,rlv),rlv),OTHER_OPERAND(rlv, rlv))
    EMIT_INSTRUCTION, // 519 - stm:	LONG_ASTORE(LONG_SUB(rlv, LONG_ALOAD(rlv,rlv)),OTHER_OPERAND(rlv, rlv))
    EMIT_INSTRUCTION, // 520 - szpr:	LONG_USHR(rlv, LONG_AND(r, LONG_CONSTANT))
    EMIT_INSTRUCTION, // 521 - szpr:	LONG_USHR(rlv, riv)
    EMIT_INSTRUCTION, // 522 - szpr:	LONG_USHR(rlv, LONG_CONSTANT)
    EMIT_INSTRUCTION, // 523 - stm:	LONG_STORE(LONG_USHR(LONG_LOAD(riv,riv),LONG_AND(r,LONG_CONSTANT)),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 524 - stm:	LONG_STORE(LONG_USHR(LONG_LOAD(riv,riv), LONG_CONSTANT),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 525 - stm:	LONG_ASTORE(LONG_USHR(LONG_ALOAD(riv,riv),LONG_AND(r, LONG_CONSTANT)),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 526 - stm:	LONG_ASTORE(LONG_USHR(LONG_ALOAD(riv,riv), LONG_CONSTANT),OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 527 - szpr:	LONG_XOR(r, rlv)
    EMIT_INSTRUCTION, // 528 - szpr:	LONG_XOR(r, load64)
    EMIT_INSTRUCTION, // 529 - szpr:	LONG_XOR(load64, rlv)
    EMIT_INSTRUCTION, // 530 - stm:	LONG_STORE(LONG_XOR(LONG_LOAD(rlv,rlv),rlv),OTHER_OPERAND(rlv, rlv))
    EMIT_INSTRUCTION, // 531 - stm:	LONG_STORE(LONG_XOR(r,LONG_LOAD(rlv,rlv)),OTHER_OPERAND(rlv, rlv))
    EMIT_INSTRUCTION, // 532 - stm:	LONG_ASTORE(LONG_XOR(LONG_ALOAD(rlv,rlv),rlv),OTHER_OPERAND(rlv, rlv))
    EMIT_INSTRUCTION, // 533 - stm:	LONG_ASTORE(LONG_XOR(r,LONG_ALOAD(rlv,rlv)),OTHER_OPERAND(rlv, rlv))
    EMIT_INSTRUCTION, // 534 - r: FLOAT_ADD(r, r)
    EMIT_INSTRUCTION, // 535 - r: FLOAT_ADD(r, float_load)
    EMIT_INSTRUCTION, // 536 - r: FLOAT_ADD(float_load,r)
    EMIT_INSTRUCTION, // 537 - r: DOUBLE_ADD(r, r)
    EMIT_INSTRUCTION, // 538 - r: DOUBLE_ADD(r, double_load)
    EMIT_INSTRUCTION, // 539 - r: DOUBLE_ADD(double_load,r)
    EMIT_INSTRUCTION, // 540 - r: FLOAT_SUB(r, r)
    EMIT_INSTRUCTION, // 541 - r: FLOAT_SUB(r, float_load)
    EMIT_INSTRUCTION, // 542 - r: DOUBLE_SUB(r, r)
    EMIT_INSTRUCTION, // 543 - r: DOUBLE_SUB(r, double_load)
    EMIT_INSTRUCTION, // 544 - r: FLOAT_MUL(r, r)
    EMIT_INSTRUCTION, // 545 - r: FLOAT_MUL(r, float_load)
    EMIT_INSTRUCTION, // 546 - r: FLOAT_MUL(float_load, r)
    EMIT_INSTRUCTION, // 547 - r: DOUBLE_MUL(r, r)
    EMIT_INSTRUCTION, // 548 - r: DOUBLE_MUL(r, double_load)
    EMIT_INSTRUCTION, // 549 - r: DOUBLE_MUL(double_load, r)
    EMIT_INSTRUCTION, // 550 - r: FLOAT_DIV(r, r)
    EMIT_INSTRUCTION, // 551 - r: FLOAT_DIV(r, float_load)
    EMIT_INSTRUCTION, // 552 - r: DOUBLE_DIV(r, r)
    EMIT_INSTRUCTION, // 553 - r: DOUBLE_DIV(r, double_load)
    EMIT_INSTRUCTION, // 554 - r: FLOAT_NEG(r)
    EMIT_INSTRUCTION, // 555 - r: DOUBLE_NEG(r)
    EMIT_INSTRUCTION, // 556 - r: FLOAT_SQRT(r)
    EMIT_INSTRUCTION, // 557 - r: DOUBLE_SQRT(r)
    EMIT_INSTRUCTION, // 558 - r: FLOAT_REM(r, r)
    EMIT_INSTRUCTION, // 559 - r: DOUBLE_REM(r, r)
    EMIT_INSTRUCTION, // 560 - r: LONG_2FLOAT(r)
    EMIT_INSTRUCTION, // 561 - r: LONG_2DOUBLE(r)
    EMIT_INSTRUCTION, // 562 - r: FLOAT_MOVE(r)
    EMIT_INSTRUCTION, // 563 - r: DOUBLE_MOVE(r)
    EMIT_INSTRUCTION, // 564 - r: DOUBLE_LOAD(riv, riv)
    EMIT_INSTRUCTION, // 565 - r: DOUBLE_LOAD(riv, rlv)
    EMIT_INSTRUCTION, // 566 - r: DOUBLE_LOAD(rlv, rlv)
    EMIT_INSTRUCTION, // 567 - double_load: DOUBLE_LOAD(riv, riv)
    EMIT_INSTRUCTION, // 568 - r: DOUBLE_ALOAD(riv, riv)
    EMIT_INSTRUCTION, // 569 - r: DOUBLE_ALOAD(rlv, riv)
    EMIT_INSTRUCTION, // 570 - double_load: DOUBLE_LOAD(rlv, rlv)
    EMIT_INSTRUCTION, // 571 - r: DOUBLE_ALOAD(riv, r)
    EMIT_INSTRUCTION, // 572 - r: DOUBLE_ALOAD(rlv, rlv)
    EMIT_INSTRUCTION, // 573 - double_load: DOUBLE_ALOAD(rlv, riv)
    EMIT_INSTRUCTION, // 574 - double_load: DOUBLE_ALOAD(riv, riv)
    EMIT_INSTRUCTION, // 575 - r: FLOAT_LOAD(riv, riv)
    EMIT_INSTRUCTION, // 576 - r: FLOAT_LOAD(rlv, rlv)
    EMIT_INSTRUCTION, // 577 - float_load: FLOAT_LOAD(riv, riv)
    EMIT_INSTRUCTION, // 578 - float_load: FLOAT_ALOAD(rlv, riv)
    EMIT_INSTRUCTION, // 579 - r: FLOAT_ALOAD(riv, riv)
    EMIT_INSTRUCTION, // 580 - r: FLOAT_ALOAD(rlv, riv)
    EMIT_INSTRUCTION, // 581 - r: FLOAT_ALOAD(riv, r)
    EMIT_INSTRUCTION, // 582 - r: FLOAT_ALOAD(rlv, rlv)
    EMIT_INSTRUCTION, // 583 - float_load: FLOAT_ALOAD(riv, riv)
    EMIT_INSTRUCTION, // 584 - stm: DOUBLE_STORE(r, OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 585 - stm: DOUBLE_STORE(r, OTHER_OPERAND(riv, rlv))
    EMIT_INSTRUCTION, // 586 - stm: DOUBLE_STORE(r, OTHER_OPERAND(rlv, riv))
    EMIT_INSTRUCTION, // 587 - stm: DOUBLE_STORE(r, OTHER_OPERAND(rlv, rlv))
    EMIT_INSTRUCTION, // 588 - stm: DOUBLE_ASTORE(r, OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 589 - stm: DOUBLE_ASTORE(r, OTHER_OPERAND(rlv, riv))
    EMIT_INSTRUCTION, // 590 - stm: DOUBLE_ASTORE(r, OTHER_OPERAND(riv, rlv))
    EMIT_INSTRUCTION, // 591 - stm: DOUBLE_ASTORE(r, OTHER_OPERAND(rlv, rlv))
    EMIT_INSTRUCTION, // 592 - stm: DOUBLE_ASTORE(r, OTHER_OPERAND(r, r))
    EMIT_INSTRUCTION, // 593 - stm: FLOAT_STORE(r, OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 594 - stm: FLOAT_STORE(r, OTHER_OPERAND(rlv, rlv))
    EMIT_INSTRUCTION, // 595 - stm: FLOAT_STORE(r, OTHER_OPERAND(rlv, riv))
    EMIT_INSTRUCTION, // 596 - stm: FLOAT_STORE(r, OTHER_OPERAND(riv, rlv))
    EMIT_INSTRUCTION, // 597 - stm: FLOAT_ASTORE(r, OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 598 - stm: FLOAT_ASTORE(r, OTHER_OPERAND(rlv, riv))
    EMIT_INSTRUCTION, // 599 - stm: FLOAT_ASTORE(r, OTHER_OPERAND(riv, rlv))
    EMIT_INSTRUCTION, // 600 - stm: FLOAT_ASTORE(r, OTHER_OPERAND(rlv, rlv))
    EMIT_INSTRUCTION, // 601 - stm: FLOAT_ASTORE(r, OTHER_OPERAND(r, r))
    EMIT_INSTRUCTION, // 602 - r: INT_2FLOAT(riv)
    EMIT_INSTRUCTION, // 603 - r: INT_2FLOAT(load32)
    EMIT_INSTRUCTION, // 604 - r: INT_2DOUBLE(riv)
    EMIT_INSTRUCTION, // 605 - r: INT_2DOUBLE(load32)
    EMIT_INSTRUCTION, // 606 - r: FLOAT_2DOUBLE(r)
    EMIT_INSTRUCTION, // 607 - r: FLOAT_2DOUBLE(float_load)
    EMIT_INSTRUCTION, // 608 - r: DOUBLE_2FLOAT(r)
    EMIT_INSTRUCTION, // 609 - r: DOUBLE_2FLOAT(double_load)
    EMIT_INSTRUCTION, // 610 - r: FLOAT_2INT(r)
    EMIT_INSTRUCTION, // 611 - r: FLOAT_2LONG(r)
    EMIT_INSTRUCTION, // 612 - r: DOUBLE_2INT(r)
    EMIT_INSTRUCTION, // 613 - r: DOUBLE_2LONG(r)
    EMIT_INSTRUCTION, // 614 - r: FLOAT_AS_INT_BITS(r)
    NOFLAGS, // 615 - load32: FLOAT_AS_INT_BITS(float_load)
    EMIT_INSTRUCTION, // 616 - r: DOUBLE_AS_LONG_BITS(r)
    NOFLAGS, // 617 - load64: DOUBLE_AS_LONG_BITS(double_load)
    EMIT_INSTRUCTION, // 618 - r: INT_BITS_AS_FLOAT(riv)
    NOFLAGS, // 619 - float_load: INT_BITS_AS_FLOAT(load32)
    EMIT_INSTRUCTION, // 620 - r: LONG_BITS_AS_DOUBLE(rlv)
    NOFLAGS, // 621 - double_load: LONG_BITS_AS_DOUBLE(load64)
    EMIT_INSTRUCTION, // 622 - r: MATERIALIZE_FP_CONSTANT(any)
    EMIT_INSTRUCTION, // 623 - float_load: MATERIALIZE_FP_CONSTANT(any)
    EMIT_INSTRUCTION, // 624 - double_load: MATERIALIZE_FP_CONSTANT(any)
    EMIT_INSTRUCTION, // 625 - stm: CLEAR_FLOATING_POINT_STATE
    EMIT_INSTRUCTION, // 626 - stm: FLOAT_IFCMP(r,r)
    EMIT_INSTRUCTION, // 627 - stm: FLOAT_IFCMP(r,float_load)
    EMIT_INSTRUCTION, // 628 - stm: FLOAT_IFCMP(float_load,r)
    EMIT_INSTRUCTION, // 629 - stm: DOUBLE_IFCMP(r,r)
    EMIT_INSTRUCTION, // 630 - stm: DOUBLE_IFCMP(r,double_load)
    EMIT_INSTRUCTION, // 631 - stm: DOUBLE_IFCMP(double_load,r)
    EMIT_INSTRUCTION, // 632 - r: FCMP_CMOV(r, OTHER_OPERAND(r, any))
    EMIT_INSTRUCTION, // 633 - r: FCMP_CMOV(r, OTHER_OPERAND(float_load, any))
    EMIT_INSTRUCTION, // 634 - r: FCMP_CMOV(r, OTHER_OPERAND(double_load, any))
    EMIT_INSTRUCTION, // 635 - r: FCMP_CMOV(float_load, OTHER_OPERAND(r, any))
    EMIT_INSTRUCTION, // 636 - r: FCMP_CMOV(double_load, OTHER_OPERAND(r, any))
    EMIT_INSTRUCTION, // 637 - r: FCMP_FCMOV(r, OTHER_OPERAND(r, any))
    EMIT_INSTRUCTION, // 638 - r: FCMP_FCMOV(r, OTHER_OPERAND(r, OTHER_OPERAND(r, float_load)))
    EMIT_INSTRUCTION, // 639 - r: FCMP_FCMOV(r, OTHER_OPERAND(r, OTHER_OPERAND(r, double_load)))
    EMIT_INSTRUCTION, // 640 - r: FCMP_FCMOV(r, OTHER_OPERAND(r, OTHER_OPERAND(float_load, r)))
    EMIT_INSTRUCTION, // 641 - r: FCMP_FCMOV(r, OTHER_OPERAND(r, OTHER_OPERAND(double_load, r)))
    EMIT_INSTRUCTION, // 642 - r: FCMP_FCMOV(r, OTHER_OPERAND(float_load, any))
    EMIT_INSTRUCTION, // 643 - r: FCMP_FCMOV(r, OTHER_OPERAND(double_load, any))
    EMIT_INSTRUCTION, // 644 - r: FCMP_FCMOV(r, OTHER_OPERAND(MATERIALIZE_FP_CONSTANT(INT_CONSTANT), OTHER_OPERAND(r, FLOAT_NEG(r))))
    EMIT_INSTRUCTION, // 645 - r: FCMP_FCMOV(r, OTHER_OPERAND(MATERIALIZE_FP_CONSTANT(LONG_CONSTANT), OTHER_OPERAND(r, FLOAT_NEG(r))))
    EMIT_INSTRUCTION, // 646 - r: FCMP_FCMOV(r, OTHER_OPERAND(MATERIALIZE_FP_CONSTANT(INT_CONSTANT), OTHER_OPERAND(FLOAT_NEG(r), r)))
    EMIT_INSTRUCTION, // 647 - r: FCMP_FCMOV(r, OTHER_OPERAND(MATERIALIZE_FP_CONSTANT(LONG_CONSTANT), OTHER_OPERAND(FLOAT_NEG(r), r)))
    EMIT_INSTRUCTION, // 648 - r: FCMP_FCMOV(MATERIALIZE_FP_CONSTANT(INT_CONSTANT), OTHER_OPERAND(r, OTHER_OPERAND(FLOAT_NEG(r), r)))
    EMIT_INSTRUCTION, // 649 - r: FCMP_FCMOV(MATERIALIZE_FP_CONSTANT(LONG_CONSTANT), OTHER_OPERAND(r, OTHER_OPERAND(FLOAT_NEG(r), r)))
    EMIT_INSTRUCTION, // 650 - r: FCMP_FCMOV(MATERIALIZE_FP_CONSTANT(INT_CONSTANT), OTHER_OPERAND(r, OTHER_OPERAND(r, FLOAT_NEG(r))))
    EMIT_INSTRUCTION, // 651 - r: FCMP_FCMOV(MATERIALIZE_FP_CONSTANT(LONG_CONSTANT), OTHER_OPERAND(r, OTHER_OPERAND(r, FLOAT_NEG(r))))
    EMIT_INSTRUCTION, // 652 - r: FCMP_FCMOV(r, OTHER_OPERAND(MATERIALIZE_FP_CONSTANT(INT_CONSTANT), OTHER_OPERAND(r, DOUBLE_NEG(r))))
    EMIT_INSTRUCTION, // 653 - r: FCMP_FCMOV(r, OTHER_OPERAND(MATERIALIZE_FP_CONSTANT(LONG_CONSTANT), OTHER_OPERAND(r, DOUBLE_NEG(r))))
    EMIT_INSTRUCTION, // 654 - r: FCMP_FCMOV(r, OTHER_OPERAND(MATERIALIZE_FP_CONSTANT(INT_CONSTANT), OTHER_OPERAND(DOUBLE_NEG(r), r)))
    EMIT_INSTRUCTION, // 655 - r: FCMP_FCMOV(r, OTHER_OPERAND(MATERIALIZE_FP_CONSTANT(LONG_CONSTANT), OTHER_OPERAND(DOUBLE_NEG(r), r)))
    EMIT_INSTRUCTION, // 656 - r: FCMP_FCMOV(MATERIALIZE_FP_CONSTANT(INT_CONSTANT), OTHER_OPERAND(r, OTHER_OPERAND(DOUBLE_NEG(r), r)))
    EMIT_INSTRUCTION, // 657 - r: FCMP_FCMOV(MATERIALIZE_FP_CONSTANT(LONG_CONSTANT), OTHER_OPERAND(r, OTHER_OPERAND(DOUBLE_NEG(r), r)))
    EMIT_INSTRUCTION, // 658 - r: FCMP_FCMOV(MATERIALIZE_FP_CONSTANT(INT_CONSTANT), OTHER_OPERAND(r, OTHER_OPERAND(r, DOUBLE_NEG(r))))
    EMIT_INSTRUCTION, // 659 - r: FCMP_FCMOV(MATERIALIZE_FP_CONSTANT(LONG_CONSTANT), OTHER_OPERAND(r, OTHER_OPERAND(r, DOUBLE_NEG(r))))
    EMIT_INSTRUCTION, // 660 - stm: LONG_ASTORE(load64, OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 661 - stm: LONG_ASTORE(load64, OTHER_OPERAND(rlv, riv))
    EMIT_INSTRUCTION, // 662 - stm: LONG_STORE(load64, OTHER_OPERAND(riv, riv))
    EMIT_INSTRUCTION, // 663 - stm: LONG_STORE(load64, OTHER_OPERAND(rlv, riv))
  };

  /**
   * Gets the action flags (such as EMIT_INSTRUCTION) associated with the given
   * rule number.
   *
   * @param ruleno the rule number we want the action flags for
   * @return the action byte for the rule
   */
  @Pure
  public static byte action(int ruleno) {
    return action[unsortedErnMap[ruleno]];
  }

  /**
   * Decode the target non-terminal and minimal cost covering statement
   * into the rule that produces the non-terminal
   *
   * @param goalnt the non-terminal that we wish to produce.
   * @param stateNT the state encoding the non-terminals associated associated
   *        with covering a tree with minimal cost (computed by at compile time
   *        by jburg).
   * @return the rule number
   */
   @Pure
   public static char decode(int goalnt, int stateNT) {
     return decode[goalnt][stateNT];
   }


  /**
   * Emit code for rule number 16:
   * stm:	IG_PATCH_POINT
   * @param p BURS node to apply the rule to
   */
  private void code16(AbstractBURS_TreeNode p) {
    EMIT(InlineGuard.mutate(P(p), IG_PATCH_POINT, null, null, null, InlineGuard.getTarget(P(p)), InlineGuard.getBranchProfile(P(p))));
  }

  /**
   * Emit code for rule number 17:
   * stm:	UNINT_BEGIN
   * @param p BURS node to apply the rule to
   */
  private void code17(AbstractBURS_TreeNode p) {
    EMIT(P(p));
  }

  /**
   * Emit code for rule number 18:
   * stm:	UNINT_END
   * @param p BURS node to apply the rule to
   */
  private void code18(AbstractBURS_TreeNode p) {
    EMIT(P(p));
  }

  /**
   * Emit code for rule number 19:
   * stm:	YIELDPOINT_PROLOGUE
   * @param p BURS node to apply the rule to
   */
  private void code19(AbstractBURS_TreeNode p) {
    EMIT(P(p));
  }

  /**
   * Emit code for rule number 20:
   * stm:	YIELDPOINT_EPILOGUE
   * @param p BURS node to apply the rule to
   */
  private void code20(AbstractBURS_TreeNode p) {
    EMIT(P(p));
  }

  /**
   * Emit code for rule number 21:
   * stm:	YIELDPOINT_BACKEDGE
   * @param p BURS node to apply the rule to
   */
  private void code21(AbstractBURS_TreeNode p) {
    EMIT(P(p));
  }

  /**
   * Emit code for rule number 22:
   * r: FRAMESIZE
   * @param p BURS node to apply the rule to
   */
  private void code22(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOV, Nullary.getClearResult(P(p)), new UnknownConstantOperand()));
  }

  /**
   * Emit code for rule number 23:
   * stm:	LOWTABLESWITCH(r)
   * @param p BURS node to apply the rule to
   */
  private void code23(AbstractBURS_TreeNode p) {
    LOWTABLESWITCH(P(p));
  }

  /**
   * Emit code for rule number 24:
   * stm:	RESOLVE
   * @param p BURS node to apply the rule to
   */
  private void code24(AbstractBURS_TreeNode p) {
    RESOLVE(P(p));
  }

  /**
   * Emit code for rule number 26:
   * r:	GUARD_MOVE
   * @param p BURS node to apply the rule to
   */
  private void code26(AbstractBURS_TreeNode p) {
    EMIT(P(p));
  }

  /**
   * Emit code for rule number 27:
   * r:	GUARD_COMBINE
   * @param p BURS node to apply the rule to
   */
  private void code27(AbstractBURS_TreeNode p) {
    EMIT(P(p));
  }

  /**
   * Emit code for rule number 28:
   * stm:	NULL_CHECK(riv)
   * @param p BURS node to apply the rule to
   */
  private void code28(AbstractBURS_TreeNode p) {
    EMIT(P(p));
  }

  /**
   * Emit code for rule number 29:
   * stm:	IR_PROLOGUE
   * @param p BURS node to apply the rule to
   */
  private void code29(AbstractBURS_TreeNode p) {
    PROLOGUE(P(p));
  }

  /**
   * Emit code for rule number 30:
   * r:	GET_CAUGHT_EXCEPTION
   * @param p BURS node to apply the rule to
   */
  private void code30(AbstractBURS_TreeNode p) {
    GET_EXCEPTION_OBJECT(P(p));
  }

  /**
   * Emit code for rule number 31:
   * stm:	SET_CAUGHT_EXCEPTION(r)
   * @param p BURS node to apply the rule to
   */
  private void code31(AbstractBURS_TreeNode p) {
    SET_EXCEPTION_OBJECT(P(p));
  }

  /**
   * Emit code for rule number 32:
   * stm: SET_CAUGHT_EXCEPTION(INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code32(AbstractBURS_TreeNode p) {
    SET_EXCEPTION_OBJECT(P(p));
  }

  /**
   * Emit code for rule number 33:
   * stm: SET_CAUGHT_EXCEPTION(LONG_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code33(AbstractBURS_TreeNode p) {
    SET_EXCEPTION_OBJECT(P(p));
  }

  /**
   * Emit code for rule number 34:
   * stm:	TRAP
   * @param p BURS node to apply the rule to
   */
  private void code34(AbstractBURS_TreeNode p) {
    EMIT(MIR_Trap.mutate(P(p), IA32_INT, Trap.getGuardResult(P(p)), Trap.getTCode(P(p))));
  }

  /**
   * Emit code for rule number 35:
   * stm:	TRAP_IF(r, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code35(AbstractBURS_TreeNode p) {
    TRAP_IF_IMM(P(p), false);
  }

  /**
   * Emit code for rule number 36:
   * stm:	TRAP_IF(r, LONG_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code36(AbstractBURS_TreeNode p) {
    TRAP_IF_IMM(P(p), true);
  }

  /**
   * Emit code for rule number 37:
   * stm:	TRAP_IF(r, r)
   * @param p BURS node to apply the rule to
   */
  private void code37(AbstractBURS_TreeNode p) {
    EMIT(MIR_TrapIf.mutate(P(p), IA32_TRAPIF, 
                       TrapIf.getGuardResult(P(p)), 
		       TrapIf.getVal1(P(p)), 
		       TrapIf.getVal2(P(p)), 
		       COND(TrapIf.getCond(P(p))), 
		       TrapIf.getTCode(P(p))));
  }

  /**
   * Emit code for rule number 38:
   * stm:	TRAP_IF(load32, riv)
   * @param p BURS node to apply the rule to
   */
  private void code38(AbstractBURS_TreeNode p) {
    EMIT(MIR_TrapIf.mutate(P(p), IA32_TRAPIF, 
                       TrapIf.getGuardResult(P(p)), 
		       consumeMO(), 
		       TrapIf.getVal2(P(p)), 
		       COND(TrapIf.getCond(P(p))), 
		       TrapIf.getTCode(P(p))));
  }

  /**
   * Emit code for rule number 39:
   * stm:	TRAP_IF(riv, load32)
   * @param p BURS node to apply the rule to
   */
  private void code39(AbstractBURS_TreeNode p) {
    EMIT(MIR_TrapIf.mutate(P(p), IA32_TRAPIF, 
                       TrapIf.getGuardResult(P(p)), 
		       TrapIf.getVal1(P(p)), 
	               consumeMO(), 
		       COND(TrapIf.getCond(P(p))), 
		       TrapIf.getTCode(P(p))));
  }

  /**
   * Emit code for rule number 40:
   * uload8:	INT_AND(load8_16_32, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code40(AbstractBURS_TreeNode p) {
    pushMO(setSize(consumeMO(),1));
  }

  /**
   * Emit code for rule number 41:
   * r:	INT_AND(load8_16_32, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code41(AbstractBURS_TreeNode p) {
    EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__B, Binary.getResult(P(p)), setSize(consumeMO(),1)));
  }

  /**
   * Emit code for rule number 42:
   * r:	INT_2BYTE(load8_16_32)
   * @param p BURS node to apply the rule to
   */
  private void code42(AbstractBURS_TreeNode p) {
    EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX__B, Unary.getResult(P(p)), setSize(consumeMO(),1)));
  }

  /**
   * Emit code for rule number 43:
   * r:	INT_USHR(INT_SHL(load8_16_32, INT_CONSTANT), INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code43(AbstractBURS_TreeNode p) {
    EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__B, Binary.getResult(P(p)), setSize(consumeMO(),1)));
  }

  /**
   * Emit code for rule number 44:
   * r:	INT_AND(load16_32, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code44(AbstractBURS_TreeNode p) {
    EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__W, Binary.getResult(P(p)), setSize(consumeMO(),2)));
  }

  /**
   * Emit code for rule number 45:
   * r:	INT_USHR(INT_SHL(load16_32, INT_CONSTANT), INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code45(AbstractBURS_TreeNode p) {
    EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__W, Binary.getResult(P(p)), setSize(consumeMO(),2)));
  }

  /**
   * Emit code for rule number 46:
   * stm:	SHORT_STORE(riv, OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code46(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), W), Store.getValue(P(p))));
  }

  /**
   * Emit code for rule number 47:
   * stm:	SHORT_STORE(load16, OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code47(AbstractBURS_TreeNode p) {
    Register tmp = regpool.getInteger(); 
EMIT(CPOS(PL(p), MIR_Move.create(IA32_MOV, new RegisterOperand(tmp, TypeReference.Int), consumeMO()))); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), W), new RegisterOperand(tmp, TypeReference.Int)));
  }

  /**
   * Emit code for rule number 48:
   * stm:    SHORT_STORE(rlv, OTHER_OPERAND(rlv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code48(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), W), Store.getValue(P(p))));
  }

  /**
   * Emit code for rule number 49:
   * stm:    SHORT_STORE(riv, OTHER_OPERAND(rlv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code49(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), W), Store.getValue(P(p))));
  }

  /**
   * Emit code for rule number 50:
   * stm:	SHORT_ASTORE(riv, OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code50(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), W_S, W), AStore.getValue(P(p))));
  }

  /**
   * Emit code for rule number 51:
   * stm:	SHORT_ASTORE(load16, OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code51(AbstractBURS_TreeNode p) {
    Register tmp = regpool.getInteger(); 
EMIT(CPOS(PL(p), MIR_Move.create(IA32_MOV, new RegisterOperand(tmp, TypeReference.Int), consumeMO()))); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), W_S, W), new RegisterOperand(tmp, TypeReference.Int)));
  }

  /**
   * Emit code for rule number 52:
   * stm:	SHORT_ASTORE(riv, OTHER_OPERAND(r, r))
   * @param p BURS node to apply the rule to
   */
  private void code52(AbstractBURS_TreeNode p) {
    RegisterOperand index = AStore.getIndex(P(p)).asRegister(); 
if (VM.BuildFor64Addr && index.getRegister().isInteger()) { 
  CLEAR_UPPER_32(P(p), index.copy().asRegister()); 
  EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), W_S, W), AStore.getValue(P(p)))); 
} else { 
  EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), W_S, W), AStore.getValue(P(p)))); 
}
  }

  /**
   * Emit code for rule number 53:
   * stm:	INT_ASTORE(riv, OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code53(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), DW_S, DW), AStore.getValue(P(p))));
  }

  /**
   * Emit code for rule number 54:
   * stm:	INT_ASTORE(riv, OTHER_OPERAND(r, r))
   * @param p BURS node to apply the rule to
   */
  private void code54(AbstractBURS_TreeNode p) {
    RegisterOperand index=AStore.getIndex(P(p)).asRegister(); 
if (VM.BuildFor64Addr && index.getRegister().isInteger()) { 
  CLEAR_UPPER_32(P(p), index.copy().asRegister()); 
  EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), DW_S, DW), AStore.getValue(P(p)))); 
} else { 
  EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), DW_S, DW), AStore.getValue(P(p)))); 
}
  }

  /**
   * Emit code for rule number 55:
   * stm:	INT_ASTORE(riv, OTHER_OPERAND(rlv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code55(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), DW_S, DW), AStore.getValue(P(p))));
  }

  /**
   * Emit code for rule number 56:
   * stm:	INT_ASTORE(riv, OTHER_OPERAND(rlv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code56(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), DW_S, DW), AStore.getValue(P(p))));
  }

  /**
   * Emit code for rule number 57:
   * stm:	INT_ASTORE(riv, OTHER_OPERAND(riv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code57(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), DW_S, DW), AStore.getValue(P(p))));
  }

  /**
   * Emit code for rule number 58:
   * stm:	LONG_ASTORE(r, OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code58(AbstractBURS_TreeNode p) {
    if (VM.BuildFor32Addr){
  RegisterOperand hval = (RegisterOperand)AStore.getClearValue(P(p)); 
  hval.setType(TypeReference.Int); 
  RegisterOperand lval = new RegisterOperand(regpool.getSecondReg(hval.getRegister()), TypeReference.Int); 
  EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, MO_AS(P(p), QW_S, DW, DW).copy(), hval))); 
  EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), QW_S, DW), lval));
} else {
  EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), QW_S, QW), AStore.getValue(P(p))));
}
  }

  /**
   * Emit code for rule number 59:
   * stm:	LONG_ASTORE(r, OTHER_OPERAND(rlv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code59(AbstractBURS_TreeNode p) {
    if (VM.BuildFor32Addr) {
  RegisterOperand hval = (RegisterOperand)AStore.getClearValue(P(p)); 
  hval.setType(TypeReference.Int); 
  RegisterOperand lval = new RegisterOperand(regpool.getSecondReg(hval.getRegister()), TypeReference.Int); 
  EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, MO_AS(P(p), QW_S, DW, DW).copy(), hval))); 
  EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), QW_S, DW), lval));
} else {
  EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), QW_S, QW), AStore.getValue(P(p))));
}
  }

  /**
   * Emit code for rule number 60:
   * stm:	LONG_ASTORE(r, OTHER_OPERAND(r, r))
   * @param p BURS node to apply the rule to
   */
  private void code60(AbstractBURS_TreeNode p) {
    RegisterOperand index=AStore.getIndex(P(p)).asRegister();
if (VM.BuildFor64Addr && index.getRegister().isInteger()) { 
  CLEAR_UPPER_32(P(p), index.copy().asRegister()); 
}
if (VM.BuildFor32Addr) {
  RegisterOperand hval = (RegisterOperand)AStore.getClearValue(P(p)); 
  hval.setType(TypeReference.Int); 
  RegisterOperand lval = new RegisterOperand(regpool.getSecondReg(hval.getRegister()), TypeReference.Int); 
  EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, MO_AS(P(p), QW_S, DW, DW).copy(), hval))); 
  EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), QW_S, DW), lval));
} else {
  EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), QW_S, QW), AStore.getValue(P(p))));
}
  }

  /**
   * Emit code for rule number 61:
   * stm:	LONG_ASTORE(LONG_CONSTANT, OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code61(AbstractBURS_TreeNode p) {
    if (VM.BuildFor32Addr) {
  LongConstantOperand val = LC(AStore.getValue(P(p))); 
  EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, MO_AS(P(p), QW_S, DW, DW).copy(), IC(val.upper32())))); 
  EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), QW_S, DW), IC(val.lower32())));
} else {
  LongConstantOperand val = LC(AStore.getValue(P(p))); 
  EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), QW_S, QW), LC(val)));
}
  }

  /**
   * Emit code for rule number 62:
   * stm:	LONG_ASTORE(LONG_CONSTANT, OTHER_OPERAND(rlv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code62(AbstractBURS_TreeNode p) {
    if (VM.BuildFor32Addr) {
  LongConstantOperand val = LC(AStore.getValue(P(p))); 
  EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, MO_AS(P(p), QW_S, DW, DW).copy(), IC(val.upper32())))); 
  EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), QW_S, DW), IC(val.lower32())));
} else {
  LongConstantOperand val = LC(AStore.getValue(P(p))); 
  EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), QW_S, QW), LC(val)));
}
  }

  /**
   * Emit code for rule number 63:
   * r:	LONG_CMP(rlv,rlv)
   * @param p BURS node to apply the rule to
   */
  private void code63(AbstractBURS_TreeNode p) {
    LONG_CMP(P(p), Binary.getResult(P(p)), Binary.getVal1(P(p)), Binary.getVal2(P(p)));
  }

  /**
   * Emit code for rule number 64:
   * stm:	GOTO
   * @param p BURS node to apply the rule to
   */
  private void code64(AbstractBURS_TreeNode p) {
    EMIT(MIR_Branch.mutate(P(p), IA32_JMP, Goto.getTarget(P(p))));
  }

  /**
   * Emit code for rule number 65:
   * stm:	PREFETCH(r)
   * @param p BURS node to apply the rule to
   */
  private void code65(AbstractBURS_TreeNode p) {
    EMIT(MIR_CacheOp.mutate(P(p), IA32_PREFETCHNTA, R(CacheOp.getRef(P(p)))));
  }

  /**
   * Emit code for rule number 66:
   * stm:	WRITE_FLOOR
   * @param p BURS node to apply the rule to
   */
  private void code66(AbstractBURS_TreeNode p) {
    EMIT(P(p)); // Pass through to maintain barrier semantics for code motion
  }

  /**
   * Emit code for rule number 67:
   * stm:	READ_CEILING
   * @param p BURS node to apply the rule to
   */
  private void code67(AbstractBURS_TreeNode p) {
    EMIT(P(p)); // Pass through to maintain barrier semantics for code motion
  }

  /**
   * Emit code for rule number 68:
   * stm:	FENCE
   * @param p BURS node to apply the rule to
   */
  private void code68(AbstractBURS_TreeNode p) {
    EMIT(MIR_Empty.mutate(P(p), IA32_MFENCE));
  }

  /**
   * Emit code for rule number 69:
   * stm:	PAUSE
   * @param p BURS node to apply the rule to
   */
  private void code69(AbstractBURS_TreeNode p) {
    EMIT(MIR_Empty.mutate(P(p), IA32_PAUSE));
  }

  /**
   * Emit code for rule number 70:
   * stm:	ILLEGAL_INSTRUCTION
   * @param p BURS node to apply the rule to
   */
  private void code70(AbstractBURS_TreeNode p) {
    EMIT(MIR_Empty.mutate(P(p), IA32_UD2));
  }

  /**
   * Emit code for rule number 71:
   * stm:	RETURN(NULL)
   * @param p BURS node to apply the rule to
   */
  private void code71(AbstractBURS_TreeNode p) {
    EMIT(MIR_Return.mutate(P(p), IA32_RET, null, null, null));
  }

  /**
   * Emit code for rule number 72:
   * stm:	RETURN(INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code72(AbstractBURS_TreeNode p) {
    EMIT(MIR_Return.mutate(P(p), IA32_RET, null, Return.getVal(P(p)), null));
  }

  /**
   * Emit code for rule number 73:
   * stm:	RETURN(r)
   * @param p BURS node to apply the rule to
   */
  private void code73(AbstractBURS_TreeNode p) {
    RegisterOperand ret = R(Return.getVal(P(p)));            
RegisterOperand ret2 = null;	                            
if (VM.BuildFor32Addr && ret.getType().isLongType()) {                                 
  ret.setType(TypeReference.Int);                           
  ret2 = new RegisterOperand(regpool.getSecondReg(ret.getRegister()), TypeReference.Int); 
}                                                            
EMIT(MIR_Return.mutate(P(p), IA32_RET, null, ret, ret2));
  }

  /**
   * Emit code for rule number 74:
   * stm:	RETURN(LONG_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code74(AbstractBURS_TreeNode p) {
    LongConstantOperand val = LC(Return.getVal(P(p))); 
if (VM.BuildFor32Addr) {                           
  EMIT(MIR_Return.mutate(P(p), IA32_RET, null, IC(val.upper32()), IC(val.lower32()))); 
} else {                                           
  EMIT(MIR_Return.mutate(P(p), IA32_RET, null, val, null)); 
}
  }

  /**
   * Emit code for rule number 75:
   * r:	CALL(r, any)
   * @param p BURS node to apply the rule to
   */
  private void code75(AbstractBURS_TreeNode p) {
    CALL(P(p), Call.getAddress(P(p)));
  }

  /**
   * Emit code for rule number 76:
   * r:	CALL(BRANCH_TARGET, any)
   * @param p BURS node to apply the rule to
   */
  private void code76(AbstractBURS_TreeNode p) {
    CALL(P(p), Call.getAddress(P(p)));
  }

  /**
   * Emit code for rule number 77:
   * r:	CALL(INT_LOAD(riv, riv), any)
   * @param p BURS node to apply the rule to
   */
  private void code77(AbstractBURS_TreeNode p) {
    CALL(P(p), MO_L(PL(p), DW));
  }

  /**
   * Emit code for rule number 78:
   * r:	CALL(INT_CONSTANT, any)
   * @param p BURS node to apply the rule to
   */
  private void code78(AbstractBURS_TreeNode p) {
    RegisterOperand temp = regpool.makeTemp(TypeReference.Int); 
EMIT(MIR_Move.create(IA32_MOV, temp, Call.getAddress(P(p)))); 
CALL(P(p), temp.copyRO());
  }

  /**
   * Emit code for rule number 79:
   * r:	CALL(LONG_LOAD(rlv, rlv), any)
   * @param p BURS node to apply the rule to
   */
  private void code79(AbstractBURS_TreeNode p) {
    CALL(P(p), MO_L(PL(p), QW));
  }

  /**
   * Emit code for rule number 80:
   * r:	SYSCALL(r, any)
   * @param p BURS node to apply the rule to
   */
  private void code80(AbstractBURS_TreeNode p) {
    SYSCALL(P(p), Call.getAddress(P(p)));
  }

  /**
   * Emit code for rule number 81:
   * r:	SYSCALL(INT_LOAD(riv, riv), any)
   * @param p BURS node to apply the rule to
   */
  private void code81(AbstractBURS_TreeNode p) {
    SYSCALL(P(p), MO_L(PL(p), DW));
  }

  /**
   * Emit code for rule number 82:
   * r:	SYSCALL(INT_CONSTANT, any)
   * @param p BURS node to apply the rule to
   */
  private void code82(AbstractBURS_TreeNode p) {
    RegisterOperand temp = regpool.makeTemp(TypeReference.Int); 
EMIT(MIR_Move.create(IA32_MOV, temp, Call.getAddress(P(p)))); 
SYSCALL(P(p), temp.copyRO());
  }

  /**
   * Emit code for rule number 83:
   * r:      GET_TIME_BASE
   * @param p BURS node to apply the rule to
   */
  private void code83(AbstractBURS_TreeNode p) {
    GET_TIME_BASE(P(p), Nullary.getResult(P(p)));
  }

  /**
   * Emit code for rule number 84:
   * stm:	YIELDPOINT_OSR(any, any)
   * @param p BURS node to apply the rule to
   */
  private void code84(AbstractBURS_TreeNode p) {
    OSR(burs, P(p));
  }

  /**
   * Emit code for rule number 87:
   * address1scaledreg:	INT_SHL(r, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code87(AbstractBURS_TreeNode p) {
    pushAddress(null, Binary.getVal1(P(p)).asRegister(), LEA_SHIFT(Binary.getVal2(P(p))), Offset.zero());
  }

  /**
   * Emit code for rule number 88:
   * address1reg:	INT_ADD(r, LONG_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code88(AbstractBURS_TreeNode p) {
    pushAddress(R(Binary.getVal1(P(p))), null, B_S, Offset.fromLong(LV(Binary.getVal2(P(p)))));
  }

  /**
   * Emit code for rule number 89:
   * address1reg:	INT_MOVE(r)
   * @param p BURS node to apply the rule to
   */
  private void code89(AbstractBURS_TreeNode p) {
    pushAddress(R(Move.getVal(P(p))), null, B_S, Offset.zero());
  }

  /**
   * Emit code for rule number 90:
   * address:	INT_ADD(r, r)
   * @param p BURS node to apply the rule to
   */
  private void code90(AbstractBURS_TreeNode p) {
    pushAddress(R(Binary.getVal1(P(p))), R(Binary.getVal2(P(p))), B_S, Offset.zero());
  }

  /**
   * Emit code for rule number 91:
   * address1reg:	INT_ADD(address1reg, LONG_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code91(AbstractBURS_TreeNode p) {
    augmentAddress(Binary.getVal2(P(p)));
  }

  /**
   * Emit code for rule number 92:
   * address1scaledreg:	INT_ADD(address1scaledreg, LONG_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code92(AbstractBURS_TreeNode p) {
    augmentAddress(Binary.getVal2(P(p)));
  }

  /**
   * Emit code for rule number 93:
   * address:	INT_ADD(r, address1scaledreg)
   * @param p BURS node to apply the rule to
   */
  private void code93(AbstractBURS_TreeNode p) {
    augmentAddress(Binary.getVal1(P(p)));
  }

  /**
   * Emit code for rule number 94:
   * address:	INT_ADD(address1scaledreg, r)
   * @param p BURS node to apply the rule to
   */
  private void code94(AbstractBURS_TreeNode p) {
    augmentAddress(Binary.getVal2(P(p)));
  }

  /**
   * Emit code for rule number 95:
   * address:	INT_ADD(address1scaledreg, LONG_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code95(AbstractBURS_TreeNode p) {
    augmentAddress(Binary.getVal2(P(p)));
  }

  /**
   * Emit code for rule number 96:
   * address:	INT_ADD(address1scaledreg, address1reg)
   * @param p BURS node to apply the rule to
   */
  private void code96(AbstractBURS_TreeNode p) {
    combineAddresses();
  }

  /**
   * Emit code for rule number 97:
   * address:	INT_ADD(address1reg, address1scaledreg)
   * @param p BURS node to apply the rule to
   */
  private void code97(AbstractBURS_TreeNode p) {
    combineAddresses();
  }

  /**
   * Emit code for rule number 98:
   * address1scaledreg:	LONG_SHL(r, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code98(AbstractBURS_TreeNode p) {
    pushAddress(null, Binary.getVal1(P(p)).asRegister(), LEA_SHIFT(Binary.getVal2(P(p))), Offset.zero());
  }

  /**
   * Emit code for rule number 99:
   * address1reg:	LONG_ADD(r, LONG_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code99(AbstractBURS_TreeNode p) {
    pushAddress(R(Binary.getVal1(P(p))), null, B_S, Offset.fromLong(LV(Binary.getVal2(P(p)))));
  }

  /**
   * Emit code for rule number 100:
   * address1reg:	LONG_MOVE(r)
   * @param p BURS node to apply the rule to
   */
  private void code100(AbstractBURS_TreeNode p) {
    pushAddress(R(Move.getVal(P(p))), null, B_S, Offset.zero());
  }

  /**
   * Emit code for rule number 101:
   * address:	LONG_ADD(r, r)
   * @param p BURS node to apply the rule to
   */
  private void code101(AbstractBURS_TreeNode p) {
    pushAddress(R(Binary.getVal1(P(p))), R(Binary.getVal2(P(p))), B_S, Offset.zero());
  }

  /**
   * Emit code for rule number 102:
   * address1reg:	LONG_ADD(address1reg, LONG_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code102(AbstractBURS_TreeNode p) {
    augmentAddress(Binary.getVal2(P(p)));
  }

  /**
   * Emit code for rule number 103:
   * address1scaledreg:	LONG_ADD(address1scaledreg, LONG_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code103(AbstractBURS_TreeNode p) {
    augmentAddress(Binary.getVal2(P(p)));
  }

  /**
   * Emit code for rule number 104:
   * address:	LONG_ADD(r, address1scaledreg)
   * @param p BURS node to apply the rule to
   */
  private void code104(AbstractBURS_TreeNode p) {
    augmentAddress(Binary.getVal1(P(p)));
  }

  /**
   * Emit code for rule number 105:
   * address:	LONG_ADD(address1scaledreg, r)
   * @param p BURS node to apply the rule to
   */
  private void code105(AbstractBURS_TreeNode p) {
    augmentAddress(Binary.getVal2(P(p)));
  }

  /**
   * Emit code for rule number 106:
   * address:	LONG_ADD(address1scaledreg, LONG_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code106(AbstractBURS_TreeNode p) {
    augmentAddress(Binary.getVal2(P(p)));
  }

  /**
   * Emit code for rule number 107:
   * address:	LONG_ADD(address1scaledreg, address1reg)
   * @param p BURS node to apply the rule to
   */
  private void code107(AbstractBURS_TreeNode p) {
    combineAddresses();
  }

  /**
   * Emit code for rule number 108:
   * address:	LONG_ADD(address1reg, address1scaledreg)
   * @param p BURS node to apply the rule to
   */
  private void code108(AbstractBURS_TreeNode p) {
    combineAddresses();
  }

  /**
   * Emit code for rule number 109:
   * r:	ATTEMPT_INT(riv, OTHER_OPERAND(riv, OTHER_OPERAND(riv, riv)))
   * @param p BURS node to apply the rule to
   */
  private void code109(AbstractBURS_TreeNode p) {
    ATTEMPT_INT(Attempt.getClearResult(P(p)), 
              MO(Attempt.getClearAddress(P(p)), Attempt.getOffset(P(p)), DW, Attempt.getClearLocation(P(p)), Attempt.getClearGuard(P(p))), 
              Attempt.getClearOldValue(P(p)), Attempt.getClearNewValue(P(p)));
  }

  /**
   * Emit code for rule number 110:
   * r:	ATTEMPT_INT(riv, OTHER_OPERAND(rlv, OTHER_OPERAND(riv, riv)))
   * @param p BURS node to apply the rule to
   */
  private void code110(AbstractBURS_TreeNode p) {
    ATTEMPT_INT(Attempt.getClearResult(P(p)), 
              MO(Attempt.getClearAddress(P(p)), Attempt.getOffset(P(p)), DW, Attempt.getClearLocation(P(p)), Attempt.getClearGuard(P(p))), 
              Attempt.getClearOldValue(P(p)), Attempt.getClearNewValue(P(p)));
  }

  /**
   * Emit code for rule number 111:
   * r:	ATTEMPT_INT(rlv, OTHER_OPERAND(rlv, OTHER_OPERAND(riv, riv)))
   * @param p BURS node to apply the rule to
   */
  private void code111(AbstractBURS_TreeNode p) {
    ATTEMPT_INT(Attempt.getClearResult(P(p)), 
              MO(Attempt.getClearAddress(P(p)), Attempt.getOffset(P(p)), DW, Attempt.getClearLocation(P(p)), Attempt.getClearGuard(P(p))), 
              Attempt.getClearOldValue(P(p)), Attempt.getClearNewValue(P(p)));
  }

  /**
   * Emit code for rule number 112:
   * r:	ATTEMPT_INT(r, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv, riv)))
   * @param p BURS node to apply the rule to
   */
  private void code112(AbstractBURS_TreeNode p) {
    augmentAddress(Attempt.getClearAddress(P(p))); 
ATTEMPT_INT(Attempt.getClearResult(P(p)), 
              consumeAddress(DW, Attempt.getClearLocation(P(p)), Attempt.getClearGuard(P(p))), 
              Attempt.getClearOldValue(P(p)), Attempt.getClearNewValue(P(p)));
  }

  /**
   * Emit code for rule number 113:
   * r:	ATTEMPT_INT(address1scaledreg, OTHER_OPERAND(r, OTHER_OPERAND(riv, riv)))
   * @param p BURS node to apply the rule to
   */
  private void code113(AbstractBURS_TreeNode p) {
    augmentAddress(Attempt.getOffset(P(p))); 
ATTEMPT_INT(Attempt.getClearResult(P(p)), 
              consumeAddress(DW, Attempt.getClearLocation(P(p)), Attempt.getClearGuard(P(p))), 
              Attempt.getClearOldValue(P(p)), Attempt.getClearNewValue(P(p)));
  }

  /**
   * Emit code for rule number 114:
   * r:	ATTEMPT_INT(address1scaledreg, OTHER_OPERAND(address1reg, OTHER_OPERAND(riv, riv)))
   * @param p BURS node to apply the rule to
   */
  private void code114(AbstractBURS_TreeNode p) {
    combineAddresses(); 
ATTEMPT_INT(Attempt.getClearResult(P(p)), 
              consumeAddress(DW, Attempt.getClearLocation(P(p)), Attempt.getClearGuard(P(p))), 
              Attempt.getClearOldValue(P(p)), Attempt.getClearNewValue(P(p)));
  }

  /**
   * Emit code for rule number 115:
   * r:	ATTEMPT_INT(address1reg, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv, riv)))
   * @param p BURS node to apply the rule to
   */
  private void code115(AbstractBURS_TreeNode p) {
    combineAddresses(); 
ATTEMPT_INT(Attempt.getClearResult(P(p)), 
              consumeAddress(DW, Attempt.getClearLocation(P(p)), Attempt.getClearGuard(P(p))), 
              Attempt.getClearOldValue(P(p)), Attempt.getClearNewValue(P(p)));
  }

  /**
   * Emit code for rule number 116:
   * r:	ATTEMPT_INT(address, OTHER_OPERAND(INT_CONSTANT, OTHER_OPERAND(riv, riv)))
   * @param p BURS node to apply the rule to
   */
  private void code116(AbstractBURS_TreeNode p) {
    augmentAddress(Attempt.getOffset(P(p))); 
ATTEMPT_INT(Attempt.getClearResult(P(p)), 
              consumeAddress(DW, Attempt.getClearLocation(P(p)), Attempt.getClearGuard(P(p))), 
              Attempt.getClearOldValue(P(p)), Attempt.getClearNewValue(P(p)));
  }

  /**
   * Emit code for rule number 117:
   * r:	ATTEMPT_INT(INT_CONSTANT, OTHER_OPERAND(address, OTHER_OPERAND(riv, riv)))
   * @param p BURS node to apply the rule to
   */
  private void code117(AbstractBURS_TreeNode p) {
    augmentAddress(Attempt.getClearAddress(P(p))); 
ATTEMPT_INT(Attempt.getClearResult(P(p)), 
              consumeAddress(DW, Attempt.getClearLocation(P(p)), Attempt.getClearGuard(P(p))), 
              Attempt.getClearOldValue(P(p)), Attempt.getClearNewValue(P(p)));
  }

  /**
   * Emit code for rule number 118:
   * stm:	INT_IFCMP(ATTEMPT_INT(riv, OTHER_OPERAND(riv, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code118(AbstractBURS_TreeNode p) {
    ATTEMPT_INT_IFCMP(MO(Attempt.getAddress(PL(p)), Attempt.getOffset(PL(p)), DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), 
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), 
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));
  }

  /**
   * Emit code for rule number 119:
   * stm:	INT_IFCMP(ATTEMPT_INT(r, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code119(AbstractBURS_TreeNode p) {
    augmentAddress(Attempt.getAddress(PL(p))); 
ATTEMPT_INT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), 
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), 
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));
  }

  /**
   * Emit code for rule number 120:
   * stm:	INT_IFCMP(ATTEMPT_INT(address1scaledreg, OTHER_OPERAND(r, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code120(AbstractBURS_TreeNode p) {
    augmentAddress(Attempt.getOffset(PL(p))); 
ATTEMPT_INT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), 
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), 
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));
  }

  /**
   * Emit code for rule number 121:
   * stm:	INT_IFCMP(ATTEMPT_INT(address1scaledreg, OTHER_OPERAND(address1reg, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code121(AbstractBURS_TreeNode p) {
    combineAddresses(); 
ATTEMPT_INT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), 
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), 
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));
  }

  /**
   * Emit code for rule number 122:
   * stm:	INT_IFCMP(ATTEMPT_INT(address1reg, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code122(AbstractBURS_TreeNode p) {
    combineAddresses(); 
ATTEMPT_INT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), 
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), 
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));
  }

  /**
   * Emit code for rule number 123:
   * stm:	INT_IFCMP(ATTEMPT_INT(address, OTHER_OPERAND(INT_CONSTANT, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code123(AbstractBURS_TreeNode p) {
    augmentAddress(Attempt.getOffset(PL(p))); 
ATTEMPT_INT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), 
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), 
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));
  }

  /**
   * Emit code for rule number 124:
   * stm:	INT_IFCMP(ATTEMPT_INT(INT_CONSTANT, OTHER_OPERAND(address, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code124(AbstractBURS_TreeNode p) {
    augmentAddress(Attempt.getAddress(PL(p))); 
ATTEMPT_INT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), 
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), 
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));
  }

  /**
   * Emit code for rule number 125:
   * stm:	INT_IFCMP(ATTEMPT_INT(riv, OTHER_OPERAND(riv, OTHER_OPERAND(riv,riv))), INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code125(AbstractBURS_TreeNode p) {
    ATTEMPT_INT_IFCMP(MO(Attempt.getAddress(PL(p)), Attempt.getOffset(PL(p)), DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), 
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), 
		    IfCmp.getCond(P(p)), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));
  }

  /**
   * Emit code for rule number 126:
   * stm:	INT_IFCMP(ATTEMPT_INT(r, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code126(AbstractBURS_TreeNode p) {
    augmentAddress(Attempt.getAddress(PL(p))); 
ATTEMPT_INT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), 
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), 
		    IfCmp.getCond(P(p)), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));
  }

  /**
   * Emit code for rule number 127:
   * stm:	INT_IFCMP(ATTEMPT_INT(address1scaledreg, OTHER_OPERAND(r, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code127(AbstractBURS_TreeNode p) {
    augmentAddress(Attempt.getOffset(PL(p))); 
ATTEMPT_INT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), 
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), 
		    IfCmp.getCond(P(p)), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));
  }

  /**
   * Emit code for rule number 128:
   * stm:	INT_IFCMP(ATTEMPT_INT(address1scaledreg, OTHER_OPERAND(address1reg, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code128(AbstractBURS_TreeNode p) {
    combineAddresses(); 
ATTEMPT_INT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), 
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), 
		    IfCmp.getCond(P(p)), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));
  }

  /**
   * Emit code for rule number 129:
   * stm:	INT_IFCMP(ATTEMPT_INT(address1reg, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code129(AbstractBURS_TreeNode p) {
    combineAddresses(); 
ATTEMPT_INT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), 
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), 
		    IfCmp.getCond(P(p)), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));
  }

  /**
   * Emit code for rule number 130:
   * stm:	INT_IFCMP(ATTEMPT_INT(address, OTHER_OPERAND(INT_CONSTANT, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code130(AbstractBURS_TreeNode p) {
    augmentAddress(Attempt.getOffset(PL(p))); 
ATTEMPT_INT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), 
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), 
		    IfCmp.getCond(P(p)), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));
  }

  /**
   * Emit code for rule number 131:
   * stm:	INT_IFCMP(ATTEMPT_INT(INT_CONSTANT, OTHER_OPERAND(address, OTHER_OPERAND(riv,riv))),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code131(AbstractBURS_TreeNode p) {
    augmentAddress(Attempt.getAddress(PL(p))); 
ATTEMPT_INT_IFCMP(consumeAddress(DW, Attempt.getLocation(PL(p)), Attempt.getGuard(PL(p))), 
	            Attempt.getOldValue(PL(p)), Attempt.getNewValue(PL(p)), 
		    IfCmp.getCond(P(p)), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p)));
  }

  /**
   * Emit code for rule number 132:
   * r:	ATTEMPT_LONG(rlv, OTHER_OPERAND(rlv, OTHER_OPERAND(rlv, rlv)))
   * @param p BURS node to apply the rule to
   */
  private void code132(AbstractBURS_TreeNode p) {
    ATTEMPT_LONG(Attempt.getClearResult(P(p)), 
              MO(Attempt.getClearAddress(P(p)), Attempt.getClearOffset(P(p)), QW, Attempt.getClearLocation(P(p)), Attempt.getClearGuard(P(p))), 
              Attempt.getClearOldValue(P(p)), Attempt.getClearNewValue(P(p)));
  }

  /**
   * Emit code for rule number 133:
   * r:	ATTEMPT_LONG(r, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(rlv, rlv)))
   * @param p BURS node to apply the rule to
   */
  private void code133(AbstractBURS_TreeNode p) {
    augmentAddress(Attempt.getClearAddress(P(p))); 
ATTEMPT_LONG(Attempt.getClearResult(P(p)), 
              consumeAddress(QW, Attempt.getClearLocation(P(p)), Attempt.getClearGuard(P(p))), 
              Attempt.getClearOldValue(P(p)), Attempt.getClearNewValue(P(p)));
  }

  /**
   * Emit code for rule number 134:
   * r:	ATTEMPT_LONG(address1scaledreg, OTHER_OPERAND(r, OTHER_OPERAND(rlv, rlv)))
   * @param p BURS node to apply the rule to
   */
  private void code134(AbstractBURS_TreeNode p) {
    augmentAddress(Attempt.getOffset(P(p))); 
ATTEMPT_LONG(Attempt.getClearResult(P(p)), 
              consumeAddress(QW, Attempt.getClearLocation(P(p)), Attempt.getClearGuard(P(p))), 
              Attempt.getClearOldValue(P(p)), Attempt.getClearNewValue(P(p)));
  }

  /**
   * Emit code for rule number 135:
   * r:	ATTEMPT_LONG(address1scaledreg, OTHER_OPERAND(address1reg, OTHER_OPERAND(rlv, rlv)))
   * @param p BURS node to apply the rule to
   */
  private void code135(AbstractBURS_TreeNode p) {
    combineAddresses(); 
ATTEMPT_LONG(Attempt.getClearResult(P(p)), 
              consumeAddress(QW, Attempt.getClearLocation(P(p)), Attempt.getClearGuard(P(p))), 
              Attempt.getClearOldValue(P(p)), Attempt.getClearNewValue(P(p)));
  }

  /**
   * Emit code for rule number 136:
   * r:	ATTEMPT_LONG(address1reg, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(rlv, rlv)))
   * @param p BURS node to apply the rule to
   */
  private void code136(AbstractBURS_TreeNode p) {
    combineAddresses(); 
ATTEMPT_LONG(Attempt.getClearResult(P(p)), 
              consumeAddress(QW, Attempt.getClearLocation(P(p)), Attempt.getClearGuard(P(p))), 
              Attempt.getClearOldValue(P(p)), Attempt.getClearNewValue(P(p)));
  }

  /**
   * Emit code for rule number 137:
   * r:	ATTEMPT_LONG(address, OTHER_OPERAND(LONG_CONSTANT, OTHER_OPERAND(rlv, rlv)))
   * @param p BURS node to apply the rule to
   */
  private void code137(AbstractBURS_TreeNode p) {
    augmentAddress(Attempt.getOffset(P(p))); 
ATTEMPT_LONG(Attempt.getClearResult(P(p)), 
              consumeAddress(QW, Attempt.getClearLocation(P(p)), Attempt.getClearGuard(P(p))), 
              Attempt.getClearOldValue(P(p)), Attempt.getClearNewValue(P(p)));
  }

  /**
   * Emit code for rule number 138:
   * r:	ATTEMPT_LONG(LONG_CONSTANT, OTHER_OPERAND(address, OTHER_OPERAND(rlv, rlv)))
   * @param p BURS node to apply the rule to
   */
  private void code138(AbstractBURS_TreeNode p) {
    augmentAddress(Attempt.getClearAddress(P(p))); 
ATTEMPT_LONG(Attempt.getClearResult(P(p)), 
              consumeAddress(QW, Attempt.getClearLocation(P(p)), Attempt.getClearGuard(P(p))), 
              Attempt.getClearOldValue(P(p)), Attempt.getClearNewValue(P(p)));
  }

  /**
   * Emit code for rule number 139:
   * stm:	INT_IFCMP(ATTEMPT_LONG(rlv, OTHER_OPERAND(rlv, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code139(AbstractBURS_TreeNode p) {
    ATTEMPT_LONG_IFCMP(MO(Attempt.getClearAddress(PL(p)), Attempt.getOffset(PL(p)), QW, Attempt.getClearLocation(PL(p)), Attempt.getClearGuard(PL(p))), 
	            Attempt.getClearOldValue(PL(p)), Attempt.getClearNewValue(PL(p)), 
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getClearTarget(P(p)), IfCmp.getClearBranchProfile(P(p)));
  }

  /**
   * Emit code for rule number 140:
   * stm:	INT_IFCMP(ATTEMPT_LONG(r, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code140(AbstractBURS_TreeNode p) {
    augmentAddress(Attempt.getClearAddress(PL(p))); 
ATTEMPT_LONG_IFCMP(consumeAddress(QW, Attempt.getClearLocation(PL(p)), Attempt.getClearGuard(PL(p))), 
	            Attempt.getClearOldValue(PL(p)), Attempt.getClearNewValue(PL(p)), 
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getClearTarget(P(p)), IfCmp.getClearBranchProfile(P(p)));
  }

  /**
   * Emit code for rule number 141:
   * stm:	INT_IFCMP(ATTEMPT_LONG(address1scaledreg, OTHER_OPERAND(r, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code141(AbstractBURS_TreeNode p) {
    augmentAddress(Attempt.getOffset(PL(p))); 
ATTEMPT_LONG_IFCMP(consumeAddress(QW, Attempt.getClearLocation(PL(p)), Attempt.getClearGuard(PL(p))), 
	            Attempt.getClearOldValue(PL(p)), Attempt.getClearNewValue(PL(p)), 
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getClearTarget(P(p)), IfCmp.getClearBranchProfile(P(p)));
  }

  /**
   * Emit code for rule number 142:
   * stm:	INT_IFCMP(ATTEMPT_LONG(address1scaledreg, OTHER_OPERAND(address1reg, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code142(AbstractBURS_TreeNode p) {
    combineAddresses(); 
ATTEMPT_LONG_IFCMP(consumeAddress(QW, Attempt.getClearLocation(PL(p)), Attempt.getClearGuard(PL(p))), 
	            Attempt.getClearOldValue(PL(p)), Attempt.getClearNewValue(PL(p)), 
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getClearTarget(P(p)), IfCmp.getClearBranchProfile(P(p)));
  }

  /**
   * Emit code for rule number 143:
   * stm:	INT_IFCMP(ATTEMPT_LONG(address1reg, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code143(AbstractBURS_TreeNode p) {
    combineAddresses(); 
ATTEMPT_LONG_IFCMP(consumeAddress(QW, Attempt.getClearLocation(PL(p)), Attempt.getClearGuard(PL(p))), 
	            Attempt.getClearOldValue(PL(p)), Attempt.getClearNewValue(PL(p)), 
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getClearTarget(P(p)), IfCmp.getClearBranchProfile(P(p)));
  }

  /**
   * Emit code for rule number 144:
   * stm:	INT_IFCMP(ATTEMPT_LONG(address, OTHER_OPERAND(LONG_CONSTANT, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code144(AbstractBURS_TreeNode p) {
    augmentAddress(Attempt.getOffset(PL(p))); 
ATTEMPT_LONG_IFCMP(consumeAddress(QW, Attempt.getClearLocation(PL(p)), Attempt.getClearGuard(PL(p))), 
	            Attempt.getClearOldValue(PL(p)), Attempt.getClearNewValue(PL(p)), 
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getClearTarget(P(p)), IfCmp.getClearBranchProfile(P(p)));
  }

  /**
   * Emit code for rule number 145:
   * stm:	INT_IFCMP(ATTEMPT_LONG(LONG_CONSTANT, OTHER_OPERAND(address, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code145(AbstractBURS_TreeNode p) {
    augmentAddress(Attempt.getClearAddress(PL(p))); 
ATTEMPT_LONG_IFCMP(consumeAddress(QW, Attempt.getClearLocation(PL(p)), Attempt.getClearGuard(PL(p))), 
	            Attempt.getClearOldValue(PL(p)), Attempt.getClearNewValue(PL(p)), 
		    IfCmp.getCond(P(p)).flipCode(), IfCmp.getClearTarget(P(p)), IfCmp.getClearBranchProfile(P(p)));
  }

  /**
   * Emit code for rule number 146:
   * stm:	INT_IFCMP(ATTEMPT_LONG(rlv, OTHER_OPERAND(rlv, OTHER_OPERAND(rlv,rlv))), INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code146(AbstractBURS_TreeNode p) {
    ATTEMPT_LONG_IFCMP(MO(Attempt.getClearAddress(PL(p)), Attempt.getOffset(PL(p)), QW, Attempt.getClearLocation(PL(p)), Attempt.getClearGuard(PL(p))), 
	            Attempt.getClearOldValue(PL(p)), Attempt.getClearNewValue(PL(p)), 
		    IfCmp.getCond(P(p)), IfCmp.getClearTarget(P(p)), IfCmp.getClearBranchProfile(P(p)));
  }

  /**
   * Emit code for rule number 147:
   * stm:	INT_IFCMP(ATTEMPT_LONG(r, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code147(AbstractBURS_TreeNode p) {
    augmentAddress(Attempt.getClearAddress(PL(p))); 
ATTEMPT_LONG_IFCMP(consumeAddress(QW, Attempt.getClearLocation(PL(p)), Attempt.getClearGuard(PL(p))), 
	            Attempt.getClearOldValue(PL(p)), Attempt.getClearNewValue(PL(p)), 
		    IfCmp.getCond(P(p)), IfCmp.getClearTarget(P(p)), IfCmp.getClearBranchProfile(P(p)));
  }

  /**
   * Emit code for rule number 148:
   * stm:	INT_IFCMP(ATTEMPT_LONG(address1scaledreg, OTHER_OPERAND(r, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code148(AbstractBURS_TreeNode p) {
    augmentAddress(Attempt.getOffset(PL(p))); 
ATTEMPT_LONG_IFCMP(consumeAddress(QW, Attempt.getClearLocation(PL(p)), Attempt.getClearGuard(PL(p))), 
	            Attempt.getClearOldValue(PL(p)), Attempt.getClearNewValue(PL(p)), 
		    IfCmp.getCond(P(p)), IfCmp.getClearTarget(P(p)), IfCmp.getClearBranchProfile(P(p)));
  }

  /**
   * Emit code for rule number 149:
   * stm:	INT_IFCMP(ATTEMPT_LONG(address1scaledreg, OTHER_OPERAND(address1reg, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code149(AbstractBURS_TreeNode p) {
    combineAddresses(); 
ATTEMPT_LONG_IFCMP(consumeAddress(QW, Attempt.getClearLocation(PL(p)), Attempt.getClearGuard(PL(p))), 
	            Attempt.getClearOldValue(PL(p)), Attempt.getClearNewValue(PL(p)), 
		    IfCmp.getCond(P(p)), IfCmp.getClearTarget(P(p)), IfCmp.getClearBranchProfile(P(p)));
  }

  /**
   * Emit code for rule number 150:
   * stm:	INT_IFCMP(ATTEMPT_LONG(address1reg, OTHER_OPERAND(address1scaledreg, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code150(AbstractBURS_TreeNode p) {
    combineAddresses(); 
ATTEMPT_LONG_IFCMP(consumeAddress(QW, Attempt.getClearLocation(PL(p)), Attempt.getClearGuard(PL(p))), 
	            Attempt.getClearOldValue(PL(p)), Attempt.getClearNewValue(PL(p)), 
		    IfCmp.getCond(P(p)), IfCmp.getClearTarget(P(p)), IfCmp.getClearBranchProfile(P(p)));
  }

  /**
   * Emit code for rule number 151:
   * stm:	INT_IFCMP(ATTEMPT_LONG(address, OTHER_OPERAND(LONG_CONSTANT, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code151(AbstractBURS_TreeNode p) {
    augmentAddress(Attempt.getOffset(PL(p))); 
ATTEMPT_LONG_IFCMP(consumeAddress(QW, Attempt.getClearLocation(PL(p)), Attempt.getClearGuard(PL(p))), 
	            Attempt.getClearOldValue(PL(p)), Attempt.getClearNewValue(PL(p)), 
		    IfCmp.getCond(P(p)), IfCmp.getClearTarget(P(p)), IfCmp.getClearBranchProfile(P(p)));
  }

  /**
   * Emit code for rule number 152:
   * stm:	INT_IFCMP(ATTEMPT_LONG(LONG_CONSTANT, OTHER_OPERAND(address, OTHER_OPERAND(rlv,rlv))),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code152(AbstractBURS_TreeNode p) {
    augmentAddress(Attempt.getClearAddress(PL(p))); 
ATTEMPT_LONG_IFCMP(consumeAddress(QW, Attempt.getClearLocation(PL(p)), Attempt.getClearGuard(PL(p))), 
	            Attempt.getClearOldValue(PL(p)), Attempt.getClearNewValue(PL(p)), 
		    IfCmp.getCond(P(p)), IfCmp.getClearTarget(P(p)), IfCmp.getClearBranchProfile(P(p)));
  }

  /**
   * Emit code for rule number 153:
   * bittest:	INT_AND(INT_USHR(r,INT_AND(r,INT_CONSTANT)),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code153(AbstractBURS_TreeNode p) {
    EMIT(MIR_Test.mutate(P(p), IA32_BT, Binary.getVal1(PL(p)).copy(), Binary.getVal1(PLR(p)).copy()));
  }

  /**
   * Emit code for rule number 154:
   * bittest:	INT_AND(INT_USHR(load32,INT_AND(r,INT_CONSTANT)),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code154(AbstractBURS_TreeNode p) {
    Register tmp = regpool.getInteger(); 
if (VM.VerifyAssertions) VM._assert((VLRR(p) & 0x7FFFFFFF) <= 31); 
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(tmp, TypeReference.Int), Binary.getVal1(PLR(p))))); 
EMIT(CPOS(P(p), MIR_BinaryAcc.create(IA32_AND, new RegisterOperand(tmp, TypeReference.Int), IC(VLRR(p))))); 
EMIT(MIR_Test.mutate(P(p), IA32_BT, consumeMO(), new RegisterOperand(tmp, TypeReference.Int)));
  }

  /**
   * Emit code for rule number 155:
   * bittest:	INT_AND(INT_USHR(r,INT_CONSTANT),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code155(AbstractBURS_TreeNode p) {
    EMIT(MIR_Test.mutate(P(p), IA32_BT, Binary.getVal1(PL(p)).copy(), IC(VLR(p))));
  }

  /**
   * Emit code for rule number 156:
   * bittest:	INT_AND(INT_SHR(r,INT_AND(r,INT_CONSTANT)),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code156(AbstractBURS_TreeNode p) {
    EMIT(MIR_Test.mutate(P(p), IA32_BT, Binary.getVal1(PL(p)).copy(), Binary.getVal1(PLR(p)).copy()));
  }

  /**
   * Emit code for rule number 157:
   * bittest:	INT_AND(INT_SHR(load32,INT_AND(r,INT_CONSTANT)),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code157(AbstractBURS_TreeNode p) {
    Register tmp = regpool.getInteger(); 
if (VM.VerifyAssertions) VM._assert((VLRR(p) & 0x7FFFFFFF) <= 31); 
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(tmp, TypeReference.Int), Binary.getVal1(PLR(p))))); 
EMIT(CPOS(P(p), MIR_BinaryAcc.create(IA32_AND, new RegisterOperand(tmp, TypeReference.Int), IC(VLRR(p))))); 
EMIT(MIR_Test.mutate(P(p), IA32_BT, consumeMO(), new RegisterOperand(tmp, TypeReference.Int)));
  }

  /**
   * Emit code for rule number 158:
   * bittest:	INT_AND(INT_SHR(r,INT_CONSTANT),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code158(AbstractBURS_TreeNode p) {
    EMIT(MIR_Test.mutate(P(p), IA32_BT, Binary.getVal1(PL(p)).copy(), IC(VLR(p))));
  }

  /**
   * Emit code for rule number 159:
   * bittest:	INT_AND(INT_SHL(INT_CONSTANT,INT_AND(riv,INT_CONSTANT)),r)
   * @param p BURS node to apply the rule to
   */
  private void code159(AbstractBURS_TreeNode p) {
    EMIT(MIR_Test.mutate(P(p), IA32_BT, Binary.getVal2(P(p)), Binary.getVal1(PLR(p)).copy()));
  }

  /**
   * Emit code for rule number 160:
   * bittest:	INT_AND(INT_SHL(INT_CONSTANT,INT_AND(r, INT_CONSTANT)),load32)
   * @param p BURS node to apply the rule to
   */
  private void code160(AbstractBURS_TreeNode p) {
    Register tmp = regpool.getInteger(); 
if (VM.VerifyAssertions) VM._assert((VLRR(p) & 0x7FFFFFFF) <= 31); 
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(tmp, TypeReference.Int), Binary.getVal1(PLR(p))))); 
EMIT(CPOS(P(p), MIR_BinaryAcc.create(IA32_AND, new RegisterOperand(tmp, TypeReference.Int), IC(VLRR(p))))); 
EMIT(MIR_Test.mutate(P(p), IA32_BT, consumeMO(), new RegisterOperand(tmp, TypeReference.Int)));
  }

  /**
   * Emit code for rule number 161:
   * bittest:	INT_AND(r,INT_SHL(INT_CONSTANT,INT_AND(r, INT_CONSTANT)))
   * @param p BURS node to apply the rule to
   */
  private void code161(AbstractBURS_TreeNode p) {
    EMIT(MIR_Test.mutate(P(p), IA32_BT, Binary.getVal1(P(p)), Binary.getVal1(PRR(p)).copy()));
  }

  /**
   * Emit code for rule number 162:
   * bittest:	INT_AND(load32,INT_SHL(INT_CONSTANT,INT_AND(r, INT_CONSTANT)))
   * @param p BURS node to apply the rule to
   */
  private void code162(AbstractBURS_TreeNode p) {
    Register tmp = regpool.getInteger(); 
if (VM.VerifyAssertions) VM._assert((VRRR(p) & 0x7FFFFFFF) <= 31); 
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(tmp, TypeReference.Int), Binary.getVal1(PRR(p))))); 
EMIT(CPOS(P(p), MIR_BinaryAcc.create(IA32_AND, new RegisterOperand(tmp, TypeReference.Int), IC(VRRR(p))))); 
EMIT(MIR_Test.mutate(P(p), IA32_BT, consumeMO(), new RegisterOperand(tmp, TypeReference.Int)));
  }

  /**
   * Emit code for rule number 163:
   * r:	BOOLEAN_CMP_INT(r,riv)
   * @param p BURS node to apply the rule to
   */
  private void code163(AbstractBURS_TreeNode p) {
    BOOLEAN_CMP_INT(P(p), BooleanCmp.getResult(P(p)), 
   BooleanCmp.getClearVal1(P(p)), BooleanCmp.getClearVal2(P(p)), 
   BooleanCmp.getCond(P(p)));
  }

  /**
   * Emit code for rule number 164:
   * boolcmp: BOOLEAN_CMP_INT(r,riv)
   * @param p BURS node to apply the rule to
   */
  private void code164(AbstractBURS_TreeNode p) {
    ConditionOperand cond = BooleanCmp.getCond(P(p)); 
pushCOND(cond); 
EMIT_Compare(P(p), cond, BooleanCmp.getClearVal1(P(p)), BooleanCmp.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 165:
   * r:	BOOLEAN_CMP_INT(r,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code165(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p),MIR_Test.create(IA32_TEST, BooleanCmp.getVal1(P(p)).copy(), BooleanCmp.getClearVal1(P(p)))));
BOOLEAN_CMP_INT(P(p), BooleanCmp.getResult(P(p)), BooleanCmp.getCond(P(p)));
  }

  /**
   * Emit code for rule number 166:
   * boolcmp: BOOLEAN_CMP_INT(r,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code166(AbstractBURS_TreeNode p) {
    pushCOND(BooleanCmp.getCond(P(p))); 
EMIT(CPOS(P(p),MIR_Test.create(IA32_TEST, BooleanCmp.getVal1(P(p)).copy(), BooleanCmp.getClearVal1(P(p)))));
  }

  /**
   * Emit code for rule number 167:
   * r:	BOOLEAN_CMP_INT(r,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code167(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_SHR, P(p), BooleanCmp.getResult(P(p)), BooleanCmp.getClearVal1(P(p)), IC(31));
  }

  /**
   * Emit code for rule number 168:
   * r:	BOOLEAN_CMP_INT(load32,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code168(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_SHR, P(p), BooleanCmp.getResult(P(p)), consumeMO(), IC(31));
  }

  /**
   * Emit code for rule number 169:
   * r:	BOOLEAN_CMP_INT(r,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code169(AbstractBURS_TreeNode p) {
    RegisterOperand result = BooleanCmp.getResult(P(p)); 
EMIT_Commutative(IA32_SHR, P(p), result, BooleanCmp.getClearVal1(P(p)), IC(31)); 
EMIT(CPOS(P(p),MIR_BinaryAcc.create(IA32_XOR, result.copyRO(), IC(1))));
  }

  /**
   * Emit code for rule number 170:
   * r:	BOOLEAN_CMP_INT(load32,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code170(AbstractBURS_TreeNode p) {
    RegisterOperand result = BooleanCmp.getResult(P(p)); 
EMIT_Commutative(IA32_SHR, P(p), result, consumeMO(), IC(31)); 
EMIT(CPOS(P(p),MIR_BinaryAcc.create(IA32_XOR, result.copyRO(), IC(1))));
  }

  /**
   * Emit code for rule number 171:
   * r:	BOOLEAN_CMP_INT(cz, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code171(AbstractBURS_TreeNode p) {
    BOOLEAN_CMP_INT(P(p), BooleanCmp.getResult(P(p)), BooleanCmp.getCond(P(p)));
  }

  /**
   * Emit code for rule number 172:
   * boolcmp: BOOLEAN_CMP_INT(cz, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code172(AbstractBURS_TreeNode p) {
    pushCOND(BooleanCmp.getCond(P(p)));
  }

  /**
   * Emit code for rule number 173:
   * r:	BOOLEAN_CMP_INT(szp, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code173(AbstractBURS_TreeNode p) {
    BOOLEAN_CMP_INT(P(p), BooleanCmp.getResult(P(p)), BooleanCmp.getCond(P(p)));
  }

  /**
   * Emit code for rule number 174:
   * boolcmp: BOOLEAN_CMP_INT(szp, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code174(AbstractBURS_TreeNode p) {
    pushCOND(BooleanCmp.getCond(P(p)));
  }

  /**
   * Emit code for rule number 175:
   * r:	BOOLEAN_CMP_INT(bittest, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code175(AbstractBURS_TreeNode p) {
    BOOLEAN_CMP_INT(P(p), BooleanCmp.getResult(P(p)), BIT_TEST(VR(p),BooleanCmp.getCond(P(p))));
  }

  /**
   * Emit code for rule number 176:
   * boolcmp:	BOOLEAN_CMP_INT(bittest, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code176(AbstractBURS_TreeNode p) {
    pushCOND(BIT_TEST(VR(p),BooleanCmp.getCond(P(p))));
  }

  /**
   * Emit code for rule number 177:
   * r:	BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code177(AbstractBURS_TreeNode p) {
    BOOLEAN_CMP_INT(P(p), BooleanCmp.getResult(P(p)), consumeCOND());
  }

  /**
   * Emit code for rule number 179:
   * r:	BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code179(AbstractBURS_TreeNode p) {
    BOOLEAN_CMP_INT(P(p), BooleanCmp.getResult(P(p)), consumeCOND().flipCode());
  }

  /**
   * Emit code for rule number 180:
   * boolcmp:	BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code180(AbstractBURS_TreeNode p) {
    pushCOND(consumeCOND().flipCode()); // invert already pushed condition
  }

  /**
   * Emit code for rule number 181:
   * r:	BOOLEAN_CMP_INT(load32,riv)
   * @param p BURS node to apply the rule to
   */
  private void code181(AbstractBURS_TreeNode p) {
    BOOLEAN_CMP_INT(PL(p), BooleanCmp.getClearResult(P(p)), 
            consumeMO(), BooleanCmp.getClearVal2(P(p)), 
	    BooleanCmp.getCond(P(p)));
  }

  /**
   * Emit code for rule number 182:
   * boolcmp: BOOLEAN_CMP_INT(load32,riv)
   * @param p BURS node to apply the rule to
   */
  private void code182(AbstractBURS_TreeNode p) {
    ConditionOperand cond = BooleanCmp.getCond(P(p)); 
pushCOND(cond); 
EMIT_Compare(P(p), cond, consumeMO(), BooleanCmp.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 183:
   * r:	BOOLEAN_CMP_INT(r,load32)
   * @param p BURS node to apply the rule to
   */
  private void code183(AbstractBURS_TreeNode p) {
    BOOLEAN_CMP_INT(PR(p), BooleanCmp.getClearResult(P(p)), 
            BooleanCmp.getClearVal1(P(p)), consumeMO(), 
	    BooleanCmp.getCond(P(p)));
  }

  /**
   * Emit code for rule number 184:
   * boolcmp: BOOLEAN_CMP_INT(riv,load32)
   * @param p BURS node to apply the rule to
   */
  private void code184(AbstractBURS_TreeNode p) {
    ConditionOperand cond = BooleanCmp.getCond(P(p)); 
pushCOND(cond); 
EMIT_Compare(P(p), cond, BooleanCmp.getClearVal1(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 185:
   * stm:	BYTE_STORE(boolcmp, OTHER_OPERAND(riv,riv))
   * @param p BURS node to apply the rule to
   */
  private void code185(AbstractBURS_TreeNode p) {
    EMIT(MIR_Set.mutate(P(p), IA32_SET__B, MO_S(P(p),B), COND(consumeCOND())));
  }

  /**
   * Emit code for rule number 186:
   * stm:	BYTE_ASTORE(boolcmp, OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code186(AbstractBURS_TreeNode p) {
    EMIT(MIR_Set.mutate(P(p), IA32_SET__B, MO_AS(P(p),B_S,B), COND(consumeCOND())));
  }

  /**
   * Emit code for rule number 187:
   * r:	BOOLEAN_CMP_LONG(r,rlv)
   * @param p BURS node to apply the rule to
   */
  private void code187(AbstractBURS_TreeNode p) {
    BOOLEAN_CMP_INT(P(p), BooleanCmp.getClearResult(P(p)), 
   BooleanCmp.getClearVal1(P(p)), BooleanCmp.getClearVal2(P(p)), 
   BooleanCmp.getCond(P(p)));
  }

  /**
   * Emit code for rule number 188:
   * boolcmp: BOOLEAN_CMP_LONG(r,rlv)
   * @param p BURS node to apply the rule to
   */
  private void code188(AbstractBURS_TreeNode p) {
    ConditionOperand cond = BooleanCmp.getCond(P(p)); 
pushCOND(cond); 
EMIT_Compare(P(p), cond, BooleanCmp.getClearVal1(P(p)), BooleanCmp.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 189:
   * r:	BOOLEAN_CMP_LONG(r,LONG_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code189(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p),MIR_Test.create(IA32_TEST, BooleanCmp.getVal1(P(p)).copy(), BooleanCmp.getClearVal1(P(p)))));
BOOLEAN_CMP_INT(P(p), BooleanCmp.getClearResult(P(p)), BooleanCmp.getCond(P(p)));
  }

  /**
   * Emit code for rule number 190:
   * boolcmp: BOOLEAN_CMP_LONG(r,LONG_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code190(AbstractBURS_TreeNode p) {
    pushCOND(BooleanCmp.getCond(P(p))); 
EMIT(CPOS(P(p),MIR_Test.create(IA32_TEST, BooleanCmp.getVal1(P(p)).copy(), BooleanCmp.getClearVal1(P(p)))));
  }

  /**
   * Emit code for rule number 191:
   * r:	BOOLEAN_CMP_LONG(r,LONG_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code191(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_SHR, P(p), BooleanCmp.getClearResult(P(p)), BooleanCmp.getClearVal1(P(p)), IC(63));
  }

  /**
   * Emit code for rule number 192:
   * r:	BOOLEAN_CMP_LONG(load64,LONG_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code192(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_SHR, P(p), BooleanCmp.getClearResult(P(p)), consumeMO(), IC(63));
  }

  /**
   * Emit code for rule number 193:
   * r:	BOOLEAN_CMP_LONG(r,LONG_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code193(AbstractBURS_TreeNode p) {
    RegisterOperand result = BooleanCmp.getClearResult(P(p)); 
EMIT_Commutative(IA32_SHR, P(p), result, BooleanCmp.getClearVal1(P(p)), IC(63)); 
EMIT(CPOS(P(p),MIR_BinaryAcc.create(IA32_XOR, result.copyRO(), IC(1))));
  }

  /**
   * Emit code for rule number 194:
   * r:	BOOLEAN_CMP_LONG(load64,LONG_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code194(AbstractBURS_TreeNode p) {
    RegisterOperand result = BooleanCmp.getClearResult(P(p)); 
EMIT_Commutative(IA32_SHR, P(p), result, consumeMO(), IC(63)); 
EMIT(CPOS(P(p),MIR_BinaryAcc.create(IA32_XOR, result.copyRO(), IC(1))));
  }

  /**
   * Emit code for rule number 195:
   * r:	BOOLEAN_CMP_LONG(cz, LONG_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code195(AbstractBURS_TreeNode p) {
    BOOLEAN_CMP_INT(P(p), BooleanCmp.getClearResult(P(p)), BooleanCmp.getCond(P(p)));
  }

  /**
   * Emit code for rule number 196:
   * r:	BOOLEAN_CMP_LONG(load64,rlv)
   * @param p BURS node to apply the rule to
   */
  private void code196(AbstractBURS_TreeNode p) {
    BOOLEAN_CMP_INT(PL(p), BooleanCmp.getClearResult(P(p)), 
            consumeMO(), BooleanCmp.getClearVal2(P(p)), 
	    BooleanCmp.getCond(P(p)));
  }

  /**
   * Emit code for rule number 197:
   * boolcmp: BOOLEAN_CMP_LONG(load64,rlv)
   * @param p BURS node to apply the rule to
   */
  private void code197(AbstractBURS_TreeNode p) {
    ConditionOperand cond = BooleanCmp.getCond(P(p)); 
pushCOND(cond); 
EMIT_Compare(P(p), cond, consumeMO(), BooleanCmp.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 198:
   * r:	BOOLEAN_CMP_LONG(r,load64)
   * @param p BURS node to apply the rule to
   */
  private void code198(AbstractBURS_TreeNode p) {
    BOOLEAN_CMP_INT(PR(p), BooleanCmp.getClearResult(P(p)), 
            BooleanCmp.getClearVal1(P(p)), consumeMO(), 
	    BooleanCmp.getCond(P(p)));
  }

  /**
   * Emit code for rule number 199:
   * boolcmp: BOOLEAN_CMP_LONG(rlv,load64)
   * @param p BURS node to apply the rule to
   */
  private void code199(AbstractBURS_TreeNode p) {
    ConditionOperand cond = BooleanCmp.getCond(P(p)); 
pushCOND(cond); 
EMIT_Compare(P(p), cond, BooleanCmp.getClearVal1(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 200:
   * r:	BOOLEAN_NOT(r)
   * @param p BURS node to apply the rule to
   */
  private void code200(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_XOR, P(p), Unary.getClearResult(P(p)), Unary.getClearVal(P(p)), IC(1));
  }

  /**
   * Emit code for rule number 201:
   * stm:	BYTE_STORE(BOOLEAN_NOT(UBYTE_LOAD(rlv,rlv)),OTHER_OPERAND(rlv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code201(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_XOR, P(p), MO_S(P(p), B), MO_S(P(p), B), IC(1));
  }

  /**
   * Emit code for rule number 202:
   * stm:	BYTE_ASTORE(BOOLEAN_NOT(UBYTE_ALOAD(rlv,riv)),OTHER_OPERAND(rlv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code202(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_XOR, P(p), MO_AS(P(p), B_S, B), MO_AS(P(p), B_S, B), IC(1));
  }

  /**
   * Emit code for rule number 203:
   * stm:    BYTE_STORE(riv, OTHER_OPERAND(rlv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code203(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), B), Store.getValue(P(p))));
  }

  /**
   * Emit code for rule number 204:
   * stm:    BYTE_STORE(load8, OTHER_OPERAND(rlv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code204(AbstractBURS_TreeNode p) {
    Register tmp = regpool.getInteger(); 
EMIT(CPOS(PL(p), MIR_Move.create(IA32_MOV, new RegisterOperand(tmp, TypeReference.Int), consumeMO()))); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), B), new RegisterOperand(tmp, TypeReference.Int)));
  }

  /**
   * Emit code for rule number 205:
   * stm:    BYTE_ASTORE(riv, OTHER_OPERAND(rlv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code205(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), B_S, B), AStore.getValue(P(p))));
  }

  /**
   * Emit code for rule number 206:
   * stm:    BYTE_ASTORE(load8, OTHER_OPERAND(rlv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code206(AbstractBURS_TreeNode p) {
    Register tmp = regpool.getInteger(); 
EMIT(CPOS(PL(p), MIR_Move.create(IA32_MOV, new RegisterOperand(tmp, TypeReference.Int), consumeMO()))); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), B_S, B), new RegisterOperand(tmp, TypeReference.Int)));
  }

  /**
   * Emit code for rule number 207:
   * r: CMP_CMOV(r, OTHER_OPERAND(riv, any))
   * @param p BURS node to apply the rule to
   */
  private void code207(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP,  CondMove.getClearVal1(P(p)), CondMove.getClearVal2(P(p))))); 
CMOV_MOV(P(p), CondMove.getClearResult(P(p)), CondMove.getClearCond(P(p)), 
         CondMove.getClearTrueValue(P(p)), CondMove.getClearFalseValue(P(p)));
  }

  /**
   * Emit code for rule number 208:
   * r: CMP_CMOV(r, OTHER_OPERAND(INT_CONSTANT, any))
   * @param p BURS node to apply the rule to
   */
  private void code208(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Test.create(IA32_TEST, CondMove.getVal1(P(p)).copy(), CondMove.getClearVal1(P(p))))); 
CMOV_MOV(P(p), CondMove.getClearResult(P(p)), CondMove.getClearCond(P(p)), 
         CondMove.getClearTrueValue(P(p)), CondMove.getClearFalseValue(P(p)));
  }

  /**
   * Emit code for rule number 209:
   * r: CMP_CMOV(r, OTHER_OPERAND(INT_CONSTANT, OTHER_OPERAND(INT_CONSTANT, INT_CONSTANT)))
   * @param p BURS node to apply the rule to
   */
  private void code209(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_SAR, P(p), CondMove.getClearResult(P(p)), CondMove.getClearVal1(P(p)), IC(31));
  }

  /**
   * Emit code for rule number 210:
   * r: CMP_CMOV(load32, OTHER_OPERAND(INT_CONSTANT, OTHER_OPERAND(INT_CONSTANT, INT_CONSTANT)))
   * @param p BURS node to apply the rule to
   */
  private void code210(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_SAR, P(p), CondMove.getClearResult(P(p)), consumeMO(), IC(31));
  }

  /**
   * Emit code for rule number 211:
   * r: CMP_CMOV(r, OTHER_OPERAND(INT_CONSTANT, OTHER_OPERAND(INT_CONSTANT, INT_CONSTANT)))
   * @param p BURS node to apply the rule to
   */
  private void code211(AbstractBURS_TreeNode p) {
    RegisterOperand result = CondMove.getClearResult(P(p)); 
EMIT_Commutative(IA32_SAR, P(p), result, CondMove.getClearVal1(P(p)), IC(31)); 
EMIT(CPOS(P(p),MIR_UnaryAcc.create(IA32_NOT, result.copyRO())));
  }

  /**
   * Emit code for rule number 212:
   * r: CMP_CMOV(load32, OTHER_OPERAND(INT_CONSTANT, OTHER_OPERAND(INT_CONSTANT, INT_CONSTANT)))
   * @param p BURS node to apply the rule to
   */
  private void code212(AbstractBURS_TreeNode p) {
    RegisterOperand result = CondMove.getClearResult(P(p)); 
EMIT_Commutative(IA32_SAR, P(p), result, consumeMO(), IC(31)); 
EMIT(CPOS(P(p),MIR_UnaryAcc.create(IA32_NOT, result.copyRO())));
  }

  /**
   * Emit code for rule number 213:
   * r: CMP_CMOV(load8, OTHER_OPERAND(INT_CONSTANT, any))
   * @param p BURS node to apply the rule to
   */
  private void code213(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, consumeMO(), CondMove.getClearVal2(P(p))))); 
CMOV_MOV(P(p), CondMove.getClearResult(P(p)), CondMove.getClearCond(P(p)), 
         CondMove.getClearTrueValue(P(p)), CondMove.getClearFalseValue(P(p)));
  }

  /**
   * Emit code for rule number 214:
   * r: CMP_CMOV(uload8, OTHER_OPERAND(riv, any))
   * @param p BURS node to apply the rule to
   */
  private void code214(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, consumeMO(), CondMove.getClearVal2(P(p))))); 
CMOV_MOV(P(p), CondMove.getClearResult(P(p)), CondMove.getClearCond(P(p)), 
         CondMove.getClearTrueValue(P(p)), CondMove.getClearFalseValue(P(p)));
  }

  /**
   * Emit code for rule number 215:
   * r: CMP_CMOV(riv, OTHER_OPERAND(uload8, any))
   * @param p BURS node to apply the rule to
   */
  private void code215(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, consumeMO(), CondMove.getClearVal2(P(p))))); 
CMOV_MOV(P(p), CondMove.getClearResult(P(p)), CondMove.getClearCond(P(p)), 
         CondMove.getClearTrueValue(P(p)), CondMove.getClearFalseValue(P(p)));
  }

  /**
   * Emit code for rule number 216:
   * r: CMP_CMOV(sload16, OTHER_OPERAND(INT_CONSTANT, any))
   * @param p BURS node to apply the rule to
   */
  private void code216(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, consumeMO(), CondMove.getClearVal2(P(p))))); 
CMOV_MOV(P(p), CondMove.getClearResult(P(p)), CondMove.getClearCond(P(p)), 
         CondMove.getClearTrueValue(P(p)), CondMove.getClearFalseValue(P(p)));
  }

  /**
   * Emit code for rule number 217:
   * r: CMP_CMOV(load32, OTHER_OPERAND(riv, any))
   * @param p BURS node to apply the rule to
   */
  private void code217(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, consumeMO(), CondMove.getClearVal2(P(p))))); 
CMOV_MOV(P(p), CondMove.getClearResult(P(p)), CondMove.getClearCond(P(p)), 
         CondMove.getClearTrueValue(P(p)), CondMove.getClearFalseValue(P(p)));
  }

  /**
   * Emit code for rule number 218:
   * r: CMP_CMOV(riv, OTHER_OPERAND(load32, any))
   * @param p BURS node to apply the rule to
   */
  private void code218(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, consumeMO(), CondMove.getClearVal1(P(p))))); 
CMOV_MOV(P(p), CondMove.getClearResult(P(p)), CondMove.getClearCond(P(p)).flipOperands(), 
         CondMove.getClearTrueValue(P(p)), CondMove.getClearFalseValue(P(p)));
  }

  /**
   * Emit code for rule number 219:
   * r: CMP_CMOV(boolcmp, OTHER_OPERAND(INT_CONSTANT, any))
   * @param p BURS node to apply the rule to
   */
  private void code219(AbstractBURS_TreeNode p) {
    CMOV_MOV(P(p), CondMove.getClearResult(P(p)), consumeCOND(), 
         CondMove.getClearTrueValue(P(p)), CondMove.getClearFalseValue(P(p)));
  }

  /**
   * Emit code for rule number 220:
   * r: CMP_CMOV(boolcmp, OTHER_OPERAND(INT_CONSTANT, any))
   * @param p BURS node to apply the rule to
   */
  private void code220(AbstractBURS_TreeNode p) {
    CMOV_MOV(P(p), CondMove.getClearResult(P(p)), consumeCOND().flipCode(), 
         CondMove.getClearTrueValue(P(p)), CondMove.getClearFalseValue(P(p)));
  }

  /**
   * Emit code for rule number 221:
   * r: CMP_CMOV(bittest, OTHER_OPERAND(INT_CONSTANT, any))
   * @param p BURS node to apply the rule to
   */
  private void code221(AbstractBURS_TreeNode p) {
    CMOV_MOV(P(p), CondMove.getClearResult(P(p)), BIT_TEST(VRL(p), CondMove.getClearCond(P(p))), 
         CondMove.getClearTrueValue(P(p)), CondMove.getClearFalseValue(P(p)));
  }

  /**
   * Emit code for rule number 222:
   * r: CMP_CMOV(cz, OTHER_OPERAND(INT_CONSTANT, any))
   * @param p BURS node to apply the rule to
   */
  private void code222(AbstractBURS_TreeNode p) {
    CMOV_MOV(P(p), CondMove.getClearResult(P(p)), CondMove.getClearCond(P(p)), 
         CondMove.getClearTrueValue(P(p)), CondMove.getClearFalseValue(P(p)));
  }

  /**
   * Emit code for rule number 223:
   * r: CMP_CMOV(szp, OTHER_OPERAND(INT_CONSTANT, any))
   * @param p BURS node to apply the rule to
   */
  private void code223(AbstractBURS_TreeNode p) {
    CMOV_MOV(P(p), CondMove.getClearResult(P(p)), CondMove.getClearCond(P(p)), 
         CondMove.getClearTrueValue(P(p)), CondMove.getClearFalseValue(P(p)));
  }

  /**
   * Emit code for rule number 224:
   * r:	INT_2BYTE(r)
   * @param p BURS node to apply the rule to
   */
  private void code224(AbstractBURS_TreeNode p) {
    EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX__B, Unary.getResult(P(p)), Unary.getVal(P(p))));
  }

  /**
   * Emit code for rule number 225:
   * r:	INT_2BYTE(load8_16_32)
   * @param p BURS node to apply the rule to
   */
  private void code225(AbstractBURS_TreeNode p) {
    EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX__B, Unary.getResult(P(p)), consumeMO()));
  }

  /**
   * Emit code for rule number 226:
   * stm:	BYTE_STORE(INT_2BYTE(r),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code226(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), B), Unary.getClearVal(PL(p))));
  }

  /**
   * Emit code for rule number 227:
   * stm:	BYTE_ASTORE(INT_2BYTE(r),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code227(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), B_S, B), Unary.getClearVal(PL(p))));
  }

  /**
   * Emit code for rule number 228:
   * r:	INT_2LONG(r)
   * @param p BURS node to apply the rule to
   */
  private void code228(AbstractBURS_TreeNode p) {
    INT_2LONG(P(p), Unary.getClearResult(P(p)), Unary.getClearVal(P(p)), true);
  }

  /**
   * Emit code for rule number 229:
   * r:	INT_2LONG(load32)
   * @param p BURS node to apply the rule to
   */
  private void code229(AbstractBURS_TreeNode p) {
    INT_2LONG(P(p), Unary.getClearResult(P(p)), consumeMO(), true);
  }

  /**
   * Emit code for rule number 230:
   * r:      LONG_AND(INT_2LONG(r), LONG_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code230(AbstractBURS_TreeNode p) {
    INT_2LONG(P(p), Binary.getClearResult(P(p)), Unary.getClearVal(PL(p)), false);
  }

  /**
   * Emit code for rule number 231:
   * r:      LONG_AND(INT_2LONG(load32), LONG_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code231(AbstractBURS_TreeNode p) {
    INT_2LONG(P(p), Binary.getClearResult(P(p)), consumeMO(), false);
  }

  /**
   * Emit code for rule number 232:
   * r:	INT_2ADDRZerExt(r)
   * @param p BURS node to apply the rule to
   */
  private void code232(AbstractBURS_TreeNode p) {
    INT_2LONG(P(p), Unary.getClearResult(P(p)), Unary.getClearVal(P(p)), false);
  }

  /**
   * Emit code for rule number 233:
   * r:	INT_2SHORT(r)
   * @param p BURS node to apply the rule to
   */
  private void code233(AbstractBURS_TreeNode p) {
    if (VM.BuildFor32Addr) { 
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX__W, Unary.getResult(P(p)), Unary.getVal(P(p)))); 
} else { 
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSXQ__W, Unary.getResult(P(p)), Unary.getVal(P(p)))); 
}
  }

  /**
   * Emit code for rule number 234:
   * r:	INT_2SHORT(load16_32)
   * @param p BURS node to apply the rule to
   */
  private void code234(AbstractBURS_TreeNode p) {
    if (VM.BuildFor32Addr) { 
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX__W, Unary.getResult(P(p)), setSize(consumeMO(), 2))); 
} else { 
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSXQ__W, Unary.getResult(P(p)), setSize(consumeMO(), 2))); 
}
  }

  /**
   * Emit code for rule number 235:
   * sload16:	INT_2SHORT(load16_32)
   * @param p BURS node to apply the rule to
   */
  private void code235(AbstractBURS_TreeNode p) {
    pushMO(setSize(consumeMO(),2));
  }

  /**
   * Emit code for rule number 236:
   * stm:	SHORT_STORE(INT_2SHORT(r), OTHER_OPERAND(riv,riv))
   * @param p BURS node to apply the rule to
   */
  private void code236(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), W), Unary.getClearVal(PL(p))));
  }

  /**
   * Emit code for rule number 237:
   * stm:	SHORT_ASTORE(INT_2SHORT(r), OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code237(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), W_S, W), Unary.getClearVal(PL(p))));
  }

  /**
   * Emit code for rule number 238:
   * szpr:	INT_2USHORT(r)
   * @param p BURS node to apply the rule to
   */
  private void code238(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, Unary.getResult(P(p)).copyRO(), Unary.getClearVal(P(p))))); 
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_AND, Unary.getResult(P(p)), IC(0xFFFF)));
  }

  /**
   * Emit code for rule number 239:
   * uload16:	INT_2USHORT(load16_32)
   * @param p BURS node to apply the rule to
   */
  private void code239(AbstractBURS_TreeNode p) {
    pushMO(setSize(consumeMO(),2));
  }

  /**
   * Emit code for rule number 240:
   * r:	INT_2USHORT(load16_32)
   * @param p BURS node to apply the rule to
   */
  private void code240(AbstractBURS_TreeNode p) {
    EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__W, Unary.getResult(P(p)), setSize(consumeMO(),2)));
  }

  /**
   * Emit code for rule number 241:
   * stm:	SHORT_STORE(INT_2USHORT(r), OTHER_OPERAND(riv,riv))
   * @param p BURS node to apply the rule to
   */
  private void code241(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), W), Unary.getClearVal(PL(p))));
  }

  /**
   * Emit code for rule number 242:
   * stm:	SHORT_ASTORE(INT_2USHORT(r), OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code242(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), W_S, W), Unary.getClearVal(PL(p))));
  }

  /**
   * Emit code for rule number 243:
   * czr:	INT_ADD(r, riv)
   * @param p BURS node to apply the rule to
   */
  private void code243(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_ADD, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), Binary.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 244:
   * r:	INT_ADD(r, riv)
   * @param p BURS node to apply the rule to
   */
  private void code244(AbstractBURS_TreeNode p) {
    if (Binary.getVal2(P(p)).isIntConstant()) { 
 pushAddress(R(Binary.getClearVal1(P(p))), null, B_S, Offset.fromIntSignExtend(VR(p))); 
} else { 
 pushAddress(R(Binary.getClearVal1(P(p))), R(Binary.getClearVal2(P(p))), B_S, Offset.zero()); 
} 
EMIT_Lea(P(p), Binary.getClearResult(P(p)), consumeAddress(DW, null, null));
  }

  /**
   * Emit code for rule number 245:
   * czr:	INT_ADD(r, load32)
   * @param p BURS node to apply the rule to
   */
  private void code245(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_ADD, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 246:
   * czr:	INT_ADD(load32, riv)
   * @param p BURS node to apply the rule to
   */
  private void code246(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_ADD, P(p), Binary.getClearResult(P(p)), Binary.getClearVal2(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 247:
   * stm:	INT_STORE(INT_ADD(INT_LOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code247(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_ADD, P(p), MO_S(P(p), DW), MO_S(P(p), DW), Binary.getClearVal2(PL(p)));
  }

  /**
   * Emit code for rule number 248:
   * stm:	INT_STORE(INT_ADD(riv,INT_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code248(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_ADD, P(p), MO_S(P(p), DW), MO_S(P(p), DW), Binary.getClearVal1(PL(p)));
  }

  /**
   * Emit code for rule number 249:
   * stm:	INT_ASTORE(INT_ADD(INT_ALOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code249(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_ADD, P(p), MO_AS(P(p), DW_S, DW), MO_AS(P(p), DW_S, DW), Binary.getClearVal2(PL(p)));
  }

  /**
   * Emit code for rule number 250:
   * stm:	INT_ASTORE(INT_ADD(riv,INT_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code250(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_ADD, P(p), MO_AS(P(p), DW_S, DW), MO_AS(P(p), DW_S, DW), Binary.getClearVal1(PL(p)));
  }

  /**
   * Emit code for rule number 251:
   * szpr:	INT_AND(r, riv)
   * @param p BURS node to apply the rule to
   */
  private void code251(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_AND, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), Binary.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 252:
   * szp:	INT_AND(r, riv)
   * @param p BURS node to apply the rule to
   */
  private void code252(AbstractBURS_TreeNode p) {
    EMIT(MIR_Test.mutate(P(p), IA32_TEST, Binary.getClearVal1(P(p)), Binary.getClearVal2(P(p))));
  }

  /**
   * Emit code for rule number 253:
   * szpr:	INT_AND(r, load32)
   * @param p BURS node to apply the rule to
   */
  private void code253(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_AND, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 254:
   * szpr:	INT_AND(load32, riv)
   * @param p BURS node to apply the rule to
   */
  private void code254(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_AND, P(p), Binary.getClearResult(P(p)), Binary.getClearVal2(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 255:
   * szp:	INT_AND(load8_16_32, riv)
   * @param p BURS node to apply the rule to
   */
  private void code255(AbstractBURS_TreeNode p) {
    EMIT(MIR_Test.mutate(P(p), IA32_TEST, consumeMO(), Binary.getClearVal2(P(p))));
  }

  /**
   * Emit code for rule number 256:
   * szp:	INT_AND(r, load8_16_32)
   * @param p BURS node to apply the rule to
   */
  private void code256(AbstractBURS_TreeNode p) {
    EMIT(MIR_Test.mutate(P(p), IA32_TEST, consumeMO(), Binary.getClearVal1(P(p))));
  }

  /**
   * Emit code for rule number 257:
   * stm:	INT_STORE(INT_AND(INT_LOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code257(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_AND, P(p), MO_S(P(p), DW), MO_S(P(p), DW), Binary.getClearVal2(PL(p)));
  }

  /**
   * Emit code for rule number 258:
   * stm:	INT_STORE(INT_AND(r,INT_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code258(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_AND, P(p), MO_S(P(p), DW), MO_S(P(p), DW), Binary.getClearVal1(PL(p)));
  }

  /**
   * Emit code for rule number 259:
   * stm:	INT_ASTORE(INT_AND(INT_ALOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code259(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_AND, P(p), MO_AS(P(p), DW_S, DW), MO_AS(P(p), DW_S, DW), Binary.getClearVal2(PL(p)));
  }

  /**
   * Emit code for rule number 260:
   * stm:	INT_ASTORE(INT_AND(r,INT_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code260(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_AND, P(p), MO_AS(P(p), DW_S, DW), MO_AS(P(p), DW_S, DW), Binary.getClearVal1(PL(p)));
  }

  /**
   * Emit code for rule number 261:
   * r:	INT_DIV(riv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code261(AbstractBURS_TreeNode p) {
    INT_DIVIDES(P(p), GuardedBinary.getClearResult(P(p)), GuardedBinary.getClearVal1(P(p)), 
            GuardedBinary.getClearVal2(P(p)), true, true);
  }

  /**
   * Emit code for rule number 262:
   * r:	INT_DIV(riv, load32)
   * @param p BURS node to apply the rule to
   */
  private void code262(AbstractBURS_TreeNode p) {
    INT_DIVIDES(P(p), GuardedBinary.getClearResult(P(p)), GuardedBinary.getClearVal1(P(p)), 
            consumeMO(), true, true);
  }

  /**
   * Emit code for rule number 263:
   * r:     UNSIGNED_DIV_64_32(rlv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code263(AbstractBURS_TreeNode p) {
    INT_DIVIDES(P(p), GuardedBinary.getResult(P(p)), GuardedBinary.getVal1(P(p)), 
            GuardedBinary.getVal2(P(p)), true, false);
  }

  /**
   * Emit code for rule number 264:
   * r:     UNSIGNED_DIV_64_32(rlv, load32)
   * @param p BURS node to apply the rule to
   */
  private void code264(AbstractBURS_TreeNode p) {
    INT_DIVIDES(P(p), GuardedBinary.getResult(P(p)), GuardedBinary.getVal1(P(p)), 
            consumeMO(), true, false);
  }

  /**
   * Emit code for rule number 265:
   * stm:	INT_IFCMP(r,riv)
   * @param p BURS node to apply the rule to
   */
  private void code265(AbstractBURS_TreeNode p) {
    IFCMP(P(p), IfCmp.getClearGuardResult(P(p)), IfCmp.getClearVal1(P(p)), IfCmp.getClearVal2(P(p)), IfCmp.getCond(P(p)));
  }

  /**
   * Emit code for rule number 266:
   * stm:	INT_IFCMP(r, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code266(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getClearGuardResult(P(p)), new TrueGuardOperand()))); 
EMIT(CPOS(P(p), MIR_Test.create(IA32_TEST, IfCmp.getVal1(P(p)).copy(), IfCmp.getClearVal1(P(p))))); 
EMIT(MIR_CondBranch.mutate(P(p), IA32_JCC, COND(IfCmp.getCond(P(p))), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p))));
  }

  /**
   * Emit code for rule number 267:
   * stm:	INT_IFCMP(load8, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code267(AbstractBURS_TreeNode p) {
    IFCMP(P(p), IfCmp.getClearGuardResult(P(p)), consumeMO(), IfCmp.getClearVal2(P(p)), IfCmp.getCond(P(p)));
  }

  /**
   * Emit code for rule number 268:
   * stm:	INT_IFCMP(uload8, r)
   * @param p BURS node to apply the rule to
   */
  private void code268(AbstractBURS_TreeNode p) {
    IFCMP(P(p), IfCmp.getClearGuardResult(P(p)), consumeMO(), IfCmp.getClearVal2(P(p)), IfCmp.getCond(P(p)));
  }

  /**
   * Emit code for rule number 269:
   * stm:	INT_IFCMP(r, uload8)
   * @param p BURS node to apply the rule to
   */
  private void code269(AbstractBURS_TreeNode p) {
    IFCMP(P(p), IfCmp.getClearGuardResult(P(p)), IfCmp.getClearVal1(P(p)), consumeMO(), IfCmp.getCond(P(p)));
  }

  /**
   * Emit code for rule number 270:
   * stm:	INT_IFCMP(sload16, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code270(AbstractBURS_TreeNode p) {
    IFCMP(P(p), IfCmp.getClearGuardResult(P(p)), consumeMO(), IfCmp.getClearVal2(P(p)), IfCmp.getCond(P(p)));
  }

  /**
   * Emit code for rule number 271:
   * stm:	INT_IFCMP(load32, riv)
   * @param p BURS node to apply the rule to
   */
  private void code271(AbstractBURS_TreeNode p) {
    IFCMP(P(p), IfCmp.getClearGuardResult(P(p)), consumeMO(), IfCmp.getClearVal2(P(p)), IfCmp.getCond(P(p)));
  }

  /**
   * Emit code for rule number 272:
   * stm:	INT_IFCMP(r, load32)
   * @param p BURS node to apply the rule to
   */
  private void code272(AbstractBURS_TreeNode p) {
    IFCMP(P(p), IfCmp.getClearGuardResult(P(p)), IfCmp.getClearVal1(P(p)), consumeMO(), IfCmp.getCond(P(p)));
  }

  /**
   * Emit code for rule number 273:
   * stm:	INT_IFCMP(boolcmp, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code273(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getClearGuardResult(P(p)), new TrueGuardOperand()))); 
EMIT(MIR_CondBranch.mutate(P(p), IA32_JCC, COND(consumeCOND()), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p))));
  }

  /**
   * Emit code for rule number 274:
   * stm:	INT_IFCMP(boolcmp, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code274(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getClearGuardResult(P(p)), new TrueGuardOperand()))); 
EMIT(MIR_CondBranch.mutate(P(p), IA32_JCC, COND(consumeCOND().flipCode()), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p))));
  }

  /**
   * Emit code for rule number 275:
   * stm:	INT_IFCMP(cz, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code275(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getClearGuardResult(P(p)), new TrueGuardOperand()))); 
EMIT(MIR_CondBranch.mutate(P(p), IA32_JCC, COND(IfCmp.getCond(P(p))), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p))));
  }

  /**
   * Emit code for rule number 276:
   * stm:	INT_IFCMP(szp, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code276(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getClearGuardResult(P(p)), new TrueGuardOperand()))); 
EMIT(MIR_CondBranch.mutate(P(p), IA32_JCC, COND(IfCmp.getCond(P(p))), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p))));
  }

  /**
   * Emit code for rule number 277:
   * stm:	INT_IFCMP(bittest, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code277(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getClearGuardResult(P(p)), new TrueGuardOperand()))); 
EMIT(MIR_CondBranch.mutate(P(p), IA32_JCC, COND(BIT_TEST(VR(p), IfCmp.getCond(P(p)))), IfCmp.getTarget(P(p)), IfCmp.getBranchProfile(P(p))));
  }

  /**
   * Emit code for rule number 278:
   * stm:	INT_IFCMP2(r,riv)
   * @param p BURS node to apply the rule to
   */
  private void code278(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp2.getClearGuardResult(P(p)), new TrueGuardOperand()))); 
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, IfCmp2.getClearVal1(P(p)), IfCmp2.getClearVal2(P(p))))); 
EMIT(MIR_CondBranch2.mutate(P(p), IA32_JCC2,                                  
	                    COND(IfCmp2.getCond1(P(p))), IfCmp2.getClearTarget1(P(p)),IfCmp2.getClearBranchProfile1(P(p)), 
	                    COND(IfCmp2.getCond2(P(p))), IfCmp2.getClearTarget2(P(p)), IfCmp2.getClearBranchProfile2(P(p))));
  }

  /**
   * Emit code for rule number 279:
   * stm:	INT_IFCMP2(load32,riv)
   * @param p BURS node to apply the rule to
   */
  private void code279(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp2.getClearGuardResult(P(p)), new TrueGuardOperand()))); 
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, consumeMO(), IfCmp2.getClearVal2(P(p))))); 
EMIT(MIR_CondBranch2.mutate(P(p), IA32_JCC2,                                  
	                    COND(IfCmp2.getCond1(P(p))), IfCmp2.getClearTarget1(P(p)),IfCmp2.getClearBranchProfile1(P(p)), 
	                    COND(IfCmp2.getCond2(P(p))), IfCmp2.getClearTarget2(P(p)), IfCmp2.getClearBranchProfile2(P(p))));
  }

  /**
   * Emit code for rule number 280:
   * stm:	INT_IFCMP2(riv,load32)
   * @param p BURS node to apply the rule to
   */
  private void code280(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp2.getClearGuardResult(P(p)), new TrueGuardOperand()))); 
EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, consumeMO(), IfCmp2.getClearVal1(P(p))))); 
EMIT(MIR_CondBranch2.mutate(P(p), IA32_JCC2,                                  
	                    COND(IfCmp2.getCond1(P(p)).flipOperands()), IfCmp2.getClearTarget1(P(p)),IfCmp2.getClearBranchProfile1(P(p)), 
	                    COND(IfCmp2.getCond2(P(p)).flipOperands()), IfCmp2.getClearTarget2(P(p)), IfCmp2.getClearBranchProfile2(P(p))));
  }

  /**
   * Emit code for rule number 281:
   * r:	INT_LOAD(rlv, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code281(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOV, Load.getResult(P(p)), MO_L(P(p), DW)));
  }

  /**
   * Emit code for rule number 282:
   * r:	INT_LOAD(rlv, address1scaledreg)
   * @param p BURS node to apply the rule to
   */
  private void code282(AbstractBURS_TreeNode p) {
    augmentAddress(Load.getAddress(P(p))); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Load.getResult(P(p)), 
		     consumeAddress(DW, Load.getLocation(P(p)), Load.getGuard(P(p)))));
  }

  /**
   * Emit code for rule number 283:
   * r:	INT_LOAD(address1scaledreg, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code283(AbstractBURS_TreeNode p) {
    augmentAddress(Load.getOffset(P(p))); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Load.getResult(P(p)), 
	             consumeAddress(DW, Load.getLocation(P(p)), Load.getGuard(P(p)))));
  }

  /**
   * Emit code for rule number 284:
   * r:	INT_LOAD(address1scaledreg, address1reg)
   * @param p BURS node to apply the rule to
   */
  private void code284(AbstractBURS_TreeNode p) {
    combineAddresses(); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Load.getResult(P(p)), 
	             consumeAddress(DW, Load.getLocation(P(p)), Load.getGuard(P(p)))));
  }

  /**
   * Emit code for rule number 285:
   * r:	INT_LOAD(address1reg, address1scaledreg)
   * @param p BURS node to apply the rule to
   */
  private void code285(AbstractBURS_TreeNode p) {
    combineAddresses(); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Load.getResult(P(p)), 
	             consumeAddress(DW, Load.getLocation(P(p)), Load.getGuard(P(p)))));
  }

  /**
   * Emit code for rule number 286:
   * r:	INT_LOAD(address, LONG_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code286(AbstractBURS_TreeNode p) {
    augmentAddress(Load.getOffset(P(p))); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Load.getResult(P(p)), 
	             consumeAddress(DW, Load.getLocation(P(p)), Load.getGuard(P(p)))));
  }

  /**
   * Emit code for rule number 287:
   * r:      INT_ALOAD(rlv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code287(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOV, ALoad.getResult(P(p)), MO_AL(P(p), DW_S, DW)));
  }

  /**
   * Emit code for rule number 288:
   * r:	INT_MOVE(riv)
   * @param p BURS node to apply the rule to
   */
  private void code288(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOV, Move.getResult(P(p)), Move.getVal(P(p))));
  }

  /**
   * Emit code for rule number 289:
   * czr:	INT_MOVE(czr)
   * @param p BURS node to apply the rule to
   */
  private void code289(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOV, Move.getResult(P(p)), Move.getVal(P(p))));
  }

  /**
   * Emit code for rule number 291:
   * szpr:	INT_MOVE(szpr)
   * @param p BURS node to apply the rule to
   */
  private void code291(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOV, Move.getResult(P(p)), Move.getVal(P(p))));
  }

  /**
   * Emit code for rule number 300:
   * r:	INT_MUL(r, riv)
   * @param p BURS node to apply the rule to
   */
  private void code300(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_IMUL2, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), Binary.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 301:
   * r:	INT_MUL(r, load32)
   * @param p BURS node to apply the rule to
   */
  private void code301(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_IMUL2, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 302:
   * r:	INT_MUL(load32, riv)
   * @param p BURS node to apply the rule to
   */
  private void code302(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_IMUL2, P(p), Binary.getClearResult(P(p)), Binary.getClearVal2(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 303:
   * szpr:	INT_NEG(r)
   * @param p BURS node to apply the rule to
   */
  private void code303(AbstractBURS_TreeNode p) {
    EMIT_Unary(IA32_NEG, P(p), Unary.getClearResult(P(p)), Unary.getClearVal(P(p)));
  }

  /**
   * Emit code for rule number 304:
   * stm:	INT_STORE(INT_NEG(INT_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code304(AbstractBURS_TreeNode p) {
    EMIT_Unary(IA32_NEG, P(p), MO_S(P(p), DW), MO_S(P(p), DW));
  }

  /**
   * Emit code for rule number 305:
   * stm:	INT_ASTORE(INT_NEG(INT_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code305(AbstractBURS_TreeNode p) {
    EMIT_Unary(IA32_NEG, P(p), MO_AS(P(p), DW_S, DW), MO_AS(P(p), DW_S, DW));
  }

  /**
   * Emit code for rule number 306:
   * r:	INT_NOT(r)
   * @param p BURS node to apply the rule to
   */
  private void code306(AbstractBURS_TreeNode p) {
    EMIT_Unary(IA32_NOT, P(p), Unary.getClearResult(P(p)), Unary.getClearVal(P(p)));
  }

  /**
   * Emit code for rule number 307:
   * stm:	INT_STORE(INT_NOT(INT_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code307(AbstractBURS_TreeNode p) {
    EMIT_Unary(IA32_NOT, P(p), MO_S(P(p), DW), MO_S(P(p), DW));
  }

  /**
   * Emit code for rule number 308:
   * stm:	INT_ASTORE(INT_NOT(INT_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code308(AbstractBURS_TreeNode p) {
    EMIT_Unary(IA32_NOT, P(p), MO_AS(P(p), DW_S, DW), MO_AS(P(p), DW_S, DW));
  }

  /**
   * Emit code for rule number 309:
   * szpr:	INT_OR(r, riv)
   * @param p BURS node to apply the rule to
   */
  private void code309(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_OR, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), Binary.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 310:
   * szpr:	INT_OR(r, load32)
   * @param p BURS node to apply the rule to
   */
  private void code310(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_OR, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), consumeMO() );
  }

  /**
   * Emit code for rule number 311:
   * szpr:	INT_OR(load32, riv)
   * @param p BURS node to apply the rule to
   */
  private void code311(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_OR, P(p), Binary.getClearResult(P(p)), Binary.getClearVal2(P(p)), consumeMO() );
  }

  /**
   * Emit code for rule number 312:
   * stm:	INT_STORE(INT_OR(INT_LOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code312(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_OR, P(p), MO_S(P(p), DW), MO_S(P(p), DW), Binary.getClearVal2(PL(p)));
  }

  /**
   * Emit code for rule number 313:
   * stm:	INT_STORE(INT_OR(r, INT_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code313(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_OR, P(p), MO_S(P(p), DW), MO_S(P(p), DW), Binary.getClearVal1(PL(p)));
  }

  /**
   * Emit code for rule number 314:
   * stm:	INT_ASTORE(INT_OR(INT_ALOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code314(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_OR, P(p), MO_AS(P(p), DW_S, DW), MO_AS(P(p), DW_S, DW), Binary.getClearVal2(PL(p)));
  }

  /**
   * Emit code for rule number 315:
   * stm:	INT_ASTORE(INT_OR(r, INT_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code315(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_OR, P(p), MO_AS(P(p), DW_S, DW), MO_AS(P(p), DW_S, DW), Binary.getClearVal1(PL(p)));
  }

  /**
   * Emit code for rule number 316:
   * r:	INT_REM(riv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code316(AbstractBURS_TreeNode p) {
    INT_DIVIDES(P(p), GuardedBinary.getClearResult(P(p)), GuardedBinary.getClearVal1(P(p)), 
	    GuardedBinary.getClearVal2(P(p)), false, true);
  }

  /**
   * Emit code for rule number 317:
   * r:	INT_REM(riv, load32)
   * @param p BURS node to apply the rule to
   */
  private void code317(AbstractBURS_TreeNode p) {
    INT_DIVIDES(P(p), GuardedBinary.getClearResult(P(p)), GuardedBinary.getClearVal1(P(p)), 
            consumeMO(), false, true);
  }

  /**
   * Emit code for rule number 318:
   * r:     UNSIGNED_REM_64_32(rlv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code318(AbstractBURS_TreeNode p) {
    INT_DIVIDES(P(p), GuardedBinary.getResult(P(p)), GuardedBinary.getVal1(P(p)), 
            GuardedBinary.getVal2(P(p)), false, false);
  }

  /**
   * Emit code for rule number 319:
   * r:     UNSIGNED_REM_64_32(rlv, load32)
   * @param p BURS node to apply the rule to
   */
  private void code319(AbstractBURS_TreeNode p) {
    INT_DIVIDES(P(p), GuardedBinary.getResult(P(p)), GuardedBinary.getVal1(P(p)), 
            consumeMO(), false, false);
  }

  /**
   * Emit code for rule number 320:
   * r:	INT_OR(INT_SHL(r,INT_CONSTANT),INT_USHR(r,INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code320(AbstractBURS_TreeNode p) {
    EMIT_NonCommutative(IA32_ROL, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(PL(p)), IC(VLR(p)&0x1f));
  }

  /**
   * Emit code for rule number 321:
   * r:      INT_OR(INT_USHR(r,INT_CONSTANT),INT_SHL(r,INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code321(AbstractBURS_TreeNode p) {
    EMIT_NonCommutative(IA32_ROL, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(PL(p)), IC(VRR(p)&0x1f));
  }

  /**
   * Emit code for rule number 322:
   * r:      INT_OR(INT_SHL(r,INT_CONSTANT),INT_USHR(r,INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code322(AbstractBURS_TreeNode p) {
    EMIT_NonCommutative(IA32_ROR, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(PL(p)), IC(1));
  }

  /**
   * Emit code for rule number 323:
   * r:      INT_OR(INT_USHR(r,INT_CONSTANT),INT_SHL(r,INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code323(AbstractBURS_TreeNode p) {
    EMIT_NonCommutative(IA32_ROR, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(PL(p)), IC(1));
  }

  /**
   * Emit code for rule number 324:
   * r:      INT_OR(INT_SHL(r,INT_AND(r,INT_CONSTANT)),INT_USHR(r,INT_AND(INT_NEG(r),INT_CONSTANT)))
   * @param p BURS node to apply the rule to
   */
  private void code324(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getClearVal1(PLR(p))))); 
EMIT_NonCommutative(IA32_ROL, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(PL(p)), new RegisterOperand(getECX(), TypeReference.Int));
  }

  /**
   * Emit code for rule number 325:
   * r:      INT_OR(INT_USHR(r,INT_AND(INT_NEG(r),INT_CONSTANT)),INT_SHL(r,INT_AND(r,INT_CONSTANT)))
   * @param p BURS node to apply the rule to
   */
  private void code325(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getClearVal1(PRR(p))))); 
EMIT_NonCommutative(IA32_ROL, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(PL(p)), new RegisterOperand(getECX(), TypeReference.Int));
  }

  /**
   * Emit code for rule number 326:
   * r:      INT_OR(INT_SHL(r,INT_AND(INT_NEG(r),INT_CONSTANT)),INT_USHR(r,INT_AND(r,INT_CONSTANT)))
   * @param p BURS node to apply the rule to
   */
  private void code326(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getClearVal1(PRR(p))))); 
EMIT_NonCommutative(IA32_ROR, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(PL(p)), new RegisterOperand(getECX(), TypeReference.Int));
  }

  /**
   * Emit code for rule number 327:
   * r:      INT_OR(INT_USHR(r,INT_AND(r,INT_CONSTANT)),INT_SHL(r,INT_AND(INT_NEG(r),INT_CONSTANT)))
   * @param p BURS node to apply the rule to
   */
  private void code327(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getClearVal1(PLR(p))))); 
EMIT_NonCommutative(IA32_ROR, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(PL(p)), new RegisterOperand(getECX(), TypeReference.Int));
  }

  /**
   * Emit code for rule number 328:
   * szpr:	INT_SHL(riv, INT_AND(r, INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code328(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getClearVal1(PR(p))))); 
EMIT_NonCommutative(IA32_SHL, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), new RegisterOperand(getECX(), TypeReference.Int));
  }

  /**
   * Emit code for rule number 329:
   * szpr:	INT_SHL(riv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code329(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getClearVal2(P(p))))); 
EMIT_NonCommutative(IA32_SHL, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), new RegisterOperand(getECX(), TypeReference.Int));
  }

  /**
   * Emit code for rule number 330:
   * szpr:	INT_SHL(r, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code330(AbstractBURS_TreeNode p) {
    if (VM.VerifyAssertions) VM._assert((VR(p) & 0x7FFFFFFF) <= 31); if(Binary.getVal2(P(p)).asIntConstant().value == 1) { 
 EMIT_Commutative(IA32_ADD, P(p), Binary.getClearResult(P(p)), Binary.getVal1(P(p)).copy(), Binary.getClearVal1(P(p))); 
} else { 
 EMIT_NonCommutative(IA32_SHL, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), Binary.getClearVal2(P(p))); 
}
  }

  /**
   * Emit code for rule number 331:
   * r:	INT_SHL(r, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code331(AbstractBURS_TreeNode p) {
    pushAddress(null, Binary.getClearVal1(P(p)).asRegister(), LEA_SHIFT(Binary.getClearVal2(P(p))), Offset.zero()); 
EMIT_Lea(P(p), Binary.getClearResult(P(p)), consumeAddress(DW, null, null));
  }

  /**
   * Emit code for rule number 332:
   * szpr:	INT_SHL(INT_SHR(r, INT_CONSTANT), INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code332(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_AND, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(PL(p)), IC(0xffffffff << VR(p)));
  }

  /**
   * Emit code for rule number 333:
   * stm:	INT_STORE(INT_SHL(INT_LOAD(riv,riv),INT_AND(r,INT_CONSTANT)),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code333(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getClearVal1(PLR(p))))); 
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHL, MO_S(P(p), DW), new RegisterOperand(getECX(), TypeReference.Int)));
  }

  /**
   * Emit code for rule number 334:
   * stm:	INT_STORE(INT_SHL(INT_LOAD(riv,riv), INT_CONSTANT),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code334(AbstractBURS_TreeNode p) {
    if (VM.VerifyAssertions) VM._assert((VLR(p) & 0x7FFFFFFF) <= 31); 
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHL, MO_S(P(p), DW), Binary.getClearVal2(PL(p))));
  }

  /**
   * Emit code for rule number 335:
   * stm:	INT_ASTORE(INT_SHL(INT_ALOAD(riv,riv),INT_AND(r, INT_CONSTANT)),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code335(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getClearVal1(PLR(p)))); 
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHL, MO_AS(P(p), DW_S, DW), new RegisterOperand(getECX(), TypeReference.Int)));
  }

  /**
   * Emit code for rule number 336:
   * stm:	INT_ASTORE(INT_SHL(INT_ALOAD(riv,riv), INT_CONSTANT),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code336(AbstractBURS_TreeNode p) {
    EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHL, MO_AS(P(p), DW_S, DW), Binary.getClearVal2(PL(p))));
  }

  /**
   * Emit code for rule number 337:
   * szpr:	INT_SHR(riv, INT_AND(r, INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code337(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getClearVal1(PR(p))))); 
EMIT_NonCommutative(IA32_SAR, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), new RegisterOperand(getECX(), TypeReference.Int));
  }

  /**
   * Emit code for rule number 338:
   * szpr:	INT_SHR(riv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code338(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getClearVal2(P(p))))); 
EMIT_NonCommutative(IA32_SAR, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), new RegisterOperand(getECX(), TypeReference.Int));
  }

  /**
   * Emit code for rule number 339:
   * szpr:	INT_SHR(riv, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code339(AbstractBURS_TreeNode p) {
    if (VM.VerifyAssertions) VM._assert((VR(p) & 0x7FFFFFFF) <= 31); 
EMIT_NonCommutative(IA32_SAR, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), Binary.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 340:
   * stm:	INT_STORE(INT_SHR(INT_LOAD(riv,riv),INT_AND(r,INT_CONSTANT)),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code340(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getClearVal1(PLR(p))))); 
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SAR, MO_S(P(p), DW), new RegisterOperand(getECX(), TypeReference.Int)));
  }

  /**
   * Emit code for rule number 341:
   * stm:	INT_STORE(INT_SHR(INT_LOAD(riv,riv), INT_CONSTANT),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code341(AbstractBURS_TreeNode p) {
    if (VM.VerifyAssertions) VM._assert((VLR(p) & 0x7FFFFFFF) <= 31); 
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SAR, MO_S(P(p), DW), Binary.getClearVal2(PL(p))));
  }

  /**
   * Emit code for rule number 342:
   * stm:	INT_ASTORE(INT_SHR(INT_ALOAD(riv,riv),INT_AND(r, INT_CONSTANT)),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code342(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getClearVal1(PLR(p)))); 
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SAR, MO_AS(P(p), DW_S, DW), new RegisterOperand(getECX(), TypeReference.Int)));
  }

  /**
   * Emit code for rule number 343:
   * stm:	INT_ASTORE(INT_SHR(INT_ALOAD(riv,riv), INT_CONSTANT),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code343(AbstractBURS_TreeNode p) {
    EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SAR, MO_AS(P(p), DW_S, DW), Binary.getClearVal2(PL(p))));
  }

  /**
   * Emit code for rule number 344:
   * stm:	INT_STORE(riv, OTHER_OPERAND(rlv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code344(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), DW), Store.getValue(P(p))));
  }

  /**
   * Emit code for rule number 345:
   * stm:	INT_STORE(riv, OTHER_OPERAND(rlv, address1scaledreg))
   * @param p BURS node to apply the rule to
   */
  private void code345(AbstractBURS_TreeNode p) {
    augmentAddress(Store.getAddress(P(p))); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV, 
                     consumeAddress(DW, Store.getLocation(P(p)), Store.getGuard(P(p))), 
		     Store.getValue(P(p))));
  }

  /**
   * Emit code for rule number 346:
   * stm:	INT_STORE(riv, OTHER_OPERAND(address1scaledreg, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code346(AbstractBURS_TreeNode p) {
    augmentAddress(Store.getOffset(P(p))); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV, 
                     consumeAddress(DW, Store.getLocation(P(p)), Store.getGuard(P(p))), 
		     Store.getValue(P(p))));
  }

  /**
   * Emit code for rule number 347:
   * stm:	INT_STORE(riv, OTHER_OPERAND(address1scaledreg, address1reg))
   * @param p BURS node to apply the rule to
   */
  private void code347(AbstractBURS_TreeNode p) {
    combineAddresses(); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV,  
                    consumeAddress(DW, Store.getLocation(P(p)), Store.getGuard(P(p))), 
                    Store.getValue(P(p))));
  }

  /**
   * Emit code for rule number 348:
   * stm:	INT_STORE(riv, OTHER_OPERAND(address1reg, address1scaledreg))
   * @param p BURS node to apply the rule to
   */
  private void code348(AbstractBURS_TreeNode p) {
    combineAddresses(); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV,  
                    consumeAddress(DW, Store.getLocation(P(p)), Store.getGuard(P(p))), 
                    Store.getValue(P(p))));
  }

  /**
   * Emit code for rule number 349:
   * stm:	INT_STORE(riv, OTHER_OPERAND(address, LONG_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code349(AbstractBURS_TreeNode p) {
    augmentAddress(Store.getOffset(P(p))); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV,  
	             consumeAddress(DW, Store.getLocation(P(p)), Store.getGuard(P(p))), 
		     Store.getValue(P(p))));
  }

  /**
   * Emit code for rule number 350:
   * czr:	INT_SUB(riv, r)
   * @param p BURS node to apply the rule to
   */
  private void code350(AbstractBURS_TreeNode p) {
    EMIT_NonCommutative(IA32_SUB, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), Binary.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 351:
   * r:	INT_SUB(riv, r)
   * @param p BURS node to apply the rule to
   */
  private void code351(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_UnaryAcc.create(IA32_NEG, Binary.getResult(P(p)).copy()))); 
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_ADD, Binary.getResult(P(p)), Binary.getVal1(P(p))));
  }

  /**
   * Emit code for rule number 352:
   * r:	INT_SUB(load32, r)
   * @param p BURS node to apply the rule to
   */
  private void code352(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_UnaryAcc.create(IA32_NEG, Binary.getResult(P(p)).copy()))); 
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_ADD, Binary.getResult(P(p)), consumeMO()));
  }

  /**
   * Emit code for rule number 353:
   * czr:	INT_SUB(riv, load32)
   * @param p BURS node to apply the rule to
   */
  private void code353(AbstractBURS_TreeNode p) {
    EMIT_NonCommutative(IA32_SUB, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 354:
   * czr:	INT_SUB(load32, riv)
   * @param p BURS node to apply the rule to
   */
  private void code354(AbstractBURS_TreeNode p) {
    EMIT_NonCommutative(IA32_SUB, P(p), Binary.getResult(P(p)), consumeMO(), Binary.getVal2(P(p)));
  }

  /**
   * Emit code for rule number 355:
   * stm:	INT_STORE(INT_SUB(INT_LOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code355(AbstractBURS_TreeNode p) {
    EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SUB, MO_S(P(p), DW), Binary.getClearVal2(PL(p))));
  }

  /**
   * Emit code for rule number 356:
   * stm:	INT_STORE(INT_SUB(riv, INT_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code356(AbstractBURS_TreeNode p) {
    MemoryOperand result = MO_S(P(p), DW); 
EMIT(CPOS(P(p), MIR_UnaryAcc.create(IA32_NEG, result))); 
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_ADD, result.copy(), Binary.getClearVal1(PL(p))));
  }

  /**
   * Emit code for rule number 357:
   * stm:	INT_ASTORE(INT_SUB(INT_ALOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code357(AbstractBURS_TreeNode p) {
    EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SUB, MO_AS(P(p), DW_S, DW), Binary.getClearVal2(PL(p))));
  }

  /**
   * Emit code for rule number 358:
   * stm:	INT_ASTORE(INT_SUB(riv, INT_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code358(AbstractBURS_TreeNode p) {
    MemoryOperand result = MO_AS(P(p), DW_S, DW); 
EMIT(CPOS(P(p), MIR_UnaryAcc.create(IA32_NEG, result))); 
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_ADD, result.copy(), Binary.getClearVal1(PL(p))));
  }

  /**
   * Emit code for rule number 359:
   * szpr:	INT_USHR(riv, INT_AND(r, INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code359(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getClearVal1(PR(p))))); 
EMIT_NonCommutative(IA32_SHR, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), new RegisterOperand(getECX(), TypeReference.Int));
  }

  /**
   * Emit code for rule number 360:
   * szpr:	INT_USHR(riv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code360(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getClearVal2(P(p))))); 
EMIT_NonCommutative(IA32_SHR, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), new RegisterOperand(getECX(), TypeReference.Int));
  }

  /**
   * Emit code for rule number 361:
   * szpr:	INT_USHR(riv, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code361(AbstractBURS_TreeNode p) {
    if (VM.VerifyAssertions) VM._assert((VR(p) & 0x7FFFFFFF) <= 31); 
EMIT_NonCommutative(IA32_SHR, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), Binary.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 362:
   * stm:	INT_STORE(INT_USHR(INT_LOAD(riv,riv),INT_AND(r,INT_CONSTANT)),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code362(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getClearVal1(PLR(p))))); 
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHR, MO_S(P(p), DW), new RegisterOperand(getECX(), TypeReference.Int)));
  }

  /**
   * Emit code for rule number 363:
   * stm:	INT_STORE(INT_USHR(INT_LOAD(riv,riv), INT_CONSTANT),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code363(AbstractBURS_TreeNode p) {
    if (VM.VerifyAssertions) VM._assert((VLR(p) & 0x7FFFFFFF) <= 31); 
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHR, MO_S(P(p), DW), Binary.getClearVal2(PL(p))));
  }

  /**
   * Emit code for rule number 364:
   * stm:	INT_ASTORE(INT_USHR(INT_ALOAD(riv,riv),INT_AND(r, INT_CONSTANT)),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code364(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getClearVal1(PLR(p)))); 
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHR, MO_AS(P(p), DW_S, DW), new RegisterOperand(getECX(), TypeReference.Int)));
  }

  /**
   * Emit code for rule number 365:
   * stm:	INT_ASTORE(INT_USHR(INT_ALOAD(riv,riv), INT_CONSTANT),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code365(AbstractBURS_TreeNode p) {
    EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHR, MO_AS(P(p), DW_S, DW), Binary.getClearVal2(PL(p))));
  }

  /**
   * Emit code for rule number 366:
   * szpr:	INT_XOR(r, riv)
   * @param p BURS node to apply the rule to
   */
  private void code366(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_XOR, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), Binary.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 367:
   * szpr:	INT_XOR(r, load32)
   * @param p BURS node to apply the rule to
   */
  private void code367(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_XOR, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), consumeMO() );
  }

  /**
   * Emit code for rule number 368:
   * szpr:	INT_XOR(load32, riv)
   * @param p BURS node to apply the rule to
   */
  private void code368(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_XOR, P(p), Binary.getClearResult(P(p)), Binary.getClearVal2(P(p)), consumeMO() );
  }

  /**
   * Emit code for rule number 369:
   * stm:	INT_STORE(INT_XOR(INT_LOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code369(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_XOR, P(p), MO_S(P(p), DW), MO_S(P(p), DW), Binary.getClearVal2(PL(p)));
  }

  /**
   * Emit code for rule number 370:
   * stm:	INT_STORE(INT_XOR(r,INT_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code370(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_XOR, P(p), MO_S(P(p), DW), MO_S(P(p), DW), Binary.getClearVal1(PL(p)));
  }

  /**
   * Emit code for rule number 371:
   * stm:	INT_ASTORE(INT_XOR(INT_ALOAD(riv,riv),riv),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code371(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_XOR, P(p), MO_AS(P(p), DW_S, DW), MO_AS(P(p), DW_S, DW), Binary.getClearVal2(PL(p)));
  }

  /**
   * Emit code for rule number 372:
   * stm:	INT_ASTORE(INT_XOR(r,INT_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code372(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_XOR, P(p), MO_AS(P(p), DW_S, DW), MO_AS(P(p), DW_S, DW), Binary.getClearVal1(PL(p)));
  }

  /**
   * Emit code for rule number 373:
   * r: LCMP_CMOV(r, OTHER_OPERAND(rlv, any))
   * @param p BURS node to apply the rule to
   */
  private void code373(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP,  CondMove.getClearVal1(P(p)), CondMove.getClearVal2(P(p))))); 
CMOV_MOV(P(p), CondMove.getClearResult(P(p)), CondMove.getClearCond(P(p)), 
         CondMove.getClearTrueValue(P(p)), CondMove.getClearFalseValue(P(p)));
  }

  /**
   * Emit code for rule number 374:
   * r: LCMP_CMOV(r, OTHER_OPERAND(INT_CONSTANT, any))
   * @param p BURS node to apply the rule to
   */
  private void code374(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Test.create(IA32_TEST, CondMove.getClearVal1(P(p)), CondMove.getClearVal1(P(p)).copy()))); 
CMOV_MOV(P(p), CondMove.getClearResult(P(p)), CondMove.getClearCond(P(p)), 
         CondMove.getClearTrueValue(P(p)), CondMove.getClearFalseValue(P(p)));
  }

  /**
   * Emit code for rule number 375:
   * r: LCMP_CMOV(load64, OTHER_OPERAND(rlv, any))
   * @param p BURS node to apply the rule to
   */
  private void code375(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, consumeMO(), CondMove.getClearVal2(P(p))))); 
CMOV_MOV(P(p), CondMove.getClearResult(P(p)), CondMove.getClearCond(P(p)), 
         CondMove.getClearTrueValue(P(p)), CondMove.getClearFalseValue(P(p)));
  }

  /**
   * Emit code for rule number 376:
   * r: LCMP_CMOV(rlv, OTHER_OPERAND(load64, any))
   * @param p BURS node to apply the rule to
   */
  private void code376(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Compare.create(IA32_CMP, consumeMO(), CondMove.getVal1(P(p))))); 
CMOV_MOV(P(p), CondMove.getClearResult(P(p)), CondMove.getClearCond(P(p)).flipOperands(), 
         CondMove.getClearTrueValue(P(p)), CondMove.getClearFalseValue(P(p)));
  }

  /**
   * Emit code for rule number 377:
   * r:	LONG_ADD(address1scaledreg, r)
   * @param p BURS node to apply the rule to
   */
  private void code377(AbstractBURS_TreeNode p) {
    augmentAddress(Binary.getVal2(P(p))); 
EMIT_Lea(P(p), Binary.getResult(P(p)), consumeAddress(QW, null, null));
  }

  /**
   * Emit code for rule number 378:
   * r:	LONG_ADD(r, address1scaledreg)
   * @param p BURS node to apply the rule to
   */
  private void code378(AbstractBURS_TreeNode p) {
    augmentAddress(Binary.getVal1(P(p))); 
EMIT_Lea(P(p), Binary.getResult(P(p)), consumeAddress(QW, null, null));
  }

  /**
   * Emit code for rule number 379:
   * r:	LONG_ADD(address1scaledreg, address1reg)
   * @param p BURS node to apply the rule to
   */
  private void code379(AbstractBURS_TreeNode p) {
    combineAddresses(); 
EMIT_Lea(P(p), Binary.getResult(P(p)), consumeAddress(QW, null, null));
  }

  /**
   * Emit code for rule number 380:
   * r:	LONG_ADD(address1reg, address1scaledreg)
   * @param p BURS node to apply the rule to
   */
  private void code380(AbstractBURS_TreeNode p) {
    combineAddresses(); 
EMIT_Lea(P(p), Binary.getResult(P(p)), consumeAddress(QW, null, null));
  }

  /**
   * Emit code for rule number 381:
   * r:	LONG_ADD(address, LONG_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code381(AbstractBURS_TreeNode p) {
    augmentAddress(Binary.getVal2(P(p))); 
EMIT_Lea(P(p), Binary.getResult(P(p)), consumeAddress(QW, null, null));
  }

  /**
   * Emit code for rule number 382:
   * r:	LONG_MOVE(address)
   * @param p BURS node to apply the rule to
   */
  private void code382(AbstractBURS_TreeNode p) {
    EMIT_Lea(P(p), Move.getResult(P(p)), consumeAddress(QW, null, null));
  }

  /**
   * Emit code for rule number 383:
   * r:      BYTE_LOAD(rlv, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code383(AbstractBURS_TreeNode p) {
    EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX__B, Load.getResult(P(p)), MO_L(P(p), B)));
  }

  /**
   * Emit code for rule number 384:
   * sload8:	BYTE_LOAD(rlv, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code384(AbstractBURS_TreeNode p) {
    pushMO(MO_L(P(p), B));
  }

  /**
   * Emit code for rule number 385:
   * r:      BYTE_ALOAD(rlv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code385(AbstractBURS_TreeNode p) {
    EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX__B, ALoad.getResult(P(p)), MO_AL(P(p), B_S, B)));
  }

  /**
   * Emit code for rule number 386:
   * r:      BYTE_ALOAD(rlv, r)
   * @param p BURS node to apply the rule to
   */
  private void code386(AbstractBURS_TreeNode p) {
    RegisterOperand index = ALoad.getIndex(P(p)).asRegister(); 
if (index.getRegister().isInteger()) { 
CLEAR_UPPER_32(P(p), index.copy().asRegister()); 
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX__B, ALoad.getResult(P(p)), MO_AL(P(p), B_S, B))); 
} else { 
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX__B, ALoad.getResult(P(p)), MO_AL(P(p), B_S, B))); 
}
  }

  /**
   * Emit code for rule number 387:
   * sload8:	BYTE_ALOAD(rlv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code387(AbstractBURS_TreeNode p) {
    pushMO(MO_AL(P(p), B_S, B));
  }

  /**
   * Emit code for rule number 388:
   * r:      UBYTE_LOAD(rlv, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code388(AbstractBURS_TreeNode p) {
    EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__B, Load.getResult(P(p)), MO_L(P(p), B)));
  }

  /**
   * Emit code for rule number 389:
   * uload8:	UBYTE_LOAD(rlv, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code389(AbstractBURS_TreeNode p) {
    pushMO(MO_L(P(p), B));
  }

  /**
   * Emit code for rule number 390:
   * r:	UBYTE_ALOAD(rlv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code390(AbstractBURS_TreeNode p) {
    EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__B, ALoad.getResult(P(p)), MO_AL(P(p), B_S, B)));
  }

  /**
   * Emit code for rule number 391:
   * r:      UBYTE_ALOAD(rlv, r)
   * @param p BURS node to apply the rule to
   */
  private void code391(AbstractBURS_TreeNode p) {
    RegisterOperand index = ALoad.getIndex(P(p)).asRegister(); 
if (index.getRegister().isInteger()) { 
CLEAR_UPPER_32(P(p), index.copy().asRegister()); 
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__B, ALoad.getResult(P(p)), MO_AL(P(p), B_S, B))); 
} else { 
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__B, ALoad.getResult(P(p)), MO_AL(P(p), B_S, B))); 
}
  }

  /**
   * Emit code for rule number 392:
   * uload8:	UBYTE_ALOAD(rlv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code392(AbstractBURS_TreeNode p) {
    pushMO(MO_AL(P(p), B_S, B));
  }

  /**
   * Emit code for rule number 395:
   * r:      SHORT_LOAD(rlv, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code395(AbstractBURS_TreeNode p) {
    EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX__W, Load.getResult(P(p)), MO_L(P(p), W)));
  }

  /**
   * Emit code for rule number 396:
   * sload16: SHORT_LOAD(rlv, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code396(AbstractBURS_TreeNode p) {
    pushMO(MO_L(P(p), W));
  }

  /**
   * Emit code for rule number 397:
   * r:      SHORT_ALOAD(rlv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code397(AbstractBURS_TreeNode p) {
    EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX__W, ALoad.getResult(P(p)), MO_AL(P(p), W_S, W)));
  }

  /**
   * Emit code for rule number 398:
   * r:      SHORT_ALOAD(rlv, r)
   * @param p BURS node to apply the rule to
   */
  private void code398(AbstractBURS_TreeNode p) {
    RegisterOperand index = ALoad.getIndex(P(p)).asRegister(); 
if (index.getRegister().isInteger()) { 
CLEAR_UPPER_32(P(p), index.copy().asRegister()); 
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX__W, ALoad.getResult(P(p)), MO_AL(P(p), W_S, W))); 
} else { 
EMIT(MIR_Unary.mutate(P(p), IA32_MOVSX__W, ALoad.getResult(P(p)), MO_AL(P(p), W_S, W))); 
}
  }

  /**
   * Emit code for rule number 399:
   * sload16: SHORT_ALOAD(rlv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code399(AbstractBURS_TreeNode p) {
    pushMO(MO_AL(P(p), W_S, W));
  }

  /**
   * Emit code for rule number 400:
   * r:      USHORT_LOAD(rlv, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code400(AbstractBURS_TreeNode p) {
    EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__W, Load.getResult(P(p)), MO_L(P(p), W)));
  }

  /**
   * Emit code for rule number 401:
   * uload16: USHORT_LOAD(rlv, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code401(AbstractBURS_TreeNode p) {
    pushMO(MO_L(P(p), W));
  }

  /**
   * Emit code for rule number 402:
   * r:      USHORT_ALOAD(rlv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code402(AbstractBURS_TreeNode p) {
    EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__W, ALoad.getResult(P(p)), MO_AL(P(p), W_S, W)));
  }

  /**
   * Emit code for rule number 403:
   * r:      USHORT_ALOAD(rlv, r)
   * @param p BURS node to apply the rule to
   */
  private void code403(AbstractBURS_TreeNode p) {
    RegisterOperand index = ALoad.getIndex(P(p)).asRegister(); 
if (index.getRegister().isInteger()) { 
CLEAR_UPPER_32(P(p), index.copy().asRegister()); 
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__W, ALoad.getResult(P(p)), MO_AL(P(p), W_S, W))); 
} else { 
EMIT(MIR_Unary.mutate(P(p), IA32_MOVZX__W, ALoad.getResult(P(p)), MO_AL(P(p), W_S, W))); 
}
  }

  /**
   * Emit code for rule number 404:
   * uload16: USHORT_ALOAD(rlv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code404(AbstractBURS_TreeNode p) {
    pushMO(MO_AL(P(p), W_S, W));
  }

  /**
   * Emit code for rule number 407:
   * load32:	INT_LOAD(rlv, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code407(AbstractBURS_TreeNode p) {
    pushMO(MO_L(P(p), DW));
  }

  /**
   * Emit code for rule number 408:
   * load32:	INT_ALOAD(rlv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code408(AbstractBURS_TreeNode p) {
    pushMO(MO_AL(P(p), DW_S, DW));
  }

  /**
   * Emit code for rule number 413:
   * load64:	LONG_LOAD(rlv, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code413(AbstractBURS_TreeNode p) {
    pushMO(MO_L(P(p), QW));
  }

  /**
   * Emit code for rule number 414:
   * load64:	LONG_ALOAD(rlv, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code414(AbstractBURS_TreeNode p) {
    pushMO(MO_AL(P(p), QW_S, QW));
  }

  /**
   * Emit code for rule number 415:
   * load64:	LONG_ALOAD(rlv, r)
   * @param p BURS node to apply the rule to
   */
  private void code415(AbstractBURS_TreeNode p) {
    RegisterOperand index = ALoad.getIndex(P(p)).asRegister(); 
if (index.getRegister().isInteger()) { 
CLEAR_UPPER_32(P(p), index.copy().asRegister()); 
pushMO(MO_AL(P(p), QW_S, QW)); 
} else { 
pushMO(MO_AL(P(p), QW_S, QW)); 
}
  }

  /**
   * Emit code for rule number 418:
   * r:	LONG_2INT(r)
   * @param p BURS node to apply the rule to
   */
  private void code418(AbstractBURS_TreeNode p) {
    RegisterOperand val = R(Unary.getVal(P(p)).copy()); 
if (VM.BuildFor64Addr) { 
RegisterOperand r = Unary.getResult(P(p)); 
RegisterOperand temp = regpool.makeTempInt(); 
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, temp, val))); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV, r, temp.copy())); 
} else { 
Register lh = regpool.getSecondReg(R(Unary.getVal(P(p))).getRegister()); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Unary.getResult(P(p)), new RegisterOperand(lh, TypeReference.Int))); 
}
  }

  /**
   * Emit code for rule number 419:
   * stm:	INT_STORE(LONG_2INT(r), OTHER_OPERAND(riv,riv))
   * @param p BURS node to apply the rule to
   */
  private void code419(AbstractBURS_TreeNode p) {
    RegisterOperand val = R(Unary.getVal(PL(p)).copy()); 
if (VM.BuildFor64Addr) { 
RegisterOperand temp = regpool.makeTempInt(); 
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, temp, val))); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), DW),temp.copy())); 
} else { 
Register lh = regpool.getSecondReg(R(Unary.getVal(PL(p))).getRegister()); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), DW), new RegisterOperand(lh, TypeReference.Int))); 
}
  }

  /**
   * Emit code for rule number 420:
   * stm:	INT_ASTORE(LONG_2INT(r), OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code420(AbstractBURS_TreeNode p) {
    RegisterOperand val = R(Unary.getVal(PL(p)).copy()); 
if (VM.BuildFor64Addr) { 
RegisterOperand temp = regpool.makeTempInt(); 
EMIT(CPOS(P(p),MIR_Move.create(IA32_MOV, temp, val))); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), DW_S, DW),temp.copy())); 
} else { 
Register lh = regpool.getSecondReg(R(Unary.getVal(PL(p))).getRegister()); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_AS(P(p), DW_S, DW), new RegisterOperand(lh, TypeReference.Int))); 
}
  }

  /**
   * Emit code for rule number 421:
   * r:	LONG_2INT(load64)
   * @param p BURS node to apply the rule to
   */
  private void code421(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOV, Unary.getResult(P(p)), setSize(consumeMO(), 4)));
  }

  /**
   * Emit code for rule number 422:
   * load32:      LONG_2INT(load64)
   * @param p BURS node to apply the rule to
   */
  private void code422(AbstractBURS_TreeNode p) {
    pushMO(setSize(consumeMO(), 4));
  }

  /**
   * Emit code for rule number 423:
   * r:	LONG_2INT(LONG_USHR(r, INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code423(AbstractBURS_TreeNode p) {
    RegisterOperand val = R(Binary.getVal1(PL(p))); 
if (VM.BuildFor64Addr) { 
RegisterOperand temp = regpool.makeTempInt(); 
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, temp, val.copy()))); 
EMIT(CPOS(P(p), MIR_BinaryAcc.create(IA32_SHR,temp.copy(),LC(32)))); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Unary.getResult(P(p)), temp.copy())); 
} else { 
Register uh = Binary.getVal1(PL(p)).asRegister().getRegister(); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Unary.getResult(P(p)), new RegisterOperand(uh, TypeReference.Int))); 
}
  }

  /**
   * Emit code for rule number 424:
   * r:      LONG_2INT(LONG_SHR(r, INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code424(AbstractBURS_TreeNode p) {
    RegisterOperand val = R(Binary.getVal1(PL(p))); 
if (VM.BuildFor64Addr) { 
RegisterOperand temp = regpool.makeTempInt(); 
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, temp, val.copy()))); 
EMIT(CPOS(P(p), MIR_BinaryAcc.create(IA32_SAR,temp.copy(),LC(32)))); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Unary.getResult(P(p)), temp.copy())); 
} else { 
Register uh = Binary.getVal1(PL(p)).asRegister().getRegister(); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Unary.getResult(P(p)), new RegisterOperand(uh, TypeReference.Int))); 
}
  }

  /**
   * Emit code for rule number 425:
   * r:      LONG_2INT(LONG_USHR(load64, INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code425(AbstractBURS_TreeNode p) {
    MemoryOperand mo = consumeMO(); 
mo.disp = mo.disp.plus(4); 
mo = setSize(mo,4); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Unary.getResult(P(p)), mo));
  }

  /**
   * Emit code for rule number 426:
   * r:      LONG_2INT(LONG_SHR(load64, INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code426(AbstractBURS_TreeNode p) {
    MemoryOperand mo = consumeMO(); 
mo.disp = mo.disp.plus(4); 
mo = setSize(mo,4); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Unary.getResult(P(p)), mo));
  }

  /**
   * Emit code for rule number 427:
   * load32:      LONG_2INT(LONG_USHR(load64, INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code427(AbstractBURS_TreeNode p) {
    MemoryOperand mo = consumeMO(); 
mo.disp = mo.disp.plus(4); 
mo = setSize(mo,4); 
pushMO(mo);
  }

  /**
   * Emit code for rule number 428:
   * load32:      LONG_2INT(LONG_SHR(load64, INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code428(AbstractBURS_TreeNode p) {
    MemoryOperand mo = consumeMO(); 
mo.disp = mo.disp.plus(4); 
mo = setSize(mo,4); 
pushMO(mo);
  }

  /**
   * Emit code for rule number 429:
   * czr:	LONG_ADD(r, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code429(AbstractBURS_TreeNode p) {
    if (Binary.getVal2(P(p)).isLongConstant()) { 
  if (Bits.fits(Binary.getVal2(P(p)).asLongConstant().value, 32)) { 
    EMIT_Commutative(IA32_ADD, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), IC(Binary.getVal2(P(p)).asLongConstant().lower32())); 
  } else { 
    RegisterOperand tmp = regpool.makeTempLong(); 
    EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, tmp, Binary.getClearVal2(P(p))))); 
    EMIT_Commutative(IA32_ADD, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), tmp.copy()); 
  } 
} else { 
EMIT_Commutative(IA32_ADD, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), Binary.getClearVal2(P(p))); 
}
  }

  /**
   * Emit code for rule number 430:
   * czr:	LONG_ADD(r, riv)
   * @param p BURS node to apply the rule to
   */
  private void code430(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_ADD, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), Binary.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 431:
   * czr:    LONG_ADD(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code431(AbstractBURS_TreeNode p) {
    if (Binary.getVal1(P(p)).asRegister().getRegister().isInteger()) { 
RegisterOperand tmp = regpool.makeTempLong(); 
EMIT(CPOS(P(p), MIR_Unary.create(IA32_MOVSXDQ, tmp,Binary.getClearVal1(P(p))))); 
EMIT_Commutative(IA32_ADD, P(p), Binary.getClearResult(P(p)),tmp.copy(), Binary.getClearVal2(P(p))); 
} else if (Binary.getVal2(P(p)).asRegister().getRegister().isInteger()) { 
RegisterOperand tmp = regpool.makeTempLong(); 
EMIT(CPOS(P(p), MIR_Unary.create(IA32_MOVSXDQ, tmp,Binary.getClearVal2(P(p))))); 
EMIT_Commutative(IA32_ADD, P(p), Binary.getClearResult(P(p)),Binary.getClearVal1(P(p)),tmp.copy()); 
} else { 
EMIT_Commutative(IA32_ADD, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), Binary.getClearVal2(P(p))); 
}
  }

  /**
   * Emit code for rule number 432:
   * r:	LONG_ADD(r, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code432(AbstractBURS_TreeNode p) {
    if (Binary.getVal2(P(p)).isLongConstant()) { 
  pushAddress(R(Binary.getClearVal1(P(p))), null, B_S, Offset.fromLong(LV(Binary.getClearVal2(P(p))))); 
} else { 
  pushAddress(R(Binary.getClearVal1(P(p))), R(Binary.getClearVal2(P(p))), B_S, Offset.zero()); 
} 
EMIT_Lea(P(p), Binary.getClearResult(P(p)), consumeAddress(QW, null, null));
  }

  /**
   * Emit code for rule number 433:
   * czr:	LONG_ADD(rlv, load64)
   * @param p BURS node to apply the rule to
   */
  private void code433(AbstractBURS_TreeNode p) {
    if (Binary.getVal1(P(p)).isLongConstant()) { 
RegisterOperand tmp = regpool.makeTempLong(); 
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, tmp,Binary.getClearVal1(P(p))))); 
EMIT_Commutative(IA32_ADD, P(p), Binary.getClearResult(P(p)), tmp.copy(), consumeMO()); 
} else { 
EMIT_Commutative(IA32_ADD, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), consumeMO()); 
}
  }

  /**
   * Emit code for rule number 434:
   * czr:	LONG_ADD(load64, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code434(AbstractBURS_TreeNode p) {
    if (Binary.getVal2(P(p)).isLongConstant()) { 
RegisterOperand tmp = regpool.makeTempLong(); 
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, tmp, Binary.getClearVal2(P(p))))); 
EMIT_Commutative(IA32_ADD, P(p), Binary.getClearResult(P(p)), consumeMO(), tmp.copy()); 
} else { 
EMIT_Commutative(IA32_ADD, P(p), Binary.getClearResult(P(p)), Binary.getClearVal2(P(p)), consumeMO()); 
}
  }

  /**
   * Emit code for rule number 435:
   * stm:	LONG_STORE(LONG_ADD(LONG_LOAD(rlv,rlv),rlv),OTHER_OPERAND(rlv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code435(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_ADD, P(p), MO_S(P(p), QW), MO_S(P(p), QW), Binary.getClearVal2(PL(p)));
  }

  /**
   * Emit code for rule number 436:
   * stm:	LONG_STORE(LONG_ADD(rlv,LONG_LOAD(rlv,rlv)),OTHER_OPERAND(rlv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code436(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_ADD, P(p), MO_S(P(p), QW), MO_S(P(p), QW), Binary.getClearVal1(PL(p)));
  }

  /**
   * Emit code for rule number 437:
   * stm:	LONG_ASTORE(LONG_ADD(LONG_ALOAD(rlv,rlv),rlv),OTHER_OPERAND(rlv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code437(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_ADD, P(p), MO_AS(P(p), QW_S, QW), MO_AS(P(p), QW_S, QW), Binary.getClearVal2(PL(p)));
  }

  /**
   * Emit code for rule number 438:
   * stm:	LONG_ASTORE(LONG_ADD(rlv,LONG_ALOAD(rlv,rlv)),OTHER_OPERAND(rlv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code438(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_ADD, P(p), MO_AS(P(p), QW_S, QW), MO_AS(P(p), QW_S, QW), Binary.getClearVal1(PL(p)));
  }

  /**
   * Emit code for rule number 439:
   * szpr:	LONG_AND(r, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code439(AbstractBURS_TreeNode p) {
    if (Binary.getVal2(P(p)).isLongConstant()) { 
  if (Bits.fits(Binary.getVal2(P(p)).asLongConstant().value, 32)) { 
    EMIT_Commutative(IA32_AND, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), IC(Binary.getVal2(P(p)).asLongConstant().lower32()));   
  } else { 
    Register tmp = regpool.getLong(); 
    EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(tmp, TypeReference.Long), Binary.getClearVal2(P(p))))); 
    EMIT_Commutative(IA32_AND, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), new RegisterOperand(tmp, TypeReference.Long)); 
  } 
}else{
EMIT_Commutative(IA32_AND, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), Binary.getClearVal2(P(p))); 
}
  }

  /**
   * Emit code for rule number 440:
   * szpr:    LONG_AND(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code440(AbstractBURS_TreeNode p) {
    if (Binary.getVal1(P(p)).asRegister().getRegister().isInteger()) { 
RegisterOperand tmp = regpool.makeTempLong(); 
EMIT(CPOS(P(p), MIR_Unary.create(IA32_MOVSXDQ, tmp, Binary.getClearVal1(P(p))))); 
EMIT_Commutative(IA32_AND, P(p), Binary.getClearResult(P(p)), tmp, Binary.getClearVal2(P(p))); 
} else if (Binary.getVal2(P(p)).asRegister().getRegister().isInteger()) { 
RegisterOperand tmp = regpool.makeTempLong(); 
EMIT(CPOS(P(p), MIR_Unary.create(IA32_MOVSXDQ, tmp, Binary.getClearVal2(P(p))))); 
EMIT_Commutative(IA32_AND, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), tmp); 
} else { 
EMIT_Commutative(IA32_AND, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), Binary.getClearVal2(P(p))); 
}
  }

  /**
   * Emit code for rule number 441:
   * szp:	LONG_AND(r, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code441(AbstractBURS_TreeNode p) {
    EMIT(MIR_Test.mutate(P(p), IA32_TEST, Binary.getVal1(P(p)), Binary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 442:
   * szpr:	LONG_AND(rlv, load64)
   * @param p BURS node to apply the rule to
   */
  private void code442(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_AND, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 443:
   * szpr:	LONG_AND(load64, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code443(AbstractBURS_TreeNode p) {
    if (Binary.getVal2(P(p)).isLongConstant()) { 
  if (Bits.fits(Binary.getVal2(P(p)).asLongConstant().value, 32)) { 
    EMIT_Commutative(IA32_AND, P(p), Binary.getClearResult(P(p)), IC(Binary.getVal2(P(p)).asLongConstant().lower32()), consumeMO());   
  } else { 
    Register tmp = regpool.getLong(); 
    EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(tmp, TypeReference.Long), Binary.getClearVal2(P(p))))); 
    EMIT_Commutative(IA32_AND, P(p), Binary.getClearResult(P(p)), new RegisterOperand(tmp, TypeReference.Long), consumeMO()); 
  } 
} else { 
EMIT_Commutative(IA32_AND, P(p), Binary.getClearResult(P(p)), Binary.getClearVal2(P(p)), consumeMO()); 
}
  }

  /**
   * Emit code for rule number 444:
   * szp:	LONG_AND(load8_16_32_64, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code444(AbstractBURS_TreeNode p) {
    EMIT(MIR_Test.mutate(P(p), IA32_TEST, consumeMO(), Binary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 445:
   * szp:	LONG_AND(r, load8_16_32_64)
   * @param p BURS node to apply the rule to
   */
  private void code445(AbstractBURS_TreeNode p) {
    EMIT(MIR_Test.mutate(P(p), IA32_TEST, consumeMO(), Binary.getVal1(P(p))));
  }

  /**
   * Emit code for rule number 446:
   * stm:	LONG_STORE(LONG_AND(LONG_LOAD(rlv,rlv),rlv),OTHER_OPERAND(rlv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code446(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_AND, P(p), MO_S(P(p), QW), MO_S(P(p), QW), Binary.getClearVal2(PL(p)));
  }

  /**
   * Emit code for rule number 447:
   * stm:	LONG_STORE(LONG_AND(r,LONG_LOAD(rlv,rlv)),OTHER_OPERAND(rlv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code447(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_AND, P(p), MO_S(P(p), QW), MO_S(P(p), QW), Binary.getClearVal1(PL(p)));
  }

  /**
   * Emit code for rule number 448:
   * stm:	LONG_ASTORE(LONG_AND(LONG_ALOAD(rlv,rlv),rlv),OTHER_OPERAND(rlv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code448(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_AND, P(p), MO_AS(P(p), QW_S, QW), MO_AS(P(p), QW_S, QW), Binary.getClearVal2(PL(p)));
  }

  /**
   * Emit code for rule number 449:
   * stm:	LONG_ASTORE(LONG_AND(r,LONG_ALOAD(rlv,rlv)),OTHER_OPERAND(rlv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code449(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_AND, P(p), MO_AS(P(p), QW_S, QW), MO_AS(P(p), QW_S, QW), Binary.getClearVal1(PL(p)));
  }

  /**
   * Emit code for rule number 450:
   * r:  LONG_DIV(rlv, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code450(AbstractBURS_TreeNode p) {
    LONG_DIVIDES(P(p), GuardedBinary.getClearResult(P(p)), GuardedBinary.getClearVal1(P(p)), 
            GuardedBinary.getClearVal2(P(p)), true, true);
  }

  /**
   * Emit code for rule number 451:
   * r:  LONG_DIV(rlv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code451(AbstractBURS_TreeNode p) {
    LONG_DIVIDES(P(p), GuardedBinary.getClearResult(P(p)), GuardedBinary.getClearVal1(P(p)), 
            GuardedBinary.getClearVal2(P(p)), true, true);
  }

  /**
   * Emit code for rule number 452:
   * r:  LONG_DIV(riv, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code452(AbstractBURS_TreeNode p) {
    LONG_DIVIDES(P(p), GuardedBinary.getClearResult(P(p)), GuardedBinary.getClearVal1(P(p)), 
            GuardedBinary.getClearVal2(P(p)), true, true);
  }

  /**
   * Emit code for rule number 453:
   * r:  LONG_DIV(rlv, load64)
   * @param p BURS node to apply the rule to
   */
  private void code453(AbstractBURS_TreeNode p) {
    LONG_DIVIDES(P(p), GuardedBinary.getClearResult(P(p)), GuardedBinary.getClearVal1(P(p)), 
            consumeMO(), true, true);
  }

  /**
   * Emit code for rule number 454:
   * r:  LONG_DIV(load64,rlv)
   * @param p BURS node to apply the rule to
   */
  private void code454(AbstractBURS_TreeNode p) {
    LONG_DIVIDES(P(p), GuardedBinary.getClearResult(P(p)), consumeMO(), GuardedBinary.getClearVal2(P(p)), 
           true, true);
  }

  /**
   * Emit code for rule number 455:
   * stm:	LONG_IFCMP(rlv,rlv)
   * @param p BURS node to apply the rule to
   */
  private void code455(AbstractBURS_TreeNode p) {
    if (IfCmp.getVal1(P(p)).isLongConstant()) { 
Register tmp = regpool.getLong(); 
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(tmp, TypeReference.Long),IfCmp.getClearVal1(P(p))))); 
IFCMP(P(p), IfCmp.getClearGuardResult(P(p)), new RegisterOperand(tmp, TypeReference.Long), IfCmp.getClearVal2(P(p)), IfCmp.getCond(P(p))); 
} else if (IfCmp.getVal2(P(p)).isLongConstant()) { 
Register tmp = regpool.getLong(); 
EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(tmp, TypeReference.Long), IfCmp.getClearVal2(P(p))))); 
IFCMP(P(p), IfCmp.getClearGuardResult(P(p)), IfCmp.getClearVal1(P(p)), new RegisterOperand(tmp, TypeReference.Long), IfCmp.getCond(P(p))); 
} else { 
IFCMP(P(p), IfCmp.getClearGuardResult(P(p)), IfCmp.getClearVal1(P(p)), IfCmp.getClearVal2(P(p)), IfCmp.getCond(P(p))); 
}
  }

  /**
   * Emit code for rule number 456:
   * stm:	LONG_IFCMP(r, LONG_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code456(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getClearGuardResult(P(p)), new TrueGuardOperand()))); 
EMIT(CPOS(P(p), MIR_Test.create(IA32_TEST, IfCmp.getVal1(P(p)).copy(), IfCmp.getClearVal1(P(p))))); 
EMIT(MIR_CondBranch.mutate(P(p), IA32_JCC, COND(IfCmp.getCond(P(p))), IfCmp.getClearTarget(P(p)), IfCmp.getClearBranchProfile(P(p))));
  }

  /**
   * Emit code for rule number 457:
   * r:	LONG_LOAD(rlv, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code457(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOV, Load.getResult(P(p)), MO_L(P(p), QW)));
  }

  /**
   * Emit code for rule number 458:
   * r:	LONG_LOAD(rlv, address1scaledreg)
   * @param p BURS node to apply the rule to
   */
  private void code458(AbstractBURS_TreeNode p) {
    augmentAddress(Load.getAddress(P(p))); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Load.getResult(P(p)), 
		     consumeAddress(QW, Load.getLocation(P(p)), Load.getGuard(P(p)))));
  }

  /**
   * Emit code for rule number 459:
   * r:	LONG_LOAD(address1scaledreg, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code459(AbstractBURS_TreeNode p) {
    augmentAddress(Load.getOffset(P(p))); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Load.getResult(P(p)), 
	             consumeAddress(QW, Load.getLocation(P(p)), Load.getGuard(P(p)))));
  }

  /**
   * Emit code for rule number 460:
   * r:	LONG_LOAD(address1scaledreg, address1reg)
   * @param p BURS node to apply the rule to
   */
  private void code460(AbstractBURS_TreeNode p) {
    combineAddresses(); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Load.getResult(P(p)), 
	             consumeAddress(QW, Load.getLocation(P(p)), Load.getGuard(P(p)))));
  }

  /**
   * Emit code for rule number 461:
   * r:	LONG_LOAD(address1reg, address1scaledreg)
   * @param p BURS node to apply the rule to
   */
  private void code461(AbstractBURS_TreeNode p) {
    combineAddresses(); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Load.getResult(P(p)), 
	             consumeAddress(QW, Load.getLocation(P(p)), Load.getGuard(P(p)))));
  }

  /**
   * Emit code for rule number 462:
   * r:	LONG_LOAD(address, LONG_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code462(AbstractBURS_TreeNode p) {
    augmentAddress(Load.getOffset(P(p))); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV, Load.getResult(P(p)), 
	             consumeAddress(QW, Load.getLocation(P(p)), Load.getGuard(P(p)))));
  }

  /**
   * Emit code for rule number 463:
   * r:      LONG_ALOAD(rlv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code463(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOV, ALoad.getResult(P(p)), MO_AL(P(p), QW_S, QW)));
  }

  /**
   * Emit code for rule number 464:
   * r:      LONG_ALOAD(rlv, r)
   * @param p BURS node to apply the rule to
   */
  private void code464(AbstractBURS_TreeNode p) {
    RegisterOperand index = ALoad.getIndex(P(p)).asRegister(); 
if (index.getRegister().isInteger()) { 
CLEAR_UPPER_32(P(p), index.copy().asRegister()); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV, ALoad.getResult(P(p)), MO_AL(P(p), QW_S, QW))); 
} else { 
EMIT(MIR_Move.mutate(P(p), IA32_MOV, ALoad.getResult(P(p)), MO_AL(P(p), QW_S, QW))); 
}
  }

  /**
   * Emit code for rule number 465:
   * r:	LONG_MOVE(rlv)
   * @param p BURS node to apply the rule to
   */
  private void code465(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOV, Move.getResult(P(p)), Move.getVal(P(p))));
  }

  /**
   * Emit code for rule number 466:
   * r:  LONG_MOVE(riv)
   * @param p BURS node to apply the rule to
   */
  private void code466(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOV, Move.getResult(P(p)), Move.getVal(P(p))));
  }

  /**
   * Emit code for rule number 468:
   * r:	LONG_MUL(r, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code468(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_IMUL2, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), Binary.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 469:
   * r:	INT_MUL(r, load64)
   * @param p BURS node to apply the rule to
   */
  private void code469(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_IMUL2, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 470:
   * r:	INT_MUL(load64, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code470(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_IMUL2, P(p), Binary.getClearResult(P(p)), Binary.getClearVal2(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 471:
   * szpr:	LONG_NEG(r)
   * @param p BURS node to apply the rule to
   */
  private void code471(AbstractBURS_TreeNode p) {
    EMIT_Unary(IA32_NEG, P(p), Unary.getClearResult(P(p)), Unary.getClearVal(P(p)));
  }

  /**
   * Emit code for rule number 472:
   * stm:	LONG_STORE(LONG_NEG(LONG_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code472(AbstractBURS_TreeNode p) {
    EMIT_Unary(IA32_NEG, P(p), MO_S(P(p), QW), MO_S(P(p), QW));
  }

  /**
   * Emit code for rule number 473:
   * stm:	LONG_ASTORE(LONG_NEG(LONG_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code473(AbstractBURS_TreeNode p) {
    EMIT_Unary(IA32_NEG, P(p), MO_AS(P(p), QW_S, QW), MO_AS(P(p), QW_S, QW));
  }

  /**
   * Emit code for rule number 474:
   * r:	LONG_NOT(r)
   * @param p BURS node to apply the rule to
   */
  private void code474(AbstractBURS_TreeNode p) {
    EMIT_Unary(IA32_NOT, P(p), Unary.getClearResult(P(p)), Unary.getClearVal(P(p)));
  }

  /**
   * Emit code for rule number 475:
   * stm:	LONG_STORE(LONG_NOT(LONG_LOAD(riv,riv)),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code475(AbstractBURS_TreeNode p) {
    EMIT_Unary(IA32_NOT, P(p), MO_S(P(p), QW), MO_S(P(p), QW));
  }

  /**
   * Emit code for rule number 476:
   * stm:	LONG_ASTORE(LONG_NOT(LONG_ALOAD(riv,riv)),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code476(AbstractBURS_TreeNode p) {
    EMIT_Unary(IA32_NOT, P(p), MO_AS(P(p), QW_S, QW), MO_AS(P(p), QW_S, QW));
  }

  /**
   * Emit code for rule number 477:
   * szpr:	LONG_OR(r, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code477(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_OR, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), Binary.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 478:
   * szpr:	LONG_OR(r, load64)
   * @param p BURS node to apply the rule to
   */
  private void code478(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_OR, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 479:
   * szpr:	LONG_OR(load64, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code479(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_OR, P(p), Binary.getClearResult(P(p)), Binary.getClearVal2(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 480:
   * stm:	LONG_STORE(LONG_OR(LONG_LOAD(rlv,rlv),rlv),OTHER_OPERAND(rlv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code480(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_OR, P(p), MO_S(P(p), QW), MO_S(P(p), QW), Binary.getClearVal2(PL(p)) );
  }

  /**
   * Emit code for rule number 481:
   * stm:	LONG_STORE(LONG_OR(r,LONG_LOAD(rlv,rlv)),OTHER_OPERAND(rlv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code481(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_OR, P(p), MO_S(P(p), QW), MO_S(P(p), QW), Binary.getClearVal1(PL(p)) );
  }

  /**
   * Emit code for rule number 482:
   * stm:	LONG_ASTORE(LONG_OR(LONG_ALOAD(rlv,rlv),rlv),OTHER_OPERAND(rlv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code482(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_OR, P(p), MO_AS(P(p), QW_S, QW), MO_AS(P(p), QW_S, QW), Binary.getClearVal2(PL(p)) );
  }

  /**
   * Emit code for rule number 483:
   * stm:	LONG_ASTORE(LONG_OR(r,LONG_ALOAD(rlv,rlv)),OTHER_OPERAND(rlv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code483(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_OR, P(p), MO_AS(P(p), QW_S, QW), MO_AS(P(p), QW_S, QW), Binary.getClearVal1(PL(p)) );
  }

  /**
   * Emit code for rule number 484:
   * r:  LONG_REM(rlv, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code484(AbstractBURS_TreeNode p) {
    LONG_DIVIDES(P(p), GuardedBinary.getClearResult(P(p)), GuardedBinary.getClearVal1(P(p)), 
            GuardedBinary.getClearVal2(P(p)), false, true);
  }

  /**
   * Emit code for rule number 485:
   * r:  LONG_REM(rlv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code485(AbstractBURS_TreeNode p) {
    LONG_DIVIDES(P(p), GuardedBinary.getClearResult(P(p)), GuardedBinary.getClearVal1(P(p)), 
            GuardedBinary.getClearVal2(P(p)), false, true);
  }

  /**
   * Emit code for rule number 486:
   * r:  LONG_REM(riv, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code486(AbstractBURS_TreeNode p) {
    LONG_DIVIDES(P(p), GuardedBinary.getClearResult(P(p)), GuardedBinary.getClearVal1(P(p)), 
            GuardedBinary.getClearVal2(P(p)), false, true);
  }

  /**
   * Emit code for rule number 487:
   * r:  LONG_REM(rlv, load64)
   * @param p BURS node to apply the rule to
   */
  private void code487(AbstractBURS_TreeNode p) {
    LONG_DIVIDES(P(p), GuardedBinary.getClearResult(P(p)), GuardedBinary.getClearVal1(P(p)), 
            consumeMO(), false, true);
  }

  /**
   * Emit code for rule number 488:
   * r:  LONG_REM(load64,rlv)
   * @param p BURS node to apply the rule to
   */
  private void code488(AbstractBURS_TreeNode p) {
    LONG_DIVIDES(P(p), GuardedBinary.getClearResult(P(p)), consumeMO(), GuardedBinary.getClearVal2(P(p)), 
           false, true);
  }

  /**
   * Emit code for rule number 489:
   * szpr:	LONG_SHL(rlv, INT_AND(r, INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code489(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getClearVal1(PR(p))))); 
EMIT_NonCommutative(IA32_SHL, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), new RegisterOperand(getECX(), TypeReference.Int));
  }

  /**
   * Emit code for rule number 490:
   * szpr:	LONG_SHL(rlv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code490(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getClearVal2(P(p))))); 
EMIT_NonCommutative(IA32_SHL, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), new RegisterOperand(getECX(), TypeReference.Int));
  }

  /**
   * Emit code for rule number 491:
   * szpr:	LONG_SHL(r, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code491(AbstractBURS_TreeNode p) {
    if (VM.VerifyAssertions) VM._assert((VR(p) & 0x7FFFFFFF) <= 63); if(Binary.getVal2(P(p)).asIntConstant().value == 1) { 
 EMIT_Commutative(IA32_ADD, P(p), Binary.getClearResult(P(p)), Binary.getVal1(P(p)).copy(), Binary.getClearVal1(P(p))); 
} else { 
 EMIT_NonCommutative(IA32_SHL, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), Binary.getClearVal2(P(p))); 
}
  }

  /**
   * Emit code for rule number 492:
   * r:	LONG_SHL(r, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code492(AbstractBURS_TreeNode p) {
    pushAddress(null, Binary.getClearVal1(P(p)).asRegister(), LEA_SHIFT(Binary.getClearVal2(P(p))), Offset.zero()); 
EMIT_Lea(P(p), Binary.getClearResult(P(p)), consumeAddress(QW, null, null));
  }

  /**
   * Emit code for rule number 493:
   * szpr:	LONG_SHL(LONG_SHR(r, INT_CONSTANT), INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code493(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_AND, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(PL(p)), IC(0xffffffff << VR(p)));
  }

  /**
   * Emit code for rule number 494:
   * stm:	LONG_STORE(LONG_SHL(LONG_LOAD(riv,riv),INT_AND(r,INT_CONSTANT)),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code494(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getClearVal1(PLR(p))))); 
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHL, MO_S(P(p), QW), new RegisterOperand(getECX(), TypeReference.Int)));
  }

  /**
   * Emit code for rule number 495:
   * stm:	LONG_STORE(LONG_SHL(LONG_LOAD(riv,riv), INT_CONSTANT),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code495(AbstractBURS_TreeNode p) {
    if (VM.VerifyAssertions) VM._assert((VLR(p) & 0x7FFFFFFF) <= 63); 
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHL, MO_S(P(p), QW), Binary.getClearVal2(PL(p))));
  }

  /**
   * Emit code for rule number 496:
   * stm:	LONG_ASTORE(LONG_SHL(LONG_ALOAD(riv,riv),INT_AND(r, INT_CONSTANT)),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code496(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getClearVal1(PLR(p)))); 
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHL, MO_AS(P(p), QW_S, QW), new RegisterOperand(getECX(), TypeReference.Int)));
  }

  /**
   * Emit code for rule number 497:
   * stm:	LONG_ASTORE(LONG_SHL(LONG_ALOAD(riv,riv), INT_CONSTANT),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code497(AbstractBURS_TreeNode p) {
    EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHL, MO_AS(P(p), QW_S, QW), Binary.getClearVal2(PL(p))));
  }

  /**
   * Emit code for rule number 498:
   * szpr:	LONG_SHR(rlv, INT_AND(r, LONG_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code498(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getClearVal1(PR(p))))); 
EMIT_NonCommutative(IA32_SAR, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), new RegisterOperand(getECX(), TypeReference.Int));
  }

  /**
   * Emit code for rule number 499:
   * szpr:	LONG_SHR(rlv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code499(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getClearVal2(P(p))))); 
EMIT_NonCommutative(IA32_SAR, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), new RegisterOperand(getECX(), TypeReference.Int));
  }

  /**
   * Emit code for rule number 500:
   * szpr:	LONG_SHR(rlv, LONG_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code500(AbstractBURS_TreeNode p) {
    if (VM.VerifyAssertions) VM._assert((VR(p) & 0x7FFFFFFF) <= 63); 
EMIT_NonCommutative(IA32_SAR, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), Binary.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 501:
   * stm:	LONG_STORE(LONG_SHR(LONG_LOAD(riv,riv),INT_AND(r,LONG_CONSTANT)),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code501(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getClearVal1(PLR(p))))); 
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SAR, MO_S(P(p), QW), new RegisterOperand(getECX(), TypeReference.Int)));
  }

  /**
   * Emit code for rule number 502:
   * stm:	LONG_STORE(LONG_SHR(LONG_LOAD(riv,riv), LONG_CONSTANT),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code502(AbstractBURS_TreeNode p) {
    if (VM.VerifyAssertions) VM._assert((VLR(p) & 0x7FFFFFFF) <= 63); 
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SAR, MO_S(P(p), QW), Binary.getClearVal2(PL(p))));
  }

  /**
   * Emit code for rule number 503:
   * stm:	LONG_ASTORE(LONG_SHR(LONG_ALOAD(riv,riv),INT_AND(r, LONG_CONSTANT)),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code503(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getClearVal1(PLR(p)))); 
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SAR, MO_AS(P(p), QW_S, QW), new RegisterOperand(getECX(), TypeReference.Int)));
  }

  /**
   * Emit code for rule number 504:
   * stm:	LONG_ASTORE(LONG_SHR(LONG_ALOAD(riv,riv), LONG_CONSTANT),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code504(AbstractBURS_TreeNode p) {
    EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SAR, MO_AS(P(p), QW_S, QW), Binary.getClearVal2(PL(p))));
  }

  /**
   * Emit code for rule number 505:
   * stm:	LONG_STORE(rlv, OTHER_OPERAND(rlv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code505(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOV, MO_S(P(p), QW), Store.getValue(P(p))));
  }

  /**
   * Emit code for rule number 506:
   * stm:	LONG_STORE(rlv, OTHER_OPERAND(rlv, address1scaledreg))
   * @param p BURS node to apply the rule to
   */
  private void code506(AbstractBURS_TreeNode p) {
    augmentAddress(Store.getAddress(P(p))); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV, 
                     consumeAddress(QW, Store.getLocation(P(p)), Store.getGuard(P(p))), 
		     Store.getValue(P(p))));
  }

  /**
   * Emit code for rule number 507:
   * stm:	LONG_STORE(rlv, OTHER_OPERAND(address1scaledreg, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code507(AbstractBURS_TreeNode p) {
    augmentAddress(Store.getOffset(P(p))); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV, 
                     consumeAddress(QW, Store.getLocation(P(p)), Store.getGuard(P(p))), 
		     Store.getValue(P(p))));
  }

  /**
   * Emit code for rule number 508:
   * stm:	LONG_STORE(rlv, OTHER_OPERAND(address1scaledreg, address1reg))
   * @param p BURS node to apply the rule to
   */
  private void code508(AbstractBURS_TreeNode p) {
    combineAddresses(); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV,  
                    consumeAddress(QW, Store.getLocation(P(p)), Store.getGuard(P(p))), 
                    Store.getValue(P(p))));
  }

  /**
   * Emit code for rule number 509:
   * stm:	LONG_STORE(rlv, OTHER_OPERAND(address1reg, address1scaledreg))
   * @param p BURS node to apply the rule to
   */
  private void code509(AbstractBURS_TreeNode p) {
    combineAddresses(); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV,  
                    consumeAddress(QW, Store.getLocation(P(p)), Store.getGuard(P(p))), 
                    Store.getValue(P(p))));
  }

  /**
   * Emit code for rule number 510:
   * stm:	LONG_STORE(rlv, OTHER_OPERAND(address, LONG_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code510(AbstractBURS_TreeNode p) {
    augmentAddress(Store.getOffset(P(p))); 
EMIT(MIR_Move.mutate(P(p), IA32_MOV,  
	             consumeAddress(QW, Store.getLocation(P(p)), Store.getGuard(P(p))), 
		     Store.getValue(P(p))));
  }

  /**
   * Emit code for rule number 511:
   * czr:	LONG_SUB(rlv, r)
   * @param p BURS node to apply the rule to
   */
  private void code511(AbstractBURS_TreeNode p) {
    EMIT_NonCommutative(IA32_SUB, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), Binary.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 512:
   * r:	LONG_SUB(rlv, r)
   * @param p BURS node to apply the rule to
   */
  private void code512(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_UnaryAcc.create(IA32_NEG, Binary.getResult(P(p)).copy()))); 
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_ADD, Binary.getClearResult(P(p)), Binary.getClearVal1(P(p))));
  }

  /**
   * Emit code for rule number 513:
   * r:	LONG_SUB(load64, r)
   * @param p BURS node to apply the rule to
   */
  private void code513(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_UnaryAcc.create(IA32_NEG, Binary.getResult(P(p)).copy()))); 
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_ADD, Binary.getClearResult(P(p)), consumeMO()));
  }

  /**
   * Emit code for rule number 514:
   * czr:	LONG_SUB(rlv, load64)
   * @param p BURS node to apply the rule to
   */
  private void code514(AbstractBURS_TreeNode p) {
    EMIT_NonCommutative(IA32_SUB, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 515:
   * czr:	LONG_SUB(load64, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code515(AbstractBURS_TreeNode p) {
    EMIT_NonCommutative(IA32_SUB, P(p), Binary.getClearResult(P(p)), consumeMO(), Binary.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 516:
   * stm:	LONG_STORE(LONG_SUB(LONG_LOAD(rlv,rlv),rlv),OTHER_OPERAND(rlv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code516(AbstractBURS_TreeNode p) {
    EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SUB, MO_S(P(p), QW), Binary.getClearVal2(PL(p))));
  }

  /**
   * Emit code for rule number 517:
   * stm:	LONG_STORE(LONG_SUB(rlv, LONG_LOAD(rlv,rlv)),OTHER_OPERAND(rlv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code517(AbstractBURS_TreeNode p) {
    MemoryOperand result = MO_S(P(p), QW); 
EMIT(CPOS(P(p), MIR_UnaryAcc.create(IA32_NEG, result))); 
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_ADD, result.copy(), Binary.getClearVal1(PL(p))));
  }

  /**
   * Emit code for rule number 518:
   * stm:	LONG_ASTORE(LONG_SUB(LONG_ALOAD(rlv,rlv),rlv),OTHER_OPERAND(rlv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code518(AbstractBURS_TreeNode p) {
    EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SUB, MO_AS(P(p), QW_S, QW), Binary.getClearVal2(PL(p))));
  }

  /**
   * Emit code for rule number 519:
   * stm:	LONG_ASTORE(LONG_SUB(rlv, LONG_ALOAD(rlv,rlv)),OTHER_OPERAND(rlv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code519(AbstractBURS_TreeNode p) {
    MemoryOperand result = MO_AS(P(p), QW_S, QW); 
EMIT(CPOS(P(p), MIR_UnaryAcc.create(IA32_NEG, result))); 
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_ADD, result.copy(), Binary.getClearVal1(PL(p))));
  }

  /**
   * Emit code for rule number 520:
   * szpr:	LONG_USHR(rlv, LONG_AND(r, LONG_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code520(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getClearVal1(PR(p))))); 
EMIT_NonCommutative(IA32_SHR, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), new RegisterOperand(getECX(), TypeReference.Int));
  }

  /**
   * Emit code for rule number 521:
   * szpr:	LONG_USHR(rlv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code521(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getClearVal2(P(p))))); 
EMIT_NonCommutative(IA32_SHR, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), new RegisterOperand(getECX(), TypeReference.Int));
  }

  /**
   * Emit code for rule number 522:
   * szpr:	LONG_USHR(rlv, LONG_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code522(AbstractBURS_TreeNode p) {
    if (VM.VerifyAssertions) VM._assert((VR(p) & 0x7FFFFFFF) <= 63); 
EMIT_NonCommutative(IA32_SHR, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), Binary.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 523:
   * stm:	LONG_STORE(LONG_USHR(LONG_LOAD(riv,riv),LONG_AND(r,LONG_CONSTANT)),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code523(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getClearVal1(PLR(p))))); 
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHR, MO_S(P(p), QW), new RegisterOperand(getECX(), TypeReference.Int)));
  }

  /**
   * Emit code for rule number 524:
   * stm:	LONG_STORE(LONG_USHR(LONG_LOAD(riv,riv), LONG_CONSTANT),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code524(AbstractBURS_TreeNode p) {
    if (VM.VerifyAssertions) VM._assert((VLR(p) & 0x7FFFFFFF) <= 63); 
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHR, MO_S(P(p), QW), Binary.getClearVal2(PL(p))));
  }

  /**
   * Emit code for rule number 525:
   * stm:	LONG_ASTORE(LONG_USHR(LONG_ALOAD(riv,riv),LONG_AND(r, LONG_CONSTANT)),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code525(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.create(IA32_MOV, new RegisterOperand(getECX(), TypeReference.Int), Binary.getClearVal1(PLR(p)))); 
EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHR, MO_AS(P(p), QW_S, QW), new RegisterOperand(getECX(), TypeReference.Int)));
  }

  /**
   * Emit code for rule number 526:
   * stm:	LONG_ASTORE(LONG_USHR(LONG_ALOAD(riv,riv), LONG_CONSTANT),OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code526(AbstractBURS_TreeNode p) {
    EMIT(MIR_BinaryAcc.mutate(P(p), IA32_SHR, MO_AS(P(p), QW_S, QW), Binary.getClearVal2(PL(p))));
  }

  /**
   * Emit code for rule number 527:
   * szpr:	LONG_XOR(r, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code527(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_XOR, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), Binary.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 528:
   * szpr:	LONG_XOR(r, load64)
   * @param p BURS node to apply the rule to
   */
  private void code528(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_XOR, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 529:
   * szpr:	LONG_XOR(load64, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code529(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_XOR, P(p), Binary.getClearResult(P(p)), Binary.getClearVal2(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 530:
   * stm:	LONG_STORE(LONG_XOR(LONG_LOAD(rlv,rlv),rlv),OTHER_OPERAND(rlv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code530(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_XOR, P(p), MO_S(P(p), QW), MO_S(P(p), QW), Binary.getClearVal2(PL(p)) );
  }

  /**
   * Emit code for rule number 531:
   * stm:	LONG_STORE(LONG_XOR(r,LONG_LOAD(rlv,rlv)),OTHER_OPERAND(rlv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code531(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_XOR, P(p), MO_S(P(p), QW), MO_S(P(p), QW), Binary.getClearVal1(PL(p)) );
  }

  /**
   * Emit code for rule number 532:
   * stm:	LONG_ASTORE(LONG_XOR(LONG_ALOAD(rlv,rlv),rlv),OTHER_OPERAND(rlv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code532(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_XOR, P(p), MO_AS(P(p), QW_S, QW), MO_AS(P(p), QW_S, QW), Binary.getClearVal2(PL(p)) );
  }

  /**
   * Emit code for rule number 533:
   * stm:	LONG_ASTORE(LONG_XOR(r,LONG_ALOAD(rlv,rlv)),OTHER_OPERAND(rlv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code533(AbstractBURS_TreeNode p) {
    EMIT_Commutative(IA32_XOR, P(p), MO_AS(P(p), QW_S, QW), MO_AS(P(p), QW_S, QW), Binary.getClearVal1(PL(p)) );
  }

  /**
   * Emit code for rule number 534:
   * r: FLOAT_ADD(r, r)
   * @param p BURS node to apply the rule to
   */
  private void code534(AbstractBURS_TreeNode p) {
    SSE2_COP(IA32_ADDSS, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), Binary.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 535:
   * r: FLOAT_ADD(r, float_load)
   * @param p BURS node to apply the rule to
   */
  private void code535(AbstractBURS_TreeNode p) {
    SSE2_COP(IA32_ADDSS, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 536:
   * r: FLOAT_ADD(float_load,r)
   * @param p BURS node to apply the rule to
   */
  private void code536(AbstractBURS_TreeNode p) {
    SSE2_COP(IA32_ADDSS, P(p), Binary.getClearResult(P(p)), Binary.getClearVal2(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 537:
   * r: DOUBLE_ADD(r, r)
   * @param p BURS node to apply the rule to
   */
  private void code537(AbstractBURS_TreeNode p) {
    SSE2_COP(IA32_ADDSD, P(p), Binary.getClearResult(P(p)), Binary.getClearVal2(P(p)), Binary.getClearVal1(P(p)));
  }

  /**
   * Emit code for rule number 538:
   * r: DOUBLE_ADD(r, double_load)
   * @param p BURS node to apply the rule to
   */
  private void code538(AbstractBURS_TreeNode p) {
    SSE2_COP(IA32_ADDSD, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 539:
   * r: DOUBLE_ADD(double_load,r)
   * @param p BURS node to apply the rule to
   */
  private void code539(AbstractBURS_TreeNode p) {
    SSE2_COP(IA32_ADDSD, P(p), Binary.getClearResult(P(p)), Binary.getClearVal2(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 540:
   * r: FLOAT_SUB(r, r)
   * @param p BURS node to apply the rule to
   */
  private void code540(AbstractBURS_TreeNode p) {
    SSE2_NCOP(IA32_SUBSS, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), Binary.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 541:
   * r: FLOAT_SUB(r, float_load)
   * @param p BURS node to apply the rule to
   */
  private void code541(AbstractBURS_TreeNode p) {
    SSE2_NCOP(IA32_SUBSS, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 542:
   * r: DOUBLE_SUB(r, r)
   * @param p BURS node to apply the rule to
   */
  private void code542(AbstractBURS_TreeNode p) {
    SSE2_NCOP(IA32_SUBSD, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), Binary.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 543:
   * r: DOUBLE_SUB(r, double_load)
   * @param p BURS node to apply the rule to
   */
  private void code543(AbstractBURS_TreeNode p) {
    SSE2_NCOP(IA32_SUBSD, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 544:
   * r: FLOAT_MUL(r, r)
   * @param p BURS node to apply the rule to
   */
  private void code544(AbstractBURS_TreeNode p) {
    SSE2_COP(IA32_MULSS, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), Binary.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 545:
   * r: FLOAT_MUL(r, float_load)
   * @param p BURS node to apply the rule to
   */
  private void code545(AbstractBURS_TreeNode p) {
    SSE2_COP(IA32_MULSS, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 546:
   * r: FLOAT_MUL(float_load, r)
   * @param p BURS node to apply the rule to
   */
  private void code546(AbstractBURS_TreeNode p) {
    SSE2_COP(IA32_MULSS, P(p), Binary.getClearResult(P(p)), Binary.getClearVal2(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 547:
   * r: DOUBLE_MUL(r, r)
   * @param p BURS node to apply the rule to
   */
  private void code547(AbstractBURS_TreeNode p) {
    SSE2_COP(IA32_MULSD, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), Binary.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 548:
   * r: DOUBLE_MUL(r, double_load)
   * @param p BURS node to apply the rule to
   */
  private void code548(AbstractBURS_TreeNode p) {
    SSE2_COP(IA32_MULSD, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 549:
   * r: DOUBLE_MUL(double_load, r)
   * @param p BURS node to apply the rule to
   */
  private void code549(AbstractBURS_TreeNode p) {
    SSE2_COP(IA32_MULSD, P(p), Binary.getClearResult(P(p)), Binary.getClearVal2(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 550:
   * r: FLOAT_DIV(r, r)
   * @param p BURS node to apply the rule to
   */
  private void code550(AbstractBURS_TreeNode p) {
    SSE2_NCOP(IA32_DIVSS, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), Binary.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 551:
   * r: FLOAT_DIV(r, float_load)
   * @param p BURS node to apply the rule to
   */
  private void code551(AbstractBURS_TreeNode p) {
    SSE2_NCOP(IA32_DIVSS, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 552:
   * r: DOUBLE_DIV(r, r)
   * @param p BURS node to apply the rule to
   */
  private void code552(AbstractBURS_TreeNode p) {
    SSE2_NCOP(IA32_DIVSD, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), Binary.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 553:
   * r: DOUBLE_DIV(r, double_load)
   * @param p BURS node to apply the rule to
   */
  private void code553(AbstractBURS_TreeNode p) {
    SSE2_NCOP(IA32_DIVSD, P(p), Binary.getClearResult(P(p)), Binary.getClearVal1(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 554:
   * r: FLOAT_NEG(r)
   * @param p BURS node to apply the rule to
   */
  private void code554(AbstractBURS_TreeNode p) {
    SSE2_NEG(true, P(p), Unary.getClearResult(P(p)), Unary.getClearVal(P(p)));
  }

  /**
   * Emit code for rule number 555:
   * r: DOUBLE_NEG(r)
   * @param p BURS node to apply the rule to
   */
  private void code555(AbstractBURS_TreeNode p) {
    SSE2_NEG(false, P(p), Unary.getClearResult(P(p)), Unary.getClearVal(P(p)));
  }

  /**
   * Emit code for rule number 556:
   * r: FLOAT_SQRT(r)
   * @param p BURS node to apply the rule to
   */
  private void code556(AbstractBURS_TreeNode p) {
    EMIT(MIR_Unary.mutate(P(p), IA32_SQRTSS, Unary.getClearResult(P(p)), Unary.getClearVal(P(p))));
  }

  /**
   * Emit code for rule number 557:
   * r: DOUBLE_SQRT(r)
   * @param p BURS node to apply the rule to
   */
  private void code557(AbstractBURS_TreeNode p) {
    EMIT(MIR_Unary.mutate(P(p), IA32_SQRTSD, Unary.getClearResult(P(p)), Unary.getClearVal(P(p))));
  }

  /**
   * Emit code for rule number 558:
   * r: FLOAT_REM(r, r)
   * @param p BURS node to apply the rule to
   */
  private void code558(AbstractBURS_TreeNode p) {
    SSE2_X87_REM(P(p));
  }

  /**
   * Emit code for rule number 559:
   * r: DOUBLE_REM(r, r)
   * @param p BURS node to apply the rule to
   */
  private void code559(AbstractBURS_TreeNode p) {
    SSE2_X87_REM(P(p));
  }

  /**
   * Emit code for rule number 560:
   * r: LONG_2FLOAT(r)
   * @param p BURS node to apply the rule to
   */
  private void code560(AbstractBURS_TreeNode p) {
    SSE2_X87_FROMLONG(P(p));
  }

  /**
   * Emit code for rule number 561:
   * r: LONG_2DOUBLE(r)
   * @param p BURS node to apply the rule to
   */
  private void code561(AbstractBURS_TreeNode p) {
    SSE2_X87_FROMLONG(P(p));
  }

  /**
   * Emit code for rule number 562:
   * r: FLOAT_MOVE(r)
   * @param p BURS node to apply the rule to
   */
  private void code562(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOVAPS, Move.getResult(P(p)), Move.getVal(P(p))));
  }

  /**
   * Emit code for rule number 563:
   * r: DOUBLE_MOVE(r)
   * @param p BURS node to apply the rule to
   */
  private void code563(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOVAPD, Move.getResult(P(p)), Move.getVal(P(p))));
  }

  /**
   * Emit code for rule number 564:
   * r: DOUBLE_LOAD(riv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code564(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOVSD, Load.getResult(P(p)), MO_L(P(p), QW)));
  }

  /**
   * Emit code for rule number 565:
   * r: DOUBLE_LOAD(riv, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code565(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOVSD, Load.getResult(P(p)), MO_L(P(p), QW)));
  }

  /**
   * Emit code for rule number 566:
   * r: DOUBLE_LOAD(rlv, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code566(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOVSD, Load.getResult(P(p)), MO_L(P(p), QW)));
  }

  /**
   * Emit code for rule number 567:
   * double_load: DOUBLE_LOAD(riv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code567(AbstractBURS_TreeNode p) {
    pushMO(MO_L(P(p), QW));
  }

  /**
   * Emit code for rule number 568:
   * r: DOUBLE_ALOAD(riv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code568(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOVSD, ALoad.getResult(P(p)), MO_AL(P(p), QW_S, QW)));
  }

  /**
   * Emit code for rule number 569:
   * r: DOUBLE_ALOAD(rlv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code569(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOVSD, ALoad.getResult(P(p)), MO_AL(P(p), QW_S, QW)));
  }

  /**
   * Emit code for rule number 570:
   * double_load: DOUBLE_LOAD(rlv, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code570(AbstractBURS_TreeNode p) {
    pushMO(MO_L(P(p), QW));
  }

  /**
   * Emit code for rule number 571:
   * r: DOUBLE_ALOAD(riv, r)
   * @param p BURS node to apply the rule to
   */
  private void code571(AbstractBURS_TreeNode p) {
    RegisterOperand index=ALoad.getIndex(P(p)).asRegister();
if (VM.BuildFor64Addr && index.getRegister().isInteger()){
CLEAR_UPPER_32(P(p), index.copy().asRegister()); 
EMIT(MIR_Move.mutate(P(p), IA32_MOVSD, ALoad.getResult(P(p)), MO_AL(P(p), QW_S, QW)));
}else{
EMIT(MIR_Move.mutate(P(p), IA32_MOVSD, ALoad.getResult(P(p)), MO_AL(P(p), QW_S, QW)));
}
  }

  /**
   * Emit code for rule number 572:
   * r: DOUBLE_ALOAD(rlv, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code572(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOVSD, ALoad.getResult(P(p)), MO_AL(P(p), QW_S, QW)));
  }

  /**
   * Emit code for rule number 573:
   * double_load: DOUBLE_ALOAD(rlv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code573(AbstractBURS_TreeNode p) {
    pushMO(MO_AL(P(p), QW_S, QW));
  }

  /**
   * Emit code for rule number 574:
   * double_load: DOUBLE_ALOAD(riv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code574(AbstractBURS_TreeNode p) {
    pushMO(MO_AL(P(p), QW_S, QW));
  }

  /**
   * Emit code for rule number 575:
   * r: FLOAT_LOAD(riv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code575(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOVSS, Load.getResult(P(p)), MO_L(P(p), DW)));
  }

  /**
   * Emit code for rule number 576:
   * r: FLOAT_LOAD(rlv, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code576(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOVSS, Load.getResult(P(p)), MO_L(P(p), DW)));
  }

  /**
   * Emit code for rule number 577:
   * float_load: FLOAT_LOAD(riv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code577(AbstractBURS_TreeNode p) {
    pushMO(MO_L(P(p), DW));
  }

  /**
   * Emit code for rule number 578:
   * float_load: FLOAT_ALOAD(rlv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code578(AbstractBURS_TreeNode p) {
    pushMO(MO_AL(P(p), DW_S, DW));
  }

  /**
   * Emit code for rule number 579:
   * r: FLOAT_ALOAD(riv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code579(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOVSS, ALoad.getResult(P(p)), MO_AL(P(p), DW_S, DW)));
  }

  /**
   * Emit code for rule number 580:
   * r: FLOAT_ALOAD(rlv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code580(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOVSS, ALoad.getResult(P(p)), MO_AL(P(p), DW_S, DW)));
  }

  /**
   * Emit code for rule number 581:
   * r: FLOAT_ALOAD(riv, r)
   * @param p BURS node to apply the rule to
   */
  private void code581(AbstractBURS_TreeNode p) {
    RegisterOperand index=ALoad.getIndex(P(p)).asRegister();
if (VM.BuildFor64Addr && index.getRegister().isInteger()){
CLEAR_UPPER_32(P(p), index.copy().asRegister()); 
EMIT(MIR_Move.mutate(P(p), IA32_MOVSS, ALoad.getResult(P(p)), MO_AL(P(p), DW_S, DW)));
}else{
EMIT(MIR_Move.mutate(P(p), IA32_MOVSS, ALoad.getResult(P(p)), MO_AL(P(p), DW_S, DW)));
}
  }

  /**
   * Emit code for rule number 582:
   * r: FLOAT_ALOAD(rlv, rlv)
   * @param p BURS node to apply the rule to
   */
  private void code582(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOVSS, ALoad.getResult(P(p)), MO_AL(P(p), DW_S, DW)));
  }

  /**
   * Emit code for rule number 583:
   * float_load: FLOAT_ALOAD(riv, riv)
   * @param p BURS node to apply the rule to
   */
  private void code583(AbstractBURS_TreeNode p) {
    pushMO(MO_AL(P(p), DW_S, DW));
  }

  /**
   * Emit code for rule number 584:
   * stm: DOUBLE_STORE(r, OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code584(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOVSD, MO_S(P(p), QW), Store.getValue(P(p))));
  }

  /**
   * Emit code for rule number 585:
   * stm: DOUBLE_STORE(r, OTHER_OPERAND(riv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code585(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOVSD, MO_S(P(p), QW), Store.getValue(P(p))));
  }

  /**
   * Emit code for rule number 586:
   * stm: DOUBLE_STORE(r, OTHER_OPERAND(rlv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code586(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOVSD, MO_S(P(p), QW), Store.getValue(P(p))));
  }

  /**
   * Emit code for rule number 587:
   * stm: DOUBLE_STORE(r, OTHER_OPERAND(rlv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code587(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOVSD, MO_S(P(p), QW), Store.getValue(P(p))));
  }

  /**
   * Emit code for rule number 588:
   * stm: DOUBLE_ASTORE(r, OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code588(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOVSD, MO_AS(P(p), QW_S, QW), AStore.getValue(P(p))));
  }

  /**
   * Emit code for rule number 589:
   * stm: DOUBLE_ASTORE(r, OTHER_OPERAND(rlv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code589(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOVSD, MO_AS(P(p), QW_S, QW), AStore.getValue(P(p))));
  }

  /**
   * Emit code for rule number 590:
   * stm: DOUBLE_ASTORE(r, OTHER_OPERAND(riv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code590(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOVSD, MO_AS(P(p), QW_S, QW), AStore.getValue(P(p))));
  }

  /**
   * Emit code for rule number 591:
   * stm: DOUBLE_ASTORE(r, OTHER_OPERAND(rlv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code591(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOVSD, MO_AS(P(p), QW_S, QW), AStore.getValue(P(p))));
  }

  /**
   * Emit code for rule number 592:
   * stm: DOUBLE_ASTORE(r, OTHER_OPERAND(r, r))
   * @param p BURS node to apply the rule to
   */
  private void code592(AbstractBURS_TreeNode p) {
    RegisterOperand index=AStore.getIndex(P(p)).asRegister();
if (VM.BuildFor64Addr && index.getRegister().isInteger()){
CLEAR_UPPER_32(P(p), index.copy().asRegister()); 
EMIT(MIR_Move.mutate(P(p), IA32_MOVSD, MO_AS(P(p), QW_S, QW), AStore.getValue(P(p))));
}else{
EMIT(MIR_Move.mutate(P(p), IA32_MOVSD, MO_AS(P(p), QW_S, QW), AStore.getValue(P(p))));
}
  }

  /**
   * Emit code for rule number 593:
   * stm: FLOAT_STORE(r, OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code593(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOVSS, MO_S(P(p), DW), Store.getValue(P(p))));
  }

  /**
   * Emit code for rule number 594:
   * stm: FLOAT_STORE(r, OTHER_OPERAND(rlv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code594(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOVSS, MO_S(P(p), DW), Store.getValue(P(p))));
  }

  /**
   * Emit code for rule number 595:
   * stm: FLOAT_STORE(r, OTHER_OPERAND(rlv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code595(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOVSS, MO_S(P(p), DW), Store.getValue(P(p))));
  }

  /**
   * Emit code for rule number 596:
   * stm: FLOAT_STORE(r, OTHER_OPERAND(riv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code596(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOVSS, MO_S(P(p), DW), Store.getValue(P(p))));
  }

  /**
   * Emit code for rule number 597:
   * stm: FLOAT_ASTORE(r, OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code597(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOVSS, MO_AS(P(p), DW_S, DW), AStore.getValue(P(p))));
  }

  /**
   * Emit code for rule number 598:
   * stm: FLOAT_ASTORE(r, OTHER_OPERAND(rlv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code598(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOVSS, MO_AS(P(p), DW_S, DW), AStore.getValue(P(p))));
  }

  /**
   * Emit code for rule number 599:
   * stm: FLOAT_ASTORE(r, OTHER_OPERAND(riv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code599(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOVSS, MO_AS(P(p), DW_S, DW), AStore.getValue(P(p))));
  }

  /**
   * Emit code for rule number 600:
   * stm: FLOAT_ASTORE(r, OTHER_OPERAND(rlv, rlv))
   * @param p BURS node to apply the rule to
   */
  private void code600(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), IA32_MOVSS, MO_AS(P(p), DW_S, DW), AStore.getValue(P(p))));
  }

  /**
   * Emit code for rule number 601:
   * stm: FLOAT_ASTORE(r, OTHER_OPERAND(r, r))
   * @param p BURS node to apply the rule to
   */
  private void code601(AbstractBURS_TreeNode p) {
    RegisterOperand index=AStore.getIndex(P(p)).asRegister();
if (VM.BuildFor64Addr && index.getRegister().isInteger()){
CLEAR_UPPER_32(P(p), index.copy().asRegister()); 
EMIT(MIR_Move.mutate(P(p), IA32_MOVSS, MO_AS(P(p), DW_S, DW), AStore.getValue(P(p))));
}else{
EMIT(MIR_Move.mutate(P(p), IA32_MOVSS, MO_AS(P(p), DW_S, DW), AStore.getValue(P(p))));
}
  }

  /**
   * Emit code for rule number 602:
   * r: INT_2FLOAT(riv)
   * @param p BURS node to apply the rule to
   */
  private void code602(AbstractBURS_TreeNode p) {
    SSE2_CONV(IA32_CVTSI2SS, P(p), Unary.getClearResult(P(p)), Unary.getClearVal(P(p)));
  }

  /**
   * Emit code for rule number 603:
   * r: INT_2FLOAT(load32)
   * @param p BURS node to apply the rule to
   */
  private void code603(AbstractBURS_TreeNode p) {
    SSE2_CONV(IA32_CVTSI2SS, P(p), Unary.getClearResult(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 604:
   * r: INT_2DOUBLE(riv)
   * @param p BURS node to apply the rule to
   */
  private void code604(AbstractBURS_TreeNode p) {
    SSE2_CONV(IA32_CVTSI2SD, P(p), Unary.getClearResult(P(p)), Unary.getClearVal(P(p)));
  }

  /**
   * Emit code for rule number 605:
   * r: INT_2DOUBLE(load32)
   * @param p BURS node to apply the rule to
   */
  private void code605(AbstractBURS_TreeNode p) {
    SSE2_CONV(IA32_CVTSI2SD, P(p), Unary.getClearResult(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 606:
   * r: FLOAT_2DOUBLE(r)
   * @param p BURS node to apply the rule to
   */
  private void code606(AbstractBURS_TreeNode p) {
    SSE2_CONV(IA32_CVTSS2SD, P(p), Unary.getClearResult(P(p)), Unary.getClearVal(P(p)));
  }

  /**
   * Emit code for rule number 607:
   * r: FLOAT_2DOUBLE(float_load)
   * @param p BURS node to apply the rule to
   */
  private void code607(AbstractBURS_TreeNode p) {
    SSE2_CONV(IA32_CVTSS2SD, P(p), Unary.getClearResult(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 608:
   * r: DOUBLE_2FLOAT(r)
   * @param p BURS node to apply the rule to
   */
  private void code608(AbstractBURS_TreeNode p) {
    SSE2_CONV(IA32_CVTSD2SS, P(p), Unary.getClearResult(P(p)), Unary.getClearVal(P(p)));
  }

  /**
   * Emit code for rule number 609:
   * r: DOUBLE_2FLOAT(double_load)
   * @param p BURS node to apply the rule to
   */
  private void code609(AbstractBURS_TreeNode p) {
    SSE2_CONV(IA32_CVTSD2SS, P(p), Unary.getClearResult(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 610:
   * r: FLOAT_2INT(r)
   * @param p BURS node to apply the rule to
   */
  private void code610(AbstractBURS_TreeNode p) {
    EMIT(P(p)); /* leave for complex operators */
  }

  /**
   * Emit code for rule number 611:
   * r: FLOAT_2LONG(r)
   * @param p BURS node to apply the rule to
   */
  private void code611(AbstractBURS_TreeNode p) {
    EMIT(P(p)); /* leave for complex operators */
  }

  /**
   * Emit code for rule number 612:
   * r: DOUBLE_2INT(r)
   * @param p BURS node to apply the rule to
   */
  private void code612(AbstractBURS_TreeNode p) {
    EMIT(P(p)); /* leave for complex operators */
  }

  /**
   * Emit code for rule number 613:
   * r: DOUBLE_2LONG(r)
   * @param p BURS node to apply the rule to
   */
  private void code613(AbstractBURS_TreeNode p) {
    EMIT(P(p)); /* leave for complex operators */
  }

  /**
   * Emit code for rule number 614:
   * r: FLOAT_AS_INT_BITS(r)
   * @param p BURS node to apply the rule to
   */
  private void code614(AbstractBURS_TreeNode p) {
    SSE2_FPR2GPR_32(P(p));
  }

  /**
   * Emit code for rule number 616:
   * r: DOUBLE_AS_LONG_BITS(r)
   * @param p BURS node to apply the rule to
   */
  private void code616(AbstractBURS_TreeNode p) {
    SSE2_FPR2GPR_64(P(p));
  }

  /**
   * Emit code for rule number 618:
   * r: INT_BITS_AS_FLOAT(riv)
   * @param p BURS node to apply the rule to
   */
  private void code618(AbstractBURS_TreeNode p) {
    SSE2_GPR2FPR_32(P(p));
  }

  /**
   * Emit code for rule number 620:
   * r: LONG_BITS_AS_DOUBLE(rlv)
   * @param p BURS node to apply the rule to
   */
  private void code620(AbstractBURS_TreeNode p) {
    SSE2_GPR2FPR_64(P(p));
  }

  /**
   * Emit code for rule number 622:
   * r: MATERIALIZE_FP_CONSTANT(any)
   * @param p BURS node to apply the rule to
   */
  private void code622(AbstractBURS_TreeNode p) {
    SSE2_FPCONSTANT(P(p));
  }

  /**
   * Emit code for rule number 623:
   * float_load: MATERIALIZE_FP_CONSTANT(any)
   * @param p BURS node to apply the rule to
   */
  private void code623(AbstractBURS_TreeNode p) {
    pushMO(MO_MC(P(p)));
  }

  /**
   * Emit code for rule number 624:
   * double_load: MATERIALIZE_FP_CONSTANT(any)
   * @param p BURS node to apply the rule to
   */
  private void code624(AbstractBURS_TreeNode p) {
    pushMO(MO_MC(P(p)));
  }

  /**
   * Emit code for rule number 625:
   * stm: CLEAR_FLOATING_POINT_STATE
   * @param p BURS node to apply the rule to
   */
  private void code625(AbstractBURS_TreeNode p) {
    EMIT(MIR_Empty.mutate(P(p), IA32_FNINIT));
  }

  /**
   * Emit code for rule number 626:
   * stm: FLOAT_IFCMP(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code626(AbstractBURS_TreeNode p) {
    SSE2_IFCMP(IA32_UCOMISS, P(p), IfCmp.getClearVal1(P(p)), IfCmp.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 627:
   * stm: FLOAT_IFCMP(r,float_load)
   * @param p BURS node to apply the rule to
   */
  private void code627(AbstractBURS_TreeNode p) {
    SSE2_IFCMP(IA32_UCOMISS, P(p), IfCmp.getClearVal1(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 628:
   * stm: FLOAT_IFCMP(float_load,r)
   * @param p BURS node to apply the rule to
   */
  private void code628(AbstractBURS_TreeNode p) {
    IfCmp.getCond(P(p)).flipOperands(); SSE2_IFCMP(IA32_UCOMISS, P(p), IfCmp.getClearVal2(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 629:
   * stm: DOUBLE_IFCMP(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code629(AbstractBURS_TreeNode p) {
    SSE2_IFCMP(IA32_UCOMISD, P(p), IfCmp.getClearVal1(P(p)), IfCmp.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 630:
   * stm: DOUBLE_IFCMP(r,double_load)
   * @param p BURS node to apply the rule to
   */
  private void code630(AbstractBURS_TreeNode p) {
    SSE2_IFCMP(IA32_UCOMISD, P(p), IfCmp.getClearVal1(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 631:
   * stm: DOUBLE_IFCMP(double_load,r)
   * @param p BURS node to apply the rule to
   */
  private void code631(AbstractBURS_TreeNode p) {
    IfCmp.getCond(P(p)).flipOperands(); SSE2_IFCMP(IA32_UCOMISD, P(p), IfCmp.getClearVal2(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 632:
   * r: FCMP_CMOV(r, OTHER_OPERAND(r, any))
   * @param p BURS node to apply the rule to
   */
  private void code632(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Compare.create(CondMove.getVal1(P(p)).isFloat() ? IA32_UCOMISS : IA32_UCOMISD,      CondMove.getClearVal1(P(p)), CondMove.getClearVal2(P(p))))); CMOV_MOV(P(p), CondMove.getClearResult(P(p)), CondMove.getClearCond(P(p)).translateUNSIGNED(),          CondMove.getClearTrueValue(P(p)), CondMove.getClearFalseValue(P(p)));
  }

  /**
   * Emit code for rule number 633:
   * r: FCMP_CMOV(r, OTHER_OPERAND(float_load, any))
   * @param p BURS node to apply the rule to
   */
  private void code633(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Compare.create(IA32_UCOMISS, CondMove.getClearVal1(P(p)), consumeMO()))); CMOV_MOV(P(p), CondMove.getClearResult(P(p)), CondMove.getClearCond(P(p)).translateUNSIGNED(),          CondMove.getClearTrueValue(P(p)), CondMove.getClearFalseValue(P(p)));
  }

  /**
   * Emit code for rule number 634:
   * r: FCMP_CMOV(r, OTHER_OPERAND(double_load, any))
   * @param p BURS node to apply the rule to
   */
  private void code634(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), MIR_Compare.create(IA32_UCOMISD, CondMove.getClearVal1(P(p)), consumeMO()))); CMOV_MOV(P(p), CondMove.getClearResult(P(p)), CondMove.getClearCond(P(p)).translateUNSIGNED(),          CondMove.getClearTrueValue(P(p)), CondMove.getClearFalseValue(P(p)));
  }

  /**
   * Emit code for rule number 635:
   * r: FCMP_CMOV(float_load, OTHER_OPERAND(r, any))
   * @param p BURS node to apply the rule to
   */
  private void code635(AbstractBURS_TreeNode p) {
    CondMove.getCond(P(p)).flipOperands(); EMIT(CPOS(P(p), MIR_Compare.create(IA32_UCOMISS, CondMove.getClearVal1(P(p)), consumeMO()))); CMOV_MOV(P(p), CondMove.getClearResult(P(p)), CondMove.getClearCond(P(p)).translateUNSIGNED(),          CondMove.getClearTrueValue(P(p)), CondMove.getClearFalseValue(P(p)));
  }

  /**
   * Emit code for rule number 636:
   * r: FCMP_CMOV(double_load, OTHER_OPERAND(r, any))
   * @param p BURS node to apply the rule to
   */
  private void code636(AbstractBURS_TreeNode p) {
    CondMove.getCond(P(p)).flipOperands(); EMIT(CPOS(P(p), MIR_Compare.create(IA32_UCOMISD, CondMove.getClearVal1(P(p)), consumeMO()))); CMOV_MOV(P(p), CondMove.getClearResult(P(p)), CondMove.getClearCond(P(p)).translateUNSIGNED(),          CondMove.getClearTrueValue(P(p)), CondMove.getClearFalseValue(P(p)));
  }

  /**
   * Emit code for rule number 637:
   * r: FCMP_FCMOV(r, OTHER_OPERAND(r, any))
   * @param p BURS node to apply the rule to
   */
  private void code637(AbstractBURS_TreeNode p) {
    SSE2_FCMP_FCMOV(P(p), CondMove.getClearResult(P(p)), CondMove.getClearVal1(P(p)), CondMove.getClearVal2(P(p)),                 CondMove.getClearCond(P(p)), CondMove.getClearTrueValue(P(p)), CondMove.getClearFalseValue(P(p)));
  }

  /**
   * Emit code for rule number 638:
   * r: FCMP_FCMOV(r, OTHER_OPERAND(r, OTHER_OPERAND(r, float_load)))
   * @param p BURS node to apply the rule to
   */
  private void code638(AbstractBURS_TreeNode p) {
    SSE2_FCMP_FCMOV(P(p), CondMove.getClearResult(P(p)), CondMove.getClearVal1(P(p)), CondMove.getClearVal2(P(p)),                 CondMove.getClearCond(P(p)), CondMove.getClearTrueValue(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 639:
   * r: FCMP_FCMOV(r, OTHER_OPERAND(r, OTHER_OPERAND(r, double_load)))
   * @param p BURS node to apply the rule to
   */
  private void code639(AbstractBURS_TreeNode p) {
    SSE2_FCMP_FCMOV(P(p), CondMove.getClearResult(P(p)), CondMove.getClearVal1(P(p)), CondMove.getClearVal2(P(p)),                 CondMove.getClearCond(P(p)), CondMove.getClearTrueValue(P(p)), consumeMO());
  }

  /**
   * Emit code for rule number 640:
   * r: FCMP_FCMOV(r, OTHER_OPERAND(r, OTHER_OPERAND(float_load, r)))
   * @param p BURS node to apply the rule to
   */
  private void code640(AbstractBURS_TreeNode p) {
    SSE2_FCMP_FCMOV(P(p), CondMove.getClearResult(P(p)), CondMove.getClearVal1(P(p)), CondMove.getClearVal2(P(p)),                 CondMove.getClearCond(P(p)), consumeMO(), CondMove.getClearFalseValue(P(p)));
  }

  /**
   * Emit code for rule number 641:
   * r: FCMP_FCMOV(r, OTHER_OPERAND(r, OTHER_OPERAND(double_load, r)))
   * @param p BURS node to apply the rule to
   */
  private void code641(AbstractBURS_TreeNode p) {
    SSE2_FCMP_FCMOV(P(p), CondMove.getClearResult(P(p)), CondMove.getClearVal1(P(p)), CondMove.getClearVal2(P(p)),                 CondMove.getClearCond(P(p)), consumeMO(), CondMove.getClearFalseValue(P(p)));
  }

  /**
   * Emit code for rule number 642:
   * r: FCMP_FCMOV(r, OTHER_OPERAND(float_load, any))
   * @param p BURS node to apply the rule to
   */
  private void code642(AbstractBURS_TreeNode p) {
    SSE2_FCMP_FCMOV(P(p), CondMove.getClearResult(P(p)), CondMove.getClearVal1(P(p)), consumeMO(),                 CondMove.getClearCond(P(p)), CondMove.getClearFalseValue(P(p)), CondMove.getClearTrueValue(P(p)));
  }

  /**
   * Emit code for rule number 643:
   * r: FCMP_FCMOV(r, OTHER_OPERAND(double_load, any))
   * @param p BURS node to apply the rule to
   */
  private void code643(AbstractBURS_TreeNode p) {
    SSE2_FCMP_FCMOV(P(p), CondMove.getClearResult(P(p)), CondMove.getClearVal1(P(p)), consumeMO(),                 CondMove.getClearCond(P(p)), CondMove.getClearFalseValue(P(p)), CondMove.getClearTrueValue(P(p)));
  }

  /**
   * Emit code for rule number 644:
   * r: FCMP_FCMOV(r, OTHER_OPERAND(MATERIALIZE_FP_CONSTANT(INT_CONSTANT), OTHER_OPERAND(r, FLOAT_NEG(r))))
   * @param p BURS node to apply the rule to
   */
  private void code644(AbstractBURS_TreeNode p) {
    SSE2_ABS(true, P(p), CondMove.getClearResult(P(p)), CondMove.getClearVal1(P(p)));
  }

  /**
   * Emit code for rule number 645:
   * r: FCMP_FCMOV(r, OTHER_OPERAND(MATERIALIZE_FP_CONSTANT(LONG_CONSTANT), OTHER_OPERAND(r, FLOAT_NEG(r))))
   * @param p BURS node to apply the rule to
   */
  private void code645(AbstractBURS_TreeNode p) {
    SSE2_ABS(true, P(p), CondMove.getClearResult(P(p)), CondMove.getClearVal1(P(p)));
  }

  /**
   * Emit code for rule number 646:
   * r: FCMP_FCMOV(r, OTHER_OPERAND(MATERIALIZE_FP_CONSTANT(INT_CONSTANT), OTHER_OPERAND(FLOAT_NEG(r), r)))
   * @param p BURS node to apply the rule to
   */
  private void code646(AbstractBURS_TreeNode p) {
    SSE2_ABS(true, P(p), CondMove.getClearResult(P(p)), CondMove.getClearVal1(P(p)));
  }

  /**
   * Emit code for rule number 647:
   * r: FCMP_FCMOV(r, OTHER_OPERAND(MATERIALIZE_FP_CONSTANT(LONG_CONSTANT), OTHER_OPERAND(FLOAT_NEG(r), r)))
   * @param p BURS node to apply the rule to
   */
  private void code647(AbstractBURS_TreeNode p) {
    SSE2_ABS(true, P(p), CondMove.getClearResult(P(p)), CondMove.getClearVal1(P(p)));
  }

  /**
   * Emit code for rule number 648:
   * r: FCMP_FCMOV(MATERIALIZE_FP_CONSTANT(INT_CONSTANT), OTHER_OPERAND(r, OTHER_OPERAND(FLOAT_NEG(r), r)))
   * @param p BURS node to apply the rule to
   */
  private void code648(AbstractBURS_TreeNode p) {
    SSE2_ABS(true, P(p), CondMove.getClearResult(P(p)), CondMove.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 649:
   * r: FCMP_FCMOV(MATERIALIZE_FP_CONSTANT(LONG_CONSTANT), OTHER_OPERAND(r, OTHER_OPERAND(FLOAT_NEG(r), r)))
   * @param p BURS node to apply the rule to
   */
  private void code649(AbstractBURS_TreeNode p) {
    SSE2_ABS(true, P(p), CondMove.getClearResult(P(p)), CondMove.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 650:
   * r: FCMP_FCMOV(MATERIALIZE_FP_CONSTANT(INT_CONSTANT), OTHER_OPERAND(r, OTHER_OPERAND(r, FLOAT_NEG(r))))
   * @param p BURS node to apply the rule to
   */
  private void code650(AbstractBURS_TreeNode p) {
    SSE2_ABS(true, P(p), CondMove.getClearResult(P(p)), CondMove.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 651:
   * r: FCMP_FCMOV(MATERIALIZE_FP_CONSTANT(LONG_CONSTANT), OTHER_OPERAND(r, OTHER_OPERAND(r, FLOAT_NEG(r))))
   * @param p BURS node to apply the rule to
   */
  private void code651(AbstractBURS_TreeNode p) {
    SSE2_ABS(true, P(p), CondMove.getClearResult(P(p)), CondMove.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 652:
   * r: FCMP_FCMOV(r, OTHER_OPERAND(MATERIALIZE_FP_CONSTANT(INT_CONSTANT), OTHER_OPERAND(r, DOUBLE_NEG(r))))
   * @param p BURS node to apply the rule to
   */
  private void code652(AbstractBURS_TreeNode p) {
    SSE2_ABS(false, P(p), CondMove.getClearResult(P(p)), CondMove.getClearVal1(P(p)));
  }

  /**
   * Emit code for rule number 653:
   * r: FCMP_FCMOV(r, OTHER_OPERAND(MATERIALIZE_FP_CONSTANT(LONG_CONSTANT), OTHER_OPERAND(r, DOUBLE_NEG(r))))
   * @param p BURS node to apply the rule to
   */
  private void code653(AbstractBURS_TreeNode p) {
    SSE2_ABS(false, P(p), CondMove.getClearResult(P(p)), CondMove.getClearVal1(P(p)));
  }

  /**
   * Emit code for rule number 654:
   * r: FCMP_FCMOV(r, OTHER_OPERAND(MATERIALIZE_FP_CONSTANT(INT_CONSTANT), OTHER_OPERAND(DOUBLE_NEG(r), r)))
   * @param p BURS node to apply the rule to
   */
  private void code654(AbstractBURS_TreeNode p) {
    SSE2_ABS(false, P(p), CondMove.getClearResult(P(p)), CondMove.getClearVal1(P(p)));
  }

  /**
   * Emit code for rule number 655:
   * r: FCMP_FCMOV(r, OTHER_OPERAND(MATERIALIZE_FP_CONSTANT(LONG_CONSTANT), OTHER_OPERAND(DOUBLE_NEG(r), r)))
   * @param p BURS node to apply the rule to
   */
  private void code655(AbstractBURS_TreeNode p) {
    SSE2_ABS(false, P(p), CondMove.getClearResult(P(p)), CondMove.getClearVal1(P(p)));
  }

  /**
   * Emit code for rule number 656:
   * r: FCMP_FCMOV(MATERIALIZE_FP_CONSTANT(INT_CONSTANT), OTHER_OPERAND(r, OTHER_OPERAND(DOUBLE_NEG(r), r)))
   * @param p BURS node to apply the rule to
   */
  private void code656(AbstractBURS_TreeNode p) {
    SSE2_ABS(false, P(p), CondMove.getClearResult(P(p)), CondMove.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 657:
   * r: FCMP_FCMOV(MATERIALIZE_FP_CONSTANT(LONG_CONSTANT), OTHER_OPERAND(r, OTHER_OPERAND(DOUBLE_NEG(r), r)))
   * @param p BURS node to apply the rule to
   */
  private void code657(AbstractBURS_TreeNode p) {
    SSE2_ABS(false, P(p), CondMove.getClearResult(P(p)), CondMove.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 658:
   * r: FCMP_FCMOV(MATERIALIZE_FP_CONSTANT(INT_CONSTANT), OTHER_OPERAND(r, OTHER_OPERAND(r, DOUBLE_NEG(r))))
   * @param p BURS node to apply the rule to
   */
  private void code658(AbstractBURS_TreeNode p) {
    SSE2_ABS(false, P(p), CondMove.getClearResult(P(p)), CondMove.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 659:
   * r: FCMP_FCMOV(MATERIALIZE_FP_CONSTANT(LONG_CONSTANT), OTHER_OPERAND(r, OTHER_OPERAND(r, DOUBLE_NEG(r))))
   * @param p BURS node to apply the rule to
   */
  private void code659(AbstractBURS_TreeNode p) {
    SSE2_ABS(false, P(p), CondMove.getClearResult(P(p)), CondMove.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 660:
   * stm: LONG_ASTORE(load64, OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code660(AbstractBURS_TreeNode p) {
    RegisterOperand temp = regpool.makeTemp(TypeReference.Double); EMIT(MIR_Move.mutate(PL(p), IA32_MOVQ, temp, consumeMO())); EMIT(MIR_Move.mutate(P(p), IA32_MOVQ, MO_AS(P(p), QW_S, QW), temp.copyRO()));
  }

  /**
   * Emit code for rule number 661:
   * stm: LONG_ASTORE(load64, OTHER_OPERAND(rlv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code661(AbstractBURS_TreeNode p) {
    RegisterOperand temp = regpool.makeTemp(TypeReference.Double); EMIT(MIR_Move.mutate(PL(p), IA32_MOVQ, temp, consumeMO())); EMIT(MIR_Move.mutate(P(p), IA32_MOVQ, MO_AS(P(p), QW_S, QW), temp.copyRO()));
  }

  /**
   * Emit code for rule number 662:
   * stm: LONG_STORE(load64, OTHER_OPERAND(riv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code662(AbstractBURS_TreeNode p) {
    RegisterOperand temp = regpool.makeTemp(TypeReference.Double); EMIT(MIR_Move.mutate(PL(p), IA32_MOVQ, temp, consumeMO())); EMIT(MIR_Move.mutate(P(p), IA32_MOVQ, MO_S(P(p), QW), temp.copyRO()));
  }

  /**
   * Emit code for rule number 663:
   * stm: LONG_STORE(load64, OTHER_OPERAND(rlv, riv))
   * @param p BURS node to apply the rule to
   */
  private void code663(AbstractBURS_TreeNode p) {
    RegisterOperand temp = regpool.makeTemp(TypeReference.Double); EMIT(MIR_Move.mutate(PL(p), IA32_MOVQ, temp, consumeMO())); EMIT(MIR_Move.mutate(P(p), IA32_MOVQ, MO_S(P(p), QW), temp.copyRO()));
  }

  /**
   * Emit code using given rule number
   *
   * @param p the tree that's being emitted
   * @param n the non-terminal goal of that tree
   * @param ruleno the rule that will generate the tree
   */
    @Override
  public void code(AbstractBURS_TreeNode p, int  n, int ruleno) {
    switch(unsortedErnMap[ruleno]) {
    case 16: code16(p); break;
    case 17: code17(p); break;
    case 18: code18(p); break;
    case 19: code19(p); break;
    case 20: code20(p); break;
    case 21: code21(p); break;
    case 22: code22(p); break;
    case 23: code23(p); break;
    case 24: code24(p); break;
    case 26: code26(p); break;
    case 27: code27(p); break;
    case 28: code28(p); break;
    case 29: code29(p); break;
    case 30: code30(p); break;
    case 31: code31(p); break;
    case 32: code32(p); break;
    case 33: code33(p); break;
    case 34: code34(p); break;
    case 35: code35(p); break;
    case 36: code36(p); break;
    case 37: code37(p); break;
    case 38: code38(p); break;
    case 39: code39(p); break;
    case 40: code40(p); break;
    case 41: code41(p); break;
    case 42: code42(p); break;
    case 43: code43(p); break;
    case 44: code44(p); break;
    case 45: code45(p); break;
    case 46: code46(p); break;
    case 47: code47(p); break;
    case 48: code48(p); break;
    case 49: code49(p); break;
    case 50: code50(p); break;
    case 51: code51(p); break;
    case 52: code52(p); break;
    case 53: code53(p); break;
    case 54: code54(p); break;
    case 55: code55(p); break;
    case 56: code56(p); break;
    case 57: code57(p); break;
    case 58: code58(p); break;
    case 59: code59(p); break;
    case 60: code60(p); break;
    case 61: code61(p); break;
    case 62: code62(p); break;
    case 63: code63(p); break;
    case 64: code64(p); break;
    case 65: code65(p); break;
    case 66: code66(p); break;
    case 67: code67(p); break;
    case 68: code68(p); break;
    case 69: code69(p); break;
    case 70: code70(p); break;
    case 71: code71(p); break;
    case 72: code72(p); break;
    case 73: code73(p); break;
    case 74: code74(p); break;
    case 75: code75(p); break;
    case 76: code76(p); break;
    case 77: code77(p); break;
    case 78: code78(p); break;
    case 79: code79(p); break;
    case 80: code80(p); break;
    case 81: code81(p); break;
    case 82: code82(p); break;
    case 83: code83(p); break;
    case 84: code84(p); break;
    case 87: code87(p); break;
    case 88: code88(p); break;
    case 89: code89(p); break;
    case 90: code90(p); break;
    case 91: code91(p); break;
    case 92: code92(p); break;
    case 93: code93(p); break;
    case 94: code94(p); break;
    case 95: code95(p); break;
    case 96: code96(p); break;
    case 97: code97(p); break;
    case 98: code98(p); break;
    case 99: code99(p); break;
    case 100: code100(p); break;
    case 101: code101(p); break;
    case 102: code102(p); break;
    case 103: code103(p); break;
    case 104: code104(p); break;
    case 105: code105(p); break;
    case 106: code106(p); break;
    case 107: code107(p); break;
    case 108: code108(p); break;
    case 109: code109(p); break;
    case 110: code110(p); break;
    case 111: code111(p); break;
    case 112: code112(p); break;
    case 113: code113(p); break;
    case 114: code114(p); break;
    case 115: code115(p); break;
    case 116: code116(p); break;
    case 117: code117(p); break;
    case 118: code118(p); break;
    case 119: code119(p); break;
    case 120: code120(p); break;
    case 121: code121(p); break;
    case 122: code122(p); break;
    case 123: code123(p); break;
    case 124: code124(p); break;
    case 125: code125(p); break;
    case 126: code126(p); break;
    case 127: code127(p); break;
    case 128: code128(p); break;
    case 129: code129(p); break;
    case 130: code130(p); break;
    case 131: code131(p); break;
    case 132: code132(p); break;
    case 133: code133(p); break;
    case 134: code134(p); break;
    case 135: code135(p); break;
    case 136: code136(p); break;
    case 137: code137(p); break;
    case 138: code138(p); break;
    case 139: code139(p); break;
    case 140: code140(p); break;
    case 141: code141(p); break;
    case 142: code142(p); break;
    case 143: code143(p); break;
    case 144: code144(p); break;
    case 145: code145(p); break;
    case 146: code146(p); break;
    case 147: code147(p); break;
    case 148: code148(p); break;
    case 149: code149(p); break;
    case 150: code150(p); break;
    case 151: code151(p); break;
    case 152: code152(p); break;
    case 153: code153(p); break;
    case 154: code154(p); break;
    case 155: code155(p); break;
    case 156: code156(p); break;
    case 157: code157(p); break;
    case 158: code158(p); break;
    case 159: code159(p); break;
    case 160: code160(p); break;
    case 161: code161(p); break;
    case 162: code162(p); break;
    case 163: code163(p); break;
    case 164: code164(p); break;
    case 165: code165(p); break;
    case 166: code166(p); break;
    case 167: code167(p); break;
    case 168: code168(p); break;
    case 169: code169(p); break;
    case 170: code170(p); break;
    case 171: code171(p); break;
    case 172: code172(p); break;
    case 173: code173(p); break;
    case 174: code174(p); break;
    case 175: code175(p); break;
    case 176: code176(p); break;
    case 177: code177(p); break;
    case 179: code179(p); break;
    case 180: code180(p); break;
    case 181: code181(p); break;
    case 182: code182(p); break;
    case 183: code183(p); break;
    case 184: code184(p); break;
    case 185: code185(p); break;
    case 186: code186(p); break;
    case 187: code187(p); break;
    case 188: code188(p); break;
    case 189: code189(p); break;
    case 190: code190(p); break;
    case 191: code191(p); break;
    case 192: code192(p); break;
    case 193: code193(p); break;
    case 194: code194(p); break;
    case 195: code195(p); break;
    case 196: code196(p); break;
    case 197: code197(p); break;
    case 198: code198(p); break;
    case 199: code199(p); break;
    case 200: code200(p); break;
    case 201: code201(p); break;
    case 202: code202(p); break;
    case 203: code203(p); break;
    case 204: code204(p); break;
    case 205: code205(p); break;
    case 206: code206(p); break;
    case 207: code207(p); break;
    case 208: code208(p); break;
    case 209: code209(p); break;
    case 210: code210(p); break;
    case 211: code211(p); break;
    case 212: code212(p); break;
    case 213: code213(p); break;
    case 214: code214(p); break;
    case 215: code215(p); break;
    case 216: code216(p); break;
    case 217: code217(p); break;
    case 218: code218(p); break;
    case 219: code219(p); break;
    case 220: code220(p); break;
    case 221: code221(p); break;
    case 222: code222(p); break;
    case 223: code223(p); break;
    case 224: code224(p); break;
    case 225: code225(p); break;
    case 226: code226(p); break;
    case 227: code227(p); break;
    case 228: code228(p); break;
    case 229: code229(p); break;
    case 230: code230(p); break;
    case 231: code231(p); break;
    case 232: code232(p); break;
    case 233: code233(p); break;
    case 234: code234(p); break;
    case 235: code235(p); break;
    case 236: code236(p); break;
    case 237: code237(p); break;
    case 238: code238(p); break;
    case 239: code239(p); break;
    case 240: code240(p); break;
    case 241: code241(p); break;
    case 242: code242(p); break;
    case 243: code243(p); break;
    case 244: code244(p); break;
    case 245: code245(p); break;
    case 246: code246(p); break;
    case 247: code247(p); break;
    case 248: code248(p); break;
    case 249: code249(p); break;
    case 250: code250(p); break;
    case 251: code251(p); break;
    case 252: code252(p); break;
    case 253: code253(p); break;
    case 254: code254(p); break;
    case 255: code255(p); break;
    case 256: code256(p); break;
    case 257: code257(p); break;
    case 258: code258(p); break;
    case 259: code259(p); break;
    case 260: code260(p); break;
    case 261: code261(p); break;
    case 262: code262(p); break;
    case 263: code263(p); break;
    case 264: code264(p); break;
    case 265: code265(p); break;
    case 266: code266(p); break;
    case 267: code267(p); break;
    case 268: code268(p); break;
    case 269: code269(p); break;
    case 270: code270(p); break;
    case 271: code271(p); break;
    case 272: code272(p); break;
    case 273: code273(p); break;
    case 274: code274(p); break;
    case 275: code275(p); break;
    case 276: code276(p); break;
    case 277: code277(p); break;
    case 278: code278(p); break;
    case 279: code279(p); break;
    case 280: code280(p); break;
    case 281: code281(p); break;
    case 282: code282(p); break;
    case 283: code283(p); break;
    case 284: code284(p); break;
    case 285: code285(p); break;
    case 286: code286(p); break;
    case 287: code287(p); break;
    case 288: code288(p); break;
    case 289: code289(p); break;
    case 291: code291(p); break;
    case 300: code300(p); break;
    case 301: code301(p); break;
    case 302: code302(p); break;
    case 303: code303(p); break;
    case 304: code304(p); break;
    case 305: code305(p); break;
    case 306: code306(p); break;
    case 307: code307(p); break;
    case 308: code308(p); break;
    case 309: code309(p); break;
    case 310: code310(p); break;
    case 311: code311(p); break;
    case 312: code312(p); break;
    case 313: code313(p); break;
    case 314: code314(p); break;
    case 315: code315(p); break;
    case 316: code316(p); break;
    case 317: code317(p); break;
    case 318: code318(p); break;
    case 319: code319(p); break;
    case 320: code320(p); break;
    case 321: code321(p); break;
    case 322: code322(p); break;
    case 323: code323(p); break;
    case 324: code324(p); break;
    case 325: code325(p); break;
    case 326: code326(p); break;
    case 327: code327(p); break;
    case 328: code328(p); break;
    case 329: code329(p); break;
    case 330: code330(p); break;
    case 331: code331(p); break;
    case 332: code332(p); break;
    case 333: code333(p); break;
    case 334: code334(p); break;
    case 335: code335(p); break;
    case 336: code336(p); break;
    case 337: code337(p); break;
    case 338: code338(p); break;
    case 339: code339(p); break;
    case 340: code340(p); break;
    case 341: code341(p); break;
    case 342: code342(p); break;
    case 343: code343(p); break;
    case 344: code344(p); break;
    case 345: code345(p); break;
    case 346: code346(p); break;
    case 347: code347(p); break;
    case 348: code348(p); break;
    case 349: code349(p); break;
    case 350: code350(p); break;
    case 351: code351(p); break;
    case 352: code352(p); break;
    case 353: code353(p); break;
    case 354: code354(p); break;
    case 355: code355(p); break;
    case 356: code356(p); break;
    case 357: code357(p); break;
    case 358: code358(p); break;
    case 359: code359(p); break;
    case 360: code360(p); break;
    case 361: code361(p); break;
    case 362: code362(p); break;
    case 363: code363(p); break;
    case 364: code364(p); break;
    case 365: code365(p); break;
    case 366: code366(p); break;
    case 367: code367(p); break;
    case 368: code368(p); break;
    case 369: code369(p); break;
    case 370: code370(p); break;
    case 371: code371(p); break;
    case 372: code372(p); break;
    case 373: code373(p); break;
    case 374: code374(p); break;
    case 375: code375(p); break;
    case 376: code376(p); break;
    case 377: code377(p); break;
    case 378: code378(p); break;
    case 379: code379(p); break;
    case 380: code380(p); break;
    case 381: code381(p); break;
    case 382: code382(p); break;
    case 383: code383(p); break;
    case 384: code384(p); break;
    case 385: code385(p); break;
    case 386: code386(p); break;
    case 387: code387(p); break;
    case 388: code388(p); break;
    case 389: code389(p); break;
    case 390: code390(p); break;
    case 391: code391(p); break;
    case 392: code392(p); break;
    case 395: code395(p); break;
    case 396: code396(p); break;
    case 397: code397(p); break;
    case 398: code398(p); break;
    case 399: code399(p); break;
    case 400: code400(p); break;
    case 401: code401(p); break;
    case 402: code402(p); break;
    case 403: code403(p); break;
    case 404: code404(p); break;
    case 407: code407(p); break;
    case 408: code408(p); break;
    case 413: code413(p); break;
    case 414: code414(p); break;
    case 415: code415(p); break;
    case 418: code418(p); break;
    case 419: code419(p); break;
    case 420: code420(p); break;
    case 421: code421(p); break;
    case 422: code422(p); break;
    case 423: code423(p); break;
    case 424: code424(p); break;
    case 425: code425(p); break;
    case 426: code426(p); break;
    case 427: code427(p); break;
    case 428: code428(p); break;
    case 429: code429(p); break;
    case 430: code430(p); break;
    case 431: code431(p); break;
    case 432: code432(p); break;
    case 433: code433(p); break;
    case 434: code434(p); break;
    case 435: code435(p); break;
    case 436: code436(p); break;
    case 437: code437(p); break;
    case 438: code438(p); break;
    case 439: code439(p); break;
    case 440: code440(p); break;
    case 441: code441(p); break;
    case 442: code442(p); break;
    case 443: code443(p); break;
    case 444: code444(p); break;
    case 445: code445(p); break;
    case 446: code446(p); break;
    case 447: code447(p); break;
    case 448: code448(p); break;
    case 449: code449(p); break;
    case 450: code450(p); break;
    case 451: code451(p); break;
    case 452: code452(p); break;
    case 453: code453(p); break;
    case 454: code454(p); break;
    case 455: code455(p); break;
    case 456: code456(p); break;
    case 457: code457(p); break;
    case 458: code458(p); break;
    case 459: code459(p); break;
    case 460: code460(p); break;
    case 461: code461(p); break;
    case 462: code462(p); break;
    case 463: code463(p); break;
    case 464: code464(p); break;
    case 465: code465(p); break;
    case 466: code466(p); break;
    case 468: code468(p); break;
    case 469: code469(p); break;
    case 470: code470(p); break;
    case 471: code471(p); break;
    case 472: code472(p); break;
    case 473: code473(p); break;
    case 474: code474(p); break;
    case 475: code475(p); break;
    case 476: code476(p); break;
    case 477: code477(p); break;
    case 478: code478(p); break;
    case 479: code479(p); break;
    case 480: code480(p); break;
    case 481: code481(p); break;
    case 482: code482(p); break;
    case 483: code483(p); break;
    case 484: code484(p); break;
    case 485: code485(p); break;
    case 486: code486(p); break;
    case 487: code487(p); break;
    case 488: code488(p); break;
    case 489: code489(p); break;
    case 490: code490(p); break;
    case 491: code491(p); break;
    case 492: code492(p); break;
    case 493: code493(p); break;
    case 494: code494(p); break;
    case 495: code495(p); break;
    case 496: code496(p); break;
    case 497: code497(p); break;
    case 498: code498(p); break;
    case 499: code499(p); break;
    case 500: code500(p); break;
    case 501: code501(p); break;
    case 502: code502(p); break;
    case 503: code503(p); break;
    case 504: code504(p); break;
    case 505: code505(p); break;
    case 506: code506(p); break;
    case 507: code507(p); break;
    case 508: code508(p); break;
    case 509: code509(p); break;
    case 510: code510(p); break;
    case 511: code511(p); break;
    case 512: code512(p); break;
    case 513: code513(p); break;
    case 514: code514(p); break;
    case 515: code515(p); break;
    case 516: code516(p); break;
    case 517: code517(p); break;
    case 518: code518(p); break;
    case 519: code519(p); break;
    case 520: code520(p); break;
    case 521: code521(p); break;
    case 522: code522(p); break;
    case 523: code523(p); break;
    case 524: code524(p); break;
    case 525: code525(p); break;
    case 526: code526(p); break;
    case 527: code527(p); break;
    case 528: code528(p); break;
    case 529: code529(p); break;
    case 530: code530(p); break;
    case 531: code531(p); break;
    case 532: code532(p); break;
    case 533: code533(p); break;
    case 534: code534(p); break;
    case 535: code535(p); break;
    case 536: code536(p); break;
    case 537: code537(p); break;
    case 538: code538(p); break;
    case 539: code539(p); break;
    case 540: code540(p); break;
    case 541: code541(p); break;
    case 542: code542(p); break;
    case 543: code543(p); break;
    case 544: code544(p); break;
    case 545: code545(p); break;
    case 546: code546(p); break;
    case 547: code547(p); break;
    case 548: code548(p); break;
    case 549: code549(p); break;
    case 550: code550(p); break;
    case 551: code551(p); break;
    case 552: code552(p); break;
    case 553: code553(p); break;
    case 554: code554(p); break;
    case 555: code555(p); break;
    case 556: code556(p); break;
    case 557: code557(p); break;
    case 558: code558(p); break;
    case 559: code559(p); break;
    case 560: code560(p); break;
    case 561: code561(p); break;
    case 562: code562(p); break;
    case 563: code563(p); break;
    case 564: code564(p); break;
    case 565: code565(p); break;
    case 566: code566(p); break;
    case 567: code567(p); break;
    case 568: code568(p); break;
    case 569: code569(p); break;
    case 570: code570(p); break;
    case 571: code571(p); break;
    case 572: code572(p); break;
    case 573: code573(p); break;
    case 574: code574(p); break;
    case 575: code575(p); break;
    case 576: code576(p); break;
    case 577: code577(p); break;
    case 578: code578(p); break;
    case 579: code579(p); break;
    case 580: code580(p); break;
    case 581: code581(p); break;
    case 582: code582(p); break;
    case 583: code583(p); break;
    case 584: code584(p); break;
    case 585: code585(p); break;
    case 586: code586(p); break;
    case 587: code587(p); break;
    case 588: code588(p); break;
    case 589: code589(p); break;
    case 590: code590(p); break;
    case 591: code591(p); break;
    case 592: code592(p); break;
    case 593: code593(p); break;
    case 594: code594(p); break;
    case 595: code595(p); break;
    case 596: code596(p); break;
    case 597: code597(p); break;
    case 598: code598(p); break;
    case 599: code599(p); break;
    case 600: code600(p); break;
    case 601: code601(p); break;
    case 602: code602(p); break;
    case 603: code603(p); break;
    case 604: code604(p); break;
    case 605: code605(p); break;
    case 606: code606(p); break;
    case 607: code607(p); break;
    case 608: code608(p); break;
    case 609: code609(p); break;
    case 610: code610(p); break;
    case 611: code611(p); break;
    case 612: code612(p); break;
    case 613: code613(p); break;
    case 614: code614(p); break;
    case 616: code616(p); break;
    case 618: code618(p); break;
    case 620: code620(p); break;
    case 622: code622(p); break;
    case 623: code623(p); break;
    case 624: code624(p); break;
    case 625: code625(p); break;
    case 626: code626(p); break;
    case 627: code627(p); break;
    case 628: code628(p); break;
    case 629: code629(p); break;
    case 630: code630(p); break;
    case 631: code631(p); break;
    case 632: code632(p); break;
    case 633: code633(p); break;
    case 634: code634(p); break;
    case 635: code635(p); break;
    case 636: code636(p); break;
    case 637: code637(p); break;
    case 638: code638(p); break;
    case 639: code639(p); break;
    case 640: code640(p); break;
    case 641: code641(p); break;
    case 642: code642(p); break;
    case 643: code643(p); break;
    case 644: code644(p); break;
    case 645: code645(p); break;
    case 646: code646(p); break;
    case 647: code647(p); break;
    case 648: code648(p); break;
    case 649: code649(p); break;
    case 650: code650(p); break;
    case 651: code651(p); break;
    case 652: code652(p); break;
    case 653: code653(p); break;
    case 654: code654(p); break;
    case 655: code655(p); break;
    case 656: code656(p); break;
    case 657: code657(p); break;
    case 658: code658(p); break;
    case 659: code659(p); break;
    case 660: code660(p); break;
    case 661: code661(p); break;
    case 662: code662(p); break;
    case 663: code663(p); break;
    default:
      throw new OptimizingCompilerException("BURS", "rule " + ruleno + " without emit code:",
        BURS_Debug.string[unsortedErnMap[ruleno]]);
    }
  }
}
