%{
/*
 *  This file is part of the Jikes RVM project (http://jikesrvm.org).
 *
 *  This file is licensed to You under the Eclipse Public License (EPL);
 *  You may not use this file except in compliance with the License. You
 *  may obtain a copy of the License at
 *
 *      http://www.opensource.org/licenses/eclipse-1.0.php
 *
 *  See the COPYRIGHT.txt file distributed with this work for information
 *  regarding copyright ownership.
 */
//ir.brg

  /**
   * Generate from ir.template and assembled rules files.
   */
%}
%term GET_CAUGHT_EXCEPTION = 0
%term SET_CAUGHT_EXCEPTION = 1
%term NEW = 2
%term NEW_UNRESOLVED = 3
%term NEWARRAY = 4
%term NEWARRAY_UNRESOLVED = 5
%term ATHROW = 6
%term CHECKCAST = 7
%term CHECKCAST_NOTNULL = 8
%term CHECKCAST_UNRESOLVED = 9
%term MUST_IMPLEMENT_INTERFACE = 10
%term INSTANCEOF = 11
%term INSTANCEOF_NOTNULL = 12
%term INSTANCEOF_UNRESOLVED = 13
%term MONITORENTER = 14
%term MONITOREXIT = 15
%term NEWOBJMULTIARRAY = 16
%term GETSTATIC = 17
%term PUTSTATIC = 18
%term GETFIELD = 19
%term PUTFIELD = 20
%term INT_ZERO_CHECK = 21
%term LONG_ZERO_CHECK = 22
%term BOUNDS_CHECK = 23
%term OBJARRAY_STORE_CHECK = 24
%term OBJARRAY_STORE_CHECK_NOTNULL = 25
%term IG_PATCH_POINT = 26
%term IG_CLASS_TEST = 27
%term IG_METHOD_TEST = 28
%term TABLESWITCH = 29
%term LOOKUPSWITCH = 30
%term INT_ALOAD = 31
%term LONG_ALOAD = 32
%term FLOAT_ALOAD = 33
%term DOUBLE_ALOAD = 34
%term REF_ALOAD = 35
%term UBYTE_ALOAD = 36
%term BYTE_ALOAD = 37
%term USHORT_ALOAD = 38
%term SHORT_ALOAD = 39
%term INT_ASTORE = 40
%term LONG_ASTORE = 41
%term FLOAT_ASTORE = 42
%term DOUBLE_ASTORE = 43
%term REF_ASTORE = 44
%term BYTE_ASTORE = 45
%term SHORT_ASTORE = 46
%term INT_IFCMP = 47
%term INT_IFCMP2 = 48
%term LONG_IFCMP = 49
%term FLOAT_IFCMP = 50
%term DOUBLE_IFCMP = 51
%term REF_IFCMP = 52
%term LABEL = 53
%term BBEND = 54
%term UNINT_BEGIN = 55
%term UNINT_END = 56
%term FENCE = 57
%term READ_CEILING = 58
%term WRITE_FLOOR = 59
%term PHI = 60
%term SPLIT = 61
%term PI = 62
%term NOP = 63
%term INT_MOVE = 64
%term LONG_MOVE = 65
%term FLOAT_MOVE = 66
%term DOUBLE_MOVE = 67
%term REF_MOVE = 68
%term GUARD_MOVE = 69
%term INT_COND_MOVE = 70
%term LONG_COND_MOVE = 71
%term FLOAT_COND_MOVE = 72
%term DOUBLE_COND_MOVE = 73
%term REF_COND_MOVE = 74
%term GUARD_COND_MOVE = 75
%term GUARD_COMBINE = 76
%term REF_ADD = 77
%term INT_ADD = 78
%term LONG_ADD = 79
%term FLOAT_ADD = 80
%term DOUBLE_ADD = 81
%term REF_SUB = 82
%term INT_SUB = 83
%term LONG_SUB = 84
%term FLOAT_SUB = 85
%term DOUBLE_SUB = 86
%term INT_MUL = 87
%term LONG_MUL = 88
%term FLOAT_MUL = 89
%term DOUBLE_MUL = 90
%term INT_DIV = 91
%term LONG_DIV = 92
%term UNSIGNED_DIV_64_32 = 93
%term UNSIGNED_REM_64_32 = 94
%term FLOAT_DIV = 95
%term DOUBLE_DIV = 96
%term INT_REM = 97
%term LONG_REM = 98
%term FLOAT_REM = 99
%term DOUBLE_REM = 100
%term REF_NEG = 101
%term INT_NEG = 102
%term LONG_NEG = 103
%term FLOAT_NEG = 104
%term DOUBLE_NEG = 105
%term FLOAT_SQRT = 106
%term DOUBLE_SQRT = 107
%term REF_SHL = 108
%term INT_SHL = 109
%term LONG_SHL = 110
%term REF_SHR = 111
%term INT_SHR = 112
%term LONG_SHR = 113
%term REF_USHR = 114
%term INT_USHR = 115
%term LONG_USHR = 116
%term REF_AND = 117
%term INT_AND = 118
%term LONG_AND = 119
%term REF_OR = 120
%term INT_OR = 121
%term LONG_OR = 122
%term REF_XOR = 123
%term INT_XOR = 124
%term REF_NOT = 125
%term INT_NOT = 126
%term LONG_NOT = 127
%term LONG_XOR = 128
%term INT_2ADDRSigExt = 129
%term INT_2ADDRZerExt = 130
%term LONG_2ADDR = 131
%term ADDR_2INT = 132
%term ADDR_2LONG = 133
%term INT_2LONG = 134
%term INT_2FLOAT = 135
%term INT_2DOUBLE = 136
%term LONG_2INT = 137
%term LONG_2FLOAT = 138
%term LONG_2DOUBLE = 139
%term FLOAT_2INT = 140
%term FLOAT_2LONG = 141
%term FLOAT_2DOUBLE = 142
%term DOUBLE_2INT = 143
%term DOUBLE_2LONG = 144
%term DOUBLE_2FLOAT = 145
%term INT_2BYTE = 146
%term INT_2USHORT = 147
%term INT_2SHORT = 148
%term LONG_CMP = 149
%term FLOAT_CMPL = 150
%term FLOAT_CMPG = 151
%term DOUBLE_CMPL = 152
%term DOUBLE_CMPG = 153
%term RETURN = 154
%term NULL_CHECK = 155
%term GOTO = 156
%term BOOLEAN_NOT = 157
%term BOOLEAN_CMP_INT = 158
%term BOOLEAN_CMP_ADDR = 159
%term BOOLEAN_CMP_LONG = 160
%term BOOLEAN_CMP_FLOAT = 161
%term BOOLEAN_CMP_DOUBLE = 162
%term BYTE_LOAD = 163
%term UBYTE_LOAD = 164
%term SHORT_LOAD = 165
%term USHORT_LOAD = 166
%term REF_LOAD = 167
%term REF_STORE = 168
%term INT_LOAD = 169
%term LONG_LOAD = 170
%term FLOAT_LOAD = 171
%term DOUBLE_LOAD = 172
%term BYTE_STORE = 173
%term SHORT_STORE = 174
%term INT_STORE = 175
%term LONG_STORE = 176
%term FLOAT_STORE = 177
%term DOUBLE_STORE = 178
%term PREPARE_INT = 179
%term PREPARE_ADDR = 180
%term PREPARE_LONG = 181
%term ATTEMPT_INT = 182
%term ATTEMPT_ADDR = 183
%term ATTEMPT_LONG = 184
%term CALL = 185
%term SYSCALL = 186
%term UNIMPLEMENTED_BUT_UNREACHABLE = 187
%term YIELDPOINT_PROLOGUE = 188
%term YIELDPOINT_EPILOGUE = 189
%term YIELDPOINT_BACKEDGE = 190
%term YIELDPOINT_OSR = 191
%term OSR_BARRIER = 192
%term IR_PROLOGUE = 193
%term RESOLVE = 194
%term RESOLVE_MEMBER = 195
%term GET_TIME_BASE = 196
%term INSTRUMENTED_EVENT_COUNTER = 197
%term TRAP_IF = 198
%term TRAP = 199
%term ILLEGAL_INSTRUCTION = 200
%term FLOAT_AS_INT_BITS = 201
%term INT_BITS_AS_FLOAT = 202
%term DOUBLE_AS_LONG_BITS = 203
%term LONG_BITS_AS_DOUBLE = 204
%term ARRAYLENGTH = 205
%term FRAMESIZE = 206
%term GET_OBJ_TIB = 207
%term GET_CLASS_TIB = 208
%term GET_TYPE_FROM_TIB = 209
%term GET_SUPERCLASS_IDS_FROM_TIB = 210
%term GET_DOES_IMPLEMENT_FROM_TIB = 211
%term GET_ARRAY_ELEMENT_TIB_FROM_TIB = 212
%term LOWTABLESWITCH = 213
%term ADDRESS_CONSTANT = 214
%term INT_CONSTANT = 215
%term LONG_CONSTANT = 216
%term REGISTER = 217
%term OTHER_OPERAND = 218
%term NULL = 219
%term BRANCH_TARGET = 220
%term DCBF = 221
%term DCBST = 222
%term DCBT = 223
%term DCBTST = 224
%term DCBZ = 225
%term DCBZL = 226
%term ICBI = 227
%term CALL_SAVE_VOLATILE = 228
%term MIR_START = 229
%term MIR_LOWTABLESWITCH = 230
%term PPC_DATA_INT = 231
%term PPC_DATA_LABEL = 232
%term PPC_ADD = 233
%term PPC_ADDr = 234
%term PPC_ADDC = 235
%term PPC_ADDE = 236
%term PPC_ADDZE = 237
%term PPC_ADDME = 238
%term PPC_ADDIC = 239
%term PPC_ADDICr = 240
%term PPC_SUBF = 241
%term PPC_SUBFr = 242
%term PPC_SUBFC = 243
%term PPC_SUBFCr = 244
%term PPC_SUBFIC = 245
%term PPC_SUBFE = 246
%term PPC_SUBFZE = 247
%term PPC_SUBFME = 248
%term PPC_AND = 249
%term PPC_ANDr = 250
%term PPC_ANDIr = 251
%term PPC_ANDISr = 252
%term PPC_NAND = 253
%term PPC_NANDr = 254
%term PPC_ANDC = 255
%term PPC_ANDCr = 256
%term PPC_OR = 257
%term PPC_ORr = 258
%term PPC_MOVE = 259
%term PPC_ORI = 260
%term PPC_ORIS = 261
%term PPC_NOR = 262
%term PPC_NORr = 263
%term PPC_ORC = 264
%term PPC_ORCr = 265
%term PPC_XOR = 266
%term PPC_XORr = 267
%term PPC_XORI = 268
%term PPC_XORIS = 269
%term PPC_EQV = 270
%term PPC_EQVr = 271
%term PPC_NEG = 272
%term PPC_NEGr = 273
%term PPC_CNTLZW = 274
%term PPC_EXTSB = 275
%term PPC_EXTSBr = 276
%term PPC_EXTSH = 277
%term PPC_EXTSHr = 278
%term PPC_SLW = 279
%term PPC_SLWr = 280
%term PPC_SLWI = 281
%term PPC_SLWIr = 282
%term PPC_SRW = 283
%term PPC_SRWr = 284
%term PPC_SRWI = 285
%term PPC_SRWIr = 286
%term PPC_SRAW = 287
%term PPC_SRAWr = 288
%term PPC_SRAWI = 289
%term PPC_SRAWIr = 290
%term PPC_RLWINM = 291
%term PPC_RLWINMr = 292
%term PPC_RLWIMI = 293
%term PPC_RLWIMIr = 294
%term PPC_RLWNM = 295
%term PPC_RLWNMr = 296
%term PPC_B = 297
%term PPC_BL = 298
%term PPC_BL_SYS = 299
%term PPC_BLR = 300
%term PPC_BCTR = 301
%term PPC_BCTRL = 302
%term PPC_BCTRL_SYS = 303
%term PPC_BCLR = 304
%term PPC_BLRL = 305
%term PPC_BCLRL = 306
%term PPC_BC = 307
%term PPC_BCL = 308
%term PPC_BCOND = 309
%term PPC_BCOND2 = 310
%term PPC_BCCTR = 311
%term PPC_BCC = 312
%term PPC_ADDI = 313
%term PPC_ADDIS = 314
%term PPC_LDI = 315
%term PPC_LDIS = 316
%term PPC_CMP = 317
%term PPC_CMPI = 318
%term PPC_CMPL = 319
%term PPC_CMPLI = 320
%term PPC_CRAND = 321
%term PPC_CRANDC = 322
%term PPC_CROR = 323
%term PPC_CRORC = 324
%term PPC_FMR = 325
%term PPC_FRSP = 326
%term PPC_FCTIW = 327
%term PPC_FCTIWZ = 328
%term PPC_FADD = 329
%term PPC_FADDS = 330
%term PPC_FSQRT = 331
%term PPC_FSQRTS = 332
%term PPC_FABS = 333
%term PPC_FCMPO = 334
%term PPC_FCMPU = 335
%term PPC_FDIV = 336
%term PPC_FDIVS = 337
%term PPC_DIVW = 338
%term PPC_DIVWU = 339
%term PPC_FMUL = 340
%term PPC_FMULS = 341
%term PPC_FSEL = 342
%term PPC_FMADD = 343
%term PPC_FMADDS = 344
%term PPC_FMSUB = 345
%term PPC_FMSUBS = 346
%term PPC_FNMADD = 347
%term PPC_FNMADDS = 348
%term PPC_FNMSUB = 349
%term PPC_FNMSUBS = 350
%term PPC_MULLI = 351
%term PPC_MULLW = 352
%term PPC_MULHW = 353
%term PPC_MULHWU = 354
%term PPC_FNEG = 355
%term PPC_FSUB = 356
%term PPC_FSUBS = 357
%term PPC_LWZ = 358
%term PPC_LWZU = 359
%term PPC_LWZUX = 360
%term PPC_LWZX = 361
%term PPC_LWARX = 362
%term PPC_LBZ = 363
%term PPC_LBZUX = 364
%term PPC_LBZX = 365
%term PPC_LHA = 366
%term PPC_LHAX = 367
%term PPC_LHZ = 368
%term PPC_LHZX = 369
%term PPC_LFD = 370
%term PPC_LFDX = 371
%term PPC_LFS = 372
%term PPC_LFSX = 373
%term PPC_LMW = 374
%term PPC_STW = 375
%term PPC_STWX = 376
%term PPC_STWCXr = 377
%term PPC_STWU = 378
%term PPC_STB = 379
%term PPC_STBX = 380
%term PPC_STH = 381
%term PPC_STHX = 382
%term PPC_STFD = 383
%term PPC_STFDX = 384
%term PPC_STFDU = 385
%term PPC_STFS = 386
%term PPC_STFSX = 387
%term PPC_STFSU = 388
%term PPC_STMW = 389
%term PPC_TW = 390
%term PPC_TWI = 391
%term PPC_MFSPR = 392
%term PPC_MTSPR = 393
%term PPC_MFTB = 394
%term PPC_MFTBU = 395
%term PPC_HWSYNC = 396
%term PPC_SYNC = 397
%term PPC_ISYNC = 398
%term PPC_DCBF = 399
%term PPC_DCBST = 400
%term PPC_DCBT = 401
%term PPC_DCBTST = 402
%term PPC_DCBZ = 403
%term PPC_DCBZL = 404
%term PPC_ICBI = 405
%term PPC64_EXTSW = 406
%term PPC64_EXTSWr = 407
%term PPC64_EXTZW = 408
%term PPC64_RLDICL = 409
%term PPC64_RLDICR = 410
%term PPC64_SLD = 411
%term PPC64_SLDr = 412
%term PPC64_SLDI = 413
%term PPC64_SRD = 414
%term PPC64_SRDr = 415
%term PPC64_SRAD = 416
%term PPC64_SRADr = 417
%term PPC64_SRADI = 418
%term PPC64_SRADIr = 419
%term PPC64_SRDI = 420
%term PPC64_RLDIMI = 421
%term PPC64_RLDIMIr = 422
%term PPC64_CMP = 423
%term PPC64_CMPI = 424
%term PPC64_CMPL = 425
%term PPC64_CMPLI = 426
%term PPC64_FCFID = 427
%term PPC64_FCTIDZ = 428
%term PPC64_DIVD = 429
%term PPC64_MULLD = 430
%term PPC64_LD = 431
%term PPC64_LDX = 432
%term PPC64_STD = 433
%term PPC64_STDX = 434
%term PPC64_TD = 435
%term PPC64_TDI = 436
%term PPC_CNTLZAddr = 437
%term PPC_SRAAddrI = 438
%term PPC_SRAddrI = 439
%term PPC64_LWA = 440
%term PPC_LInt = 441
%term PPC64_LWAX = 442
%term PPC_LIntX = 443
%term PPC_LIntUX = 444
%term PPC_LAddr = 445
%term PPC_LAddrX = 446
%term PPC_LAddrU = 447
%term PPC_LAddrUX = 448
%term PPC_LAddrARX = 449
%term PPC_STAddr = 450
%term PPC_STAddrX = 451
%term PPC_STAddrU = 452
%term PPC_STAddrUX = 453
%term PPC_STAddrCXr = 454
%term PPC_TAddr = 455
%term PPC_ILLEGAL_INSTRUCTION = 456
%term MIR_END = 457
%%
stm: r		"" 0
r: REGISTER		"" 0
r: czr		"" 0
r: rs		"" 0
r: rz		"" 0
rs: rp		"" 0
rz: rp		"" 0
any: NULL		"" 0
any: r		"" 0
any: ADDRESS_CONSTANT		"" 0
any: INT_CONSTANT		"" 0
any: LONG_CONSTANT		"" 0
any: OTHER_OPERAND(any, any)		"" 0
stm: RESOLVE		"" 10
stm: IG_PATCH_POINT		"" 10
stm: UNINT_BEGIN		"" 10
stm: UNINT_END		"" 10
stm: YIELDPOINT_PROLOGUE		"" 10
stm: YIELDPOINT_EPILOGUE		"" 10
stm: YIELDPOINT_BACKEDGE		"" 10
r: FRAMESIZE		"" 10
stm: LOWTABLESWITCH(r)		"" 10
stm: NOP		"" 10
r: GUARD_MOVE		"" 11
r: GUARD_COMBINE		"" 11
stm: NULL_CHECK(r)		"" 11
r: GET_CAUGHT_EXCEPTION		"" 11
stm: SET_CAUGHT_EXCEPTION(r)		"" 11
stm: FENCE		"" 11
stm: WRITE_FLOOR		"" 11
stm: READ_CEILING		"" 11
stm: DCBF(r)		"" 11
stm: DCBST(r)		"" 11
stm: DCBT(r)		"" 11
stm: DCBTST(r)		"" 11
stm: DCBZ(r)		"" 11
stm: DCBZL(r)		"" 11
stm: ICBI(r)		"" 11
stm:   ILLEGAL_INSTRUCTION		"" 11
stm: TRAP		"" 10
stm: TRAP_IF(r,r)		"" 10
stm: TRAP_IF(r,INT_CONSTANT)		"" 10
stm: TRAP_IF(r,LONG_CONSTANT)		"" 10
r: BOOLEAN_NOT(r)		"" 11
r: BOOLEAN_CMP_INT(r,INT_CONSTANT)		"" 10
r: BOOLEAN_CMP_INT(r,r)		"" 10
boolcmp: BOOLEAN_CMP_INT(r,INT_CONSTANT)		"" 0
boolcmp: BOOLEAN_CMP_INT(r,r)		"" 0
r: BOOLEAN_CMP_ADDR(r,INT_CONSTANT)		"" 10
r: BOOLEAN_CMP_ADDR(r,r)		"" 10
boolcmp: BOOLEAN_CMP_ADDR(r,INT_CONSTANT)		"" 0
boolcmp: BOOLEAN_CMP_ADDR(r,r)		"" 0
boolcmp: BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)		"" (VR(p) == 1 && BooleanCmp.getCond(P(p)).isEQUAL()?0:INFINITE)
boolcmp: BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)		"" (VR(p) == 1 && BooleanCmp.getCond(P(p)).isNOT_EQUAL()?0:INFINITE)
boolcmp: BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)		"" (VR(p) == 0 && BooleanCmp.getCond(P(p)).isNOT_EQUAL()?0:INFINITE)
boolcmp: BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)		"" (VR(p) == 0 && BooleanCmp.getCond(P(p)).isEQUAL()?0:INFINITE)
r: BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)		"" (VR(p) == 1 && BooleanCmp.getCond(P(p)).isEQUAL()?10:INFINITE)
r: BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)		"" (VR(p) == 1 && BooleanCmp.getCond(P(p)).isNOT_EQUAL()?10:INFINITE)
r: BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)		"" (VR(p) == 0 && BooleanCmp.getCond(P(p)).isNOT_EQUAL()?10:INFINITE)
r: BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)		"" (VR(p) == 0 && BooleanCmp.getCond(P(p)).isEQUAL()?10:INFINITE)
r: REF_ADD(r,INT_CONSTANT)		"" 11
r: REF_ADD(r,r)		"" 11
r: REF_ADD(r,REF_MOVE(INT_CONSTANT))		"" 20
r: REF_ADD(r,REF_MOVE(INT_CONSTANT))		"" (U16(IV(Move.getVal(PR(p))))?10:INFINITE)
r: REF_SUB(r,r)		"" 11
r: REF_SUB(INT_CONSTANT,r)		"" (SI16(IV(Binary.getVal1(P(p))))?11:INFINITE)
r: INT_MUL(r,INT_CONSTANT)		"" 11
r: INT_MUL(r,r)		"" 11
r: INT_DIV(r,r)		"" 20
r: INT_DIV(r,REF_MOVE(INT_CONSTANT))		"" 20
r: INT_REM(r,r)		"" 20
r: INT_REM(r,REF_MOVE(INT_CONSTANT))		"" 20
r: REF_NEG(r)		"" 11
rz: INT_SHL(r,INT_CONSTANT)		"" 10
rz: INT_SHL(r,r)		"" 20
rz: INT_SHL(INT_USHR(r,INT_CONSTANT),INT_CONSTANT)		"" 10
rs: INT_SHR(r,INT_CONSTANT)		"" 10
rs: INT_SHR(r,r)		"" 20
rp: INT_SHR(REF_AND(r,INT_CONSTANT),INT_CONSTANT)		"" (POSITIVE_MASK(IV(Binary.getVal2(PL(p))))?10:INFINITE)
rp: INT_USHR(r,INT_CONSTANT)		"" 10
rz: INT_USHR(r,r)		"" 20
rp: INT_USHR(REF_AND(r,INT_CONSTANT),INT_CONSTANT)		"" (POSITIVE_MASK(IV(Binary.getVal2(PL(p))))?10:INFINITE)
rp: INT_USHR(REF_AND(r,REF_MOVE(INT_CONSTANT)),INT_CONSTANT)		"" (POSITIVE_MASK(IV(Move.getVal(PLR(p))))?10:INFINITE)
rp: INT_USHR(INT_SHL(r,INT_CONSTANT),INT_CONSTANT)		"" 10
r: REF_AND(r,r)		"" 10
czr: REF_AND(r,INT_CONSTANT)		"" 11
rp: REF_AND(r,INT_CONSTANT)		"" (MASK(IV(Binary.getVal2(P(p))))?10:INFINITE)
r: REF_AND(REF_NOT(r),REF_NOT(r))		"" 10
r: REF_AND(r,REF_NOT(r))		"" 10
rp: REF_AND(INT_USHR(r,INT_CONSTANT),INT_CONSTANT)		"" (POSITIVE_MASK(IV(Binary.getVal2(P(p))))?10:INFINITE)
rp: REF_AND(INT_USHR(r,INT_CONSTANT),REF_MOVE(INT_CONSTANT))		"" (POSITIVE_MASK(IV(Move.getVal(PR(p))))?10:INFINITE)
r: REF_OR(r,r)		"" 10
r: REF_OR(r,INT_CONSTANT)		"" 10
r: REF_OR(REF_NOT(r),REF_NOT(r))		"" 10
r: REF_OR(r,REF_NOT(r))		"" 10
r: REF_XOR(r,r)		"" 10
r: REF_XOR(r,INT_CONSTANT)		"" 10
r: REF_NOT(r)		"" 10
r: REF_NOT(REF_OR(r,r))		"" 10
r: REF_NOT(REF_AND(r,r))		"" 10
r: REF_NOT(REF_XOR(r,r))		"" 10
r: FLOAT_ADD(r,r)		"" 10
r: DOUBLE_ADD(r,r)		"" 10
r: FLOAT_MUL(r,r)		"" 10
r: DOUBLE_MUL(r,r)		"" 10
r: FLOAT_SUB(r,r)		"" 10
r: DOUBLE_SUB(r,r)		"" 10
r: FLOAT_DIV(r,r)		"" 10
r: DOUBLE_DIV(r,r)		"" 10
r: FLOAT_NEG(r)		"" 10
r: DOUBLE_NEG(r)		"" 10
r: FLOAT_SQRT(r)		"" 10
r: DOUBLE_SQRT(r)		"" 10
r:  FLOAT_ADD(FLOAT_MUL(r, r), r)		"" (IR.strictFP(P(p),PL(p))?INFINITE:10)
r:  DOUBLE_ADD(DOUBLE_MUL(r, r), r)		"" (IR.strictFP(P(p),PL(p))?INFINITE:10)
r: FLOAT_ADD(r, FLOAT_MUL(r,r))		"" (IR.strictFP(P(p),PR(p))?INFINITE:10)
r: DOUBLE_ADD(r, DOUBLE_MUL(r,r))		"" (IR.strictFP(P(p),PR(p))?INFINITE:10)
r:  FLOAT_SUB(FLOAT_MUL(r, r), r)		"" (IR.strictFP(P(p),PL(p))?INFINITE:10)
r:  DOUBLE_SUB(DOUBLE_MUL(r, r), r)		"" (IR.strictFP(P(p),PL(p))?INFINITE:10)
r:  FLOAT_NEG(FLOAT_ADD(FLOAT_MUL(r, r), r))		"" (IR.strictFP(P(p),PL(p),PLL(p))?INFINITE:10)
r:  DOUBLE_NEG(DOUBLE_ADD(DOUBLE_MUL(r, r), r))		"" (IR.strictFP(P(p),PL(p),PLL(p))?INFINITE:10)
r: FLOAT_NEG(FLOAT_ADD(r, FLOAT_MUL(r,r)))		"" (IR.strictFP(P(p),PL(p),PLR(p))?INFINITE:10)
r: DOUBLE_NEG(DOUBLE_ADD(r, DOUBLE_MUL(r,r)))		"" (IR.strictFP(P(p),PL(p),PLR(p))?INFINITE:10)
r:  FLOAT_NEG(FLOAT_SUB(FLOAT_MUL(r, r), r))		"" (IR.strictFP(P(p),PL(p),PLL(p))?INFINITE:10)
r:  DOUBLE_NEG(DOUBLE_SUB(DOUBLE_MUL(r, r), r))		"" (IR.strictFP(P(p),PL(p),PLL(p))?INFINITE:10)
rs: INT_2BYTE(r)		"" 10
rp: INT_2USHORT(r)		"" 20
rs: INT_2SHORT(r)		"" 10
r: INT_2FLOAT(r)		"" 10
r: INT_2DOUBLE(r)		"" 10
r: FLOAT_2INT(r)		"" 10
r: FLOAT_2DOUBLE(r)		"" 10
r: DOUBLE_2INT(r)		"" 10
r: DOUBLE_2FLOAT(r)		"" 10
r: FLOAT_AS_INT_BITS(r)		"" 20
r: INT_BITS_AS_FLOAT(r)		"" 20
r: REF_MOVE(r)		"" 11
rs: REF_MOVE(INT_CONSTANT)		"" (SI16(IV(Move.getVal(P(p))))?11:INFINITE)
rs: REF_MOVE(INT_CONSTANT)		"" (U16(IV(Move.getVal(P(p))))?11:INFINITE)
rs: REF_MOVE(INT_CONSTANT)		"" 22
r: FLOAT_MOVE(r)		"" 10
r: DOUBLE_MOVE(r)		"" 10
rs: BYTE_LOAD(r,INT_CONSTANT)		"" 22
rs: BYTE_LOAD(r,r)		"" 22
rp: REF_AND(BYTE_LOAD(r,r),INT_CONSTANT)		"" (VR(p) == 0xff ? 10 : INFINITE)
rp: REF_AND(BYTE_LOAD(r,INT_CONSTANT),INT_CONSTANT)		"" (VR(p) == 0xff ? 10 : INFINITE)
rp: UBYTE_LOAD(r,INT_CONSTANT)		"" 11
rp: UBYTE_LOAD(r,r)		"" 11
rs: SHORT_LOAD(r,INT_CONSTANT)		"" 11
rs: SHORT_LOAD(r,r)		"" 11
rp: USHORT_LOAD(r,INT_CONSTANT)		"" 11
rp: USHORT_LOAD(r,r)		"" 11
r: FLOAT_LOAD(r,INT_CONSTANT)		"" 11
r:      FLOAT_LOAD(r,REF_MOVE(ADDRESS_CONSTANT))		"" FITS(Move.getVal(PR(p)),32,22)
r: FLOAT_LOAD(r,r)		"" 11
r: DOUBLE_LOAD(r,INT_CONSTANT)		"" 11
r:      DOUBLE_LOAD(r,REF_MOVE(ADDRESS_CONSTANT))		"" FITS(Move.getVal(PR(p)),32,22)
r: DOUBLE_LOAD(r,r)		"" 11
rs:      INT_LOAD(r,INT_CONSTANT)		"" 11
rs:      INT_LOAD(r,REF_MOVE(ADDRESS_CONSTANT))		"" FITS(Move.getVal(PR(p)),32,22)
rs:      INT_LOAD(r,r)		"" 11
rs:      INT_LOAD(REF_ADD(r,r),INT_CONSTANT)		"" isZERO(VR(p), 11)
rs:      INT_LOAD(REF_ADD(r,INT_CONSTANT),INT_CONSTANT)		"" (SI16(VR(p)+VLR(p)) ? 14 : INFINITE)
stm: BYTE_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))		"" 11
stm: BYTE_STORE(r,OTHER_OPERAND(r,r))		"" 11
stm: BYTE_STORE(INT_2BYTE(r),OTHER_OPERAND(r,INT_CONSTANT))		"" 11
stm: BYTE_STORE(INT_2BYTE(r),OTHER_OPERAND(r,r))		"" 11
stm: SHORT_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))		"" 11
stm: SHORT_STORE(r,OTHER_OPERAND(r,r))		"" 11
stm: SHORT_STORE(INT_2SHORT(r),OTHER_OPERAND(r,INT_CONSTANT))		"" 11
stm: SHORT_STORE(INT_2SHORT(r),OTHER_OPERAND(r,r))		"" 11
stm: SHORT_STORE(INT_2USHORT(r),OTHER_OPERAND(r,INT_CONSTANT))		"" 11
stm: SHORT_STORE(INT_2USHORT(r),OTHER_OPERAND(r,r))		"" 11
stm: INT_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))		"" 11
stm: INT_STORE(r,OTHER_OPERAND(r,REF_MOVE(ADDRESS_CONSTANT)))		"" FITS(Move.getVal(PRR(p)),32,22)
stm: INT_STORE(r,OTHER_OPERAND(r,r))		"" 11
stm: INT_STORE(r,OTHER_OPERAND(REF_ADD(r,INT_CONSTANT),INT_CONSTANT))		"" (SI16(VRR(p)+VRLR(p))?14:INFINITE)
stm: FLOAT_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))		"" 11
stm:      FLOAT_STORE(r,OTHER_OPERAND(r,REF_MOVE(ADDRESS_CONSTANT)))		"" FITS(Move.getVal(PRR(p)),32,22)
stm: FLOAT_STORE(r,OTHER_OPERAND(r,r))		"" 11
stm: DOUBLE_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))		"" 11
stm:      DOUBLE_STORE(r,OTHER_OPERAND(r,REF_MOVE(ADDRESS_CONSTANT)))		"" FITS(Move.getVal(PRR(p)),32,22)
stm: DOUBLE_STORE(r,OTHER_OPERAND(r,r))		"" 11
stm: INT_IFCMP(r,r)		"" 20
stm: INT_IFCMP(r,INT_CONSTANT)		"" 20
stm: INT_IFCMP(INT_2BYTE(r),INT_CONSTANT)		"" ((!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE)
stm: INT_IFCMP(INT_2SHORT(r),INT_CONSTANT)		"" ((!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE)
stm: INT_IFCMP(INT_USHR(r,r),INT_CONSTANT)		"" ((!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE)
stm: INT_IFCMP(INT_SHL(r,r),INT_CONSTANT)		"" ((!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE)
stm: INT_IFCMP(INT_SHR(r,r),INT_CONSTANT)		"" ((!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE)
stm: INT_IFCMP(INT_USHR(r,INT_CONSTANT),INT_CONSTANT)		"" ((!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE)
stm: INT_IFCMP(INT_SHL(r,INT_CONSTANT),INT_CONSTANT)		"" ((!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE)
stm: INT_IFCMP(INT_SHR(r,INT_CONSTANT),INT_CONSTANT)		"" ((!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE)
stm: INT_IFCMP(REF_AND(r,INT_CONSTANT),INT_CONSTANT)		"" ((!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE)
stm: INT_IFCMP(boolcmp, INT_CONSTANT)		"" (VR(p) == 0 && IfCmp.getCond(P(p)).isNOT_EQUAL()?20:INFINITE)
stm: INT_IFCMP(boolcmp, INT_CONSTANT)		"" (VR(p) == 0 && IfCmp.getCond(P(p)).isEQUAL()?20:INFINITE)
stm: INT_IFCMP(boolcmp, INT_CONSTANT)		"" (VR(p) == 1 && IfCmp.getCond(P(p)).isEQUAL()?20:INFINITE)
stm: INT_IFCMP(boolcmp, INT_CONSTANT)		"" (VR(p) == 1 && (IfCmp.getCond(P(p)).isNOT_EQUAL())?26:INFINITE)
stm: INT_IFCMP2(r,r)		"" 20
stm: INT_IFCMP2(r,INT_CONSTANT)		"" 20
stm:   FLOAT_IFCMP(r,r)		"" 20
stm:   DOUBLE_IFCMP(r,r)		"" 20
stm: FLOAT_CMPL(r,r)		"" 40
stm: FLOAT_CMPG(r,r)		"" 40
stm: DOUBLE_CMPL(r,r)		"" 40
stm: DOUBLE_CMPG(r,r)		"" 40
stm: GOTO		"" 11
stm: RETURN(NULL)		"" 10
stm: RETURN(r)		"" 10
r: CALL(r,any)		"" 10
r: CALL(BRANCH_TARGET,any)		"" 10
r: SYSCALL(r,any)		"" 10
r: GET_TIME_BASE		"" 11
r: OTHER_OPERAND(r,r)		"" 0
r:  YIELDPOINT_OSR(any, any)		"" 11
r:      PREPARE_INT(r, r)		"" 11
r:      PREPARE_LONG(r, r)		"" 11
r:      ATTEMPT_INT(r, r)		"" 11
r:      ATTEMPT_LONG(r, r)		"" 11
stm: IR_PROLOGUE		"" 11
r:      LONG_MUL(r,INT_CONSTANT)		"" 11
r:      LONG_MUL(r,r)		"" 11
r:      LONG_DIV(r,r)		"" 20
r:      LONG_DIV(r,REF_MOVE(INT_CONSTANT))		"" 20
r:      LONG_REM(r,r)		"" 20
r:      LONG_REM(r,REF_MOVE(INT_CONSTANT))		"" 20
r:      LONG_SHL(r,INT_CONSTANT)		"" 10
r:      LONG_SHL(r,r)		"" 20
r:      LONG_SHL(LONG_USHR(r,INT_CONSTANT),INT_CONSTANT)		"" ((VLR(p) <= VR(p)) ? 10 : INFINITE)
r:      LONG_USHR(LONG_SHL(r,INT_CONSTANT),INT_CONSTANT)		"" ((VLR(p) <= VR(p)) ? 10 : INFINITE)
r:      LONG_SHR(r,INT_CONSTANT)		"" 10
r:      LONG_SHR(r,r)		"" 20
r:      LONG_USHR(r,INT_CONSTANT)		"" 10
r:      LONG_USHR(r,r)		"" 20
rs: INT_2LONG(r)		"" 11
rs: INT_2LONG(rs)		"" 10
r: LONG_2INT(r)		"" 10
r: FLOAT_2LONG(r)		"" 10
r: DOUBLE_2LONG(r)		"" 10
r: DOUBLE_AS_LONG_BITS(r)		"" 40
r: LONG_BITS_AS_DOUBLE(r)		"" 40
r: REF_MOVE(ADDRESS_CONSTANT)		"" 40
r: REF_MOVE(LONG_CONSTANT)		"" 40
r: LONG_CMP(r,r)		"" 40
stm:      LONG_IFCMP(r,r)		"" 20
stm:      LONG_IFCMP(r,INT_CONSTANT)		"" 20
stm:      LONG_IFCMP(r,LONG_CONSTANT)		"" 20
stm:    INT_IFCMP(ATTEMPT_INT(r,r),INT_CONSTANT)		"" ((!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE)
stm:    INT_IFCMP(ATTEMPT_ADDR(r,r),INT_CONSTANT)		"" ((!IfCmp.getCond(P(p)).isUNSIGNED())&&ZERO(IfCmp.getVal2(P(p)))?20:INFINITE)
rz: INT_2ADDRZerExt(rz)		"" 10
rz: INT_2ADDRZerExt(r)		"" 11
rz: INT_2ADDRZerExt(INT_LOAD(r,INT_CONSTANT))		"" 11
rz: INT_2ADDRZerExt(INT_LOAD(r,r))		"" 11
rz: INT_2ADDRZerExt(INT_LOAD(REF_ADD(r,INT_CONSTANT),INT_CONSTANT))		"" (SI16(VLR(p)+VLLR(p)) ? 14 : INFINITE)
r: LONG_LOAD(r,INT_CONSTANT)		"" 11
r: LONG_LOAD(r,REF_MOVE(ADDRESS_CONSTANT))		"" FITS(Move.getVal(PR(p)),32,22)
r: LONG_LOAD(r,r)		"" 11
r: LONG_LOAD(REF_ADD(r,r),INT_CONSTANT)		"" isZERO(VR(p), 11)
r: LONG_LOAD(REF_ADD(r,INT_CONSTANT),INT_CONSTANT)		"" (SI16(VR(p)+VLR(p)) ? 14 : INFINITE)
stm: LONG_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))		"" 11
stm: LONG_STORE(r,OTHER_OPERAND(r,REF_MOVE(ADDRESS_CONSTANT)))		"" FITS(Move.getVal(PRR(p)),32,22)
stm: LONG_STORE(r,OTHER_OPERAND(r,r))		"" 11
stm: LONG_STORE(r,OTHER_OPERAND(REF_ADD(r,INT_CONSTANT),INT_CONSTANT))		"" (SI16(VRR(p)+VRLR(p))?14:INFINITE)
r:      PREPARE_ADDR(r, r)		"" 11
r:      ATTEMPT_ADDR(r, r)		"" 11
%%
  /**
   * For each BURS rule (the number of which provides the index) give its flags byte
   */
  private static final byte[] action={
    0,
    NOFLAGS, // 1 - stm: r
    NOFLAGS, // 2 - r: REGISTER
    NOFLAGS, // 3 - r: czr
    NOFLAGS, // 4 - r: rs
    NOFLAGS, // 5 - r: rz
    NOFLAGS, // 6 - rs: rp
    NOFLAGS, // 7 - rz: rp
    NOFLAGS, // 8 - any: NULL
    NOFLAGS, // 9 - any: r
    NOFLAGS, // 10 - any: ADDRESS_CONSTANT
    NOFLAGS, // 11 - any: INT_CONSTANT
    NOFLAGS, // 12 - any: LONG_CONSTANT
    NOFLAGS, // 13 - any: OTHER_OPERAND(any, any)
    EMIT_INSTRUCTION, // 14 - stm: RESOLVE
    EMIT_INSTRUCTION, // 15 - stm: IG_PATCH_POINT
    EMIT_INSTRUCTION, // 16 - stm: UNINT_BEGIN
    EMIT_INSTRUCTION, // 17 - stm: UNINT_END
    EMIT_INSTRUCTION, // 18 - stm: YIELDPOINT_PROLOGUE
    EMIT_INSTRUCTION, // 19 - stm: YIELDPOINT_EPILOGUE
    EMIT_INSTRUCTION, // 20 - stm: YIELDPOINT_BACKEDGE
    EMIT_INSTRUCTION, // 21 - r: FRAMESIZE
    EMIT_INSTRUCTION, // 22 - stm: LOWTABLESWITCH(r)
    NOFLAGS, // 23 - stm: NOP
    EMIT_INSTRUCTION, // 24 - r: GUARD_MOVE
    EMIT_INSTRUCTION, // 25 - r: GUARD_COMBINE
    EMIT_INSTRUCTION, // 26 - stm: NULL_CHECK(r)
    EMIT_INSTRUCTION, // 27 - r: GET_CAUGHT_EXCEPTION
    EMIT_INSTRUCTION, // 28 - stm: SET_CAUGHT_EXCEPTION(r)
    EMIT_INSTRUCTION, // 29 - stm: FENCE
    EMIT_INSTRUCTION, // 30 - stm: WRITE_FLOOR
    EMIT_INSTRUCTION, // 31 - stm: READ_CEILING
    EMIT_INSTRUCTION, // 32 - stm: DCBF(r)
    EMIT_INSTRUCTION, // 33 - stm: DCBST(r)
    EMIT_INSTRUCTION, // 34 - stm: DCBT(r)
    EMIT_INSTRUCTION, // 35 - stm: DCBTST(r)
    EMIT_INSTRUCTION, // 36 - stm: DCBZ(r)
    EMIT_INSTRUCTION, // 37 - stm: DCBZL(r)
    EMIT_INSTRUCTION, // 38 - stm: ICBI(r)
    EMIT_INSTRUCTION, // 39 - stm:   ILLEGAL_INSTRUCTION
    EMIT_INSTRUCTION, // 40 - stm: TRAP
    EMIT_INSTRUCTION, // 41 - stm: TRAP_IF(r,r)
    EMIT_INSTRUCTION, // 42 - stm: TRAP_IF(r,INT_CONSTANT)
    EMIT_INSTRUCTION, // 43 - stm: TRAP_IF(r,LONG_CONSTANT)
    EMIT_INSTRUCTION, // 44 - r: BOOLEAN_NOT(r)
    EMIT_INSTRUCTION, // 45 - r: BOOLEAN_CMP_INT(r,INT_CONSTANT)
    EMIT_INSTRUCTION, // 46 - r: BOOLEAN_CMP_INT(r,r)
    EMIT_INSTRUCTION, // 47 - boolcmp: BOOLEAN_CMP_INT(r,INT_CONSTANT)
    EMIT_INSTRUCTION, // 48 - boolcmp: BOOLEAN_CMP_INT(r,r)
    EMIT_INSTRUCTION, // 49 - r: BOOLEAN_CMP_ADDR(r,INT_CONSTANT)
    EMIT_INSTRUCTION, // 50 - r: BOOLEAN_CMP_ADDR(r,r)
    EMIT_INSTRUCTION, // 51 - boolcmp: BOOLEAN_CMP_ADDR(r,INT_CONSTANT)
    EMIT_INSTRUCTION, // 52 - boolcmp: BOOLEAN_CMP_ADDR(r,r)
    NOFLAGS, // 53 - boolcmp: BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
    EMIT_INSTRUCTION, // 54 - boolcmp: BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
    NOFLAGS, // 55 - boolcmp: BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
    EMIT_INSTRUCTION, // 56 - boolcmp: BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
    EMIT_INSTRUCTION, // 57 - r: BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
    EMIT_INSTRUCTION, // 58 - r: BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
    EMIT_INSTRUCTION, // 59 - r: BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
    EMIT_INSTRUCTION, // 60 - r: BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
    EMIT_INSTRUCTION, // 61 - r: REF_ADD(r,INT_CONSTANT)
    EMIT_INSTRUCTION, // 62 - r: REF_ADD(r,r)
    EMIT_INSTRUCTION, // 63 - r: REF_ADD(r,REF_MOVE(INT_CONSTANT))
    EMIT_INSTRUCTION, // 64 - r: REF_ADD(r,REF_MOVE(INT_CONSTANT))
    EMIT_INSTRUCTION, // 65 - r: REF_SUB(r,r)
    EMIT_INSTRUCTION, // 66 - r: REF_SUB(INT_CONSTANT,r)
    EMIT_INSTRUCTION, // 67 - r: INT_MUL(r,INT_CONSTANT)
    EMIT_INSTRUCTION, // 68 - r: INT_MUL(r,r)
    EMIT_INSTRUCTION, // 69 - r: INT_DIV(r,r)
    EMIT_INSTRUCTION, // 70 - r: INT_DIV(r,REF_MOVE(INT_CONSTANT))
    EMIT_INSTRUCTION, // 71 - r: INT_REM(r,r)
    EMIT_INSTRUCTION, // 72 - r: INT_REM(r,REF_MOVE(INT_CONSTANT))
    EMIT_INSTRUCTION, // 73 - r: REF_NEG(r)
    EMIT_INSTRUCTION, // 74 - rz: INT_SHL(r,INT_CONSTANT)
    EMIT_INSTRUCTION, // 75 - rz: INT_SHL(r,r)
    EMIT_INSTRUCTION, // 76 - rz: INT_SHL(INT_USHR(r,INT_CONSTANT),INT_CONSTANT)
    EMIT_INSTRUCTION, // 77 - rs: INT_SHR(r,INT_CONSTANT)
    EMIT_INSTRUCTION, // 78 - rs: INT_SHR(r,r)
    EMIT_INSTRUCTION, // 79 - rp: INT_SHR(REF_AND(r,INT_CONSTANT),INT_CONSTANT)
    EMIT_INSTRUCTION, // 80 - rp: INT_USHR(r,INT_CONSTANT)
    EMIT_INSTRUCTION, // 81 - rz: INT_USHR(r,r)
    EMIT_INSTRUCTION, // 82 - rp: INT_USHR(REF_AND(r,INT_CONSTANT),INT_CONSTANT)
    EMIT_INSTRUCTION, // 83 - rp: INT_USHR(REF_AND(r,REF_MOVE(INT_CONSTANT)),INT_CONSTANT)
    EMIT_INSTRUCTION, // 84 - rp: INT_USHR(INT_SHL(r,INT_CONSTANT),INT_CONSTANT)
    EMIT_INSTRUCTION, // 85 - r: REF_AND(r,r)
    EMIT_INSTRUCTION, // 86 - czr: REF_AND(r,INT_CONSTANT)
    EMIT_INSTRUCTION, // 87 - rp: REF_AND(r,INT_CONSTANT)
    EMIT_INSTRUCTION, // 88 - r: REF_AND(REF_NOT(r),REF_NOT(r))
    EMIT_INSTRUCTION, // 89 - r: REF_AND(r,REF_NOT(r))
    EMIT_INSTRUCTION, // 90 - rp: REF_AND(INT_USHR(r,INT_CONSTANT),INT_CONSTANT)
    EMIT_INSTRUCTION, // 91 - rp: REF_AND(INT_USHR(r,INT_CONSTANT),REF_MOVE(INT_CONSTANT))
    EMIT_INSTRUCTION, // 92 - r: REF_OR(r,r)
    EMIT_INSTRUCTION, // 93 - r: REF_OR(r,INT_CONSTANT)
    EMIT_INSTRUCTION, // 94 - r: REF_OR(REF_NOT(r),REF_NOT(r))
    EMIT_INSTRUCTION, // 95 - r: REF_OR(r,REF_NOT(r))
    EMIT_INSTRUCTION, // 96 - r: REF_XOR(r,r)
    EMIT_INSTRUCTION, // 97 - r: REF_XOR(r,INT_CONSTANT)
    EMIT_INSTRUCTION, // 98 - r: REF_NOT(r)
    EMIT_INSTRUCTION, // 99 - r: REF_NOT(REF_OR(r,r))
    EMIT_INSTRUCTION, // 100 - r: REF_NOT(REF_AND(r,r))
    EMIT_INSTRUCTION, // 101 - r: REF_NOT(REF_XOR(r,r))
    EMIT_INSTRUCTION, // 102 - r: FLOAT_ADD(r,r)
    EMIT_INSTRUCTION, // 103 - r: DOUBLE_ADD(r,r)
    EMIT_INSTRUCTION, // 104 - r: FLOAT_MUL(r,r)
    EMIT_INSTRUCTION, // 105 - r: DOUBLE_MUL(r,r)
    EMIT_INSTRUCTION, // 106 - r: FLOAT_SUB(r,r)
    EMIT_INSTRUCTION, // 107 - r: DOUBLE_SUB(r,r)
    EMIT_INSTRUCTION, // 108 - r: FLOAT_DIV(r,r)
    EMIT_INSTRUCTION, // 109 - r: DOUBLE_DIV(r,r)
    EMIT_INSTRUCTION, // 110 - r: FLOAT_NEG(r)
    EMIT_INSTRUCTION, // 111 - r: DOUBLE_NEG(r)
    EMIT_INSTRUCTION, // 112 - r: FLOAT_SQRT(r)
    EMIT_INSTRUCTION, // 113 - r: DOUBLE_SQRT(r)
    EMIT_INSTRUCTION, // 114 - r:  FLOAT_ADD(FLOAT_MUL(r, r), r)
    EMIT_INSTRUCTION, // 115 - r:  DOUBLE_ADD(DOUBLE_MUL(r, r), r)
    EMIT_INSTRUCTION, // 116 - r: FLOAT_ADD(r, FLOAT_MUL(r,r))
    EMIT_INSTRUCTION, // 117 - r: DOUBLE_ADD(r, DOUBLE_MUL(r,r))
    EMIT_INSTRUCTION, // 118 - r:  FLOAT_SUB(FLOAT_MUL(r, r), r)
    EMIT_INSTRUCTION, // 119 - r:  DOUBLE_SUB(DOUBLE_MUL(r, r), r)
    EMIT_INSTRUCTION, // 120 - r:  FLOAT_NEG(FLOAT_ADD(FLOAT_MUL(r, r), r))
    EMIT_INSTRUCTION, // 121 - r:  DOUBLE_NEG(DOUBLE_ADD(DOUBLE_MUL(r, r), r))
    EMIT_INSTRUCTION, // 122 - r: FLOAT_NEG(FLOAT_ADD(r, FLOAT_MUL(r,r)))
    EMIT_INSTRUCTION, // 123 - r: DOUBLE_NEG(DOUBLE_ADD(r, DOUBLE_MUL(r,r)))
    EMIT_INSTRUCTION, // 124 - r:  FLOAT_NEG(FLOAT_SUB(FLOAT_MUL(r, r), r))
    EMIT_INSTRUCTION, // 125 - r:  DOUBLE_NEG(DOUBLE_SUB(DOUBLE_MUL(r, r), r))
    EMIT_INSTRUCTION, // 126 - rs: INT_2BYTE(r)
    EMIT_INSTRUCTION, // 127 - rp: INT_2USHORT(r)
    EMIT_INSTRUCTION, // 128 - rs: INT_2SHORT(r)
    EMIT_INSTRUCTION, // 129 - r: INT_2FLOAT(r)
    EMIT_INSTRUCTION, // 130 - r: INT_2DOUBLE(r)
    EMIT_INSTRUCTION, // 131 - r: FLOAT_2INT(r)
    EMIT_INSTRUCTION, // 132 - r: FLOAT_2DOUBLE(r)
    EMIT_INSTRUCTION, // 133 - r: DOUBLE_2INT(r)
    EMIT_INSTRUCTION, // 134 - r: DOUBLE_2FLOAT(r)
    EMIT_INSTRUCTION, // 135 - r: FLOAT_AS_INT_BITS(r)
    EMIT_INSTRUCTION, // 136 - r: INT_BITS_AS_FLOAT(r)
    EMIT_INSTRUCTION, // 137 - r: REF_MOVE(r)
    EMIT_INSTRUCTION, // 138 - rs: REF_MOVE(INT_CONSTANT)
    EMIT_INSTRUCTION, // 139 - rs: REF_MOVE(INT_CONSTANT)
    EMIT_INSTRUCTION, // 140 - rs: REF_MOVE(INT_CONSTANT)
    EMIT_INSTRUCTION, // 141 - r: FLOAT_MOVE(r)
    EMIT_INSTRUCTION, // 142 - r: DOUBLE_MOVE(r)
    EMIT_INSTRUCTION, // 143 - rs: BYTE_LOAD(r,INT_CONSTANT)
    EMIT_INSTRUCTION, // 144 - rs: BYTE_LOAD(r,r)
    EMIT_INSTRUCTION, // 145 - rp: REF_AND(BYTE_LOAD(r,r),INT_CONSTANT)
    EMIT_INSTRUCTION, // 146 - rp: REF_AND(BYTE_LOAD(r,INT_CONSTANT),INT_CONSTANT)
    EMIT_INSTRUCTION, // 147 - rp: UBYTE_LOAD(r,INT_CONSTANT)
    EMIT_INSTRUCTION, // 148 - rp: UBYTE_LOAD(r,r)
    EMIT_INSTRUCTION, // 149 - rs: SHORT_LOAD(r,INT_CONSTANT)
    EMIT_INSTRUCTION, // 150 - rs: SHORT_LOAD(r,r)
    EMIT_INSTRUCTION, // 151 - rp: USHORT_LOAD(r,INT_CONSTANT)
    EMIT_INSTRUCTION, // 152 - rp: USHORT_LOAD(r,r)
    EMIT_INSTRUCTION, // 153 - r: FLOAT_LOAD(r,INT_CONSTANT)
    EMIT_INSTRUCTION, // 154 - r:      FLOAT_LOAD(r,REF_MOVE(ADDRESS_CONSTANT))
    EMIT_INSTRUCTION, // 155 - r: FLOAT_LOAD(r,r)
    EMIT_INSTRUCTION, // 156 - r: DOUBLE_LOAD(r,INT_CONSTANT)
    EMIT_INSTRUCTION, // 157 - r:      DOUBLE_LOAD(r,REF_MOVE(ADDRESS_CONSTANT))
    EMIT_INSTRUCTION, // 158 - r: DOUBLE_LOAD(r,r)
    EMIT_INSTRUCTION, // 159 - rs:      INT_LOAD(r,INT_CONSTANT)
    EMIT_INSTRUCTION, // 160 - rs:      INT_LOAD(r,REF_MOVE(ADDRESS_CONSTANT))
    EMIT_INSTRUCTION, // 161 - rs:      INT_LOAD(r,r)
    EMIT_INSTRUCTION, // 162 - rs:      INT_LOAD(REF_ADD(r,r),INT_CONSTANT)
    EMIT_INSTRUCTION, // 163 - rs:      INT_LOAD(REF_ADD(r,INT_CONSTANT),INT_CONSTANT)
    EMIT_INSTRUCTION, // 164 - stm: BYTE_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))
    EMIT_INSTRUCTION, // 165 - stm: BYTE_STORE(r,OTHER_OPERAND(r,r))
    EMIT_INSTRUCTION, // 166 - stm: BYTE_STORE(INT_2BYTE(r),OTHER_OPERAND(r,INT_CONSTANT))
    EMIT_INSTRUCTION, // 167 - stm: BYTE_STORE(INT_2BYTE(r),OTHER_OPERAND(r,r))
    EMIT_INSTRUCTION, // 168 - stm: SHORT_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))
    EMIT_INSTRUCTION, // 169 - stm: SHORT_STORE(r,OTHER_OPERAND(r,r))
    EMIT_INSTRUCTION, // 170 - stm: SHORT_STORE(INT_2SHORT(r),OTHER_OPERAND(r,INT_CONSTANT))
    EMIT_INSTRUCTION, // 171 - stm: SHORT_STORE(INT_2SHORT(r),OTHER_OPERAND(r,r))
    EMIT_INSTRUCTION, // 172 - stm: SHORT_STORE(INT_2USHORT(r),OTHER_OPERAND(r,INT_CONSTANT))
    EMIT_INSTRUCTION, // 173 - stm: SHORT_STORE(INT_2USHORT(r),OTHER_OPERAND(r,r))
    EMIT_INSTRUCTION, // 174 - stm: INT_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))
    EMIT_INSTRUCTION, // 175 - stm: INT_STORE(r,OTHER_OPERAND(r,REF_MOVE(ADDRESS_CONSTANT)))
    EMIT_INSTRUCTION, // 176 - stm: INT_STORE(r,OTHER_OPERAND(r,r))
    EMIT_INSTRUCTION, // 177 - stm: INT_STORE(r,OTHER_OPERAND(REF_ADD(r,INT_CONSTANT),INT_CONSTANT))
    EMIT_INSTRUCTION, // 178 - stm: FLOAT_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))
    EMIT_INSTRUCTION, // 179 - stm:      FLOAT_STORE(r,OTHER_OPERAND(r,REF_MOVE(ADDRESS_CONSTANT)))
    EMIT_INSTRUCTION, // 180 - stm: FLOAT_STORE(r,OTHER_OPERAND(r,r))
    EMIT_INSTRUCTION, // 181 - stm: DOUBLE_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))
    EMIT_INSTRUCTION, // 182 - stm:      DOUBLE_STORE(r,OTHER_OPERAND(r,REF_MOVE(ADDRESS_CONSTANT)))
    EMIT_INSTRUCTION, // 183 - stm: DOUBLE_STORE(r,OTHER_OPERAND(r,r))
    EMIT_INSTRUCTION, // 184 - stm: INT_IFCMP(r,r)
    EMIT_INSTRUCTION, // 185 - stm: INT_IFCMP(r,INT_CONSTANT)
    EMIT_INSTRUCTION, // 186 - stm: INT_IFCMP(INT_2BYTE(r),INT_CONSTANT)
    EMIT_INSTRUCTION, // 187 - stm: INT_IFCMP(INT_2SHORT(r),INT_CONSTANT)
    EMIT_INSTRUCTION, // 188 - stm: INT_IFCMP(INT_USHR(r,r),INT_CONSTANT)
    EMIT_INSTRUCTION, // 189 - stm: INT_IFCMP(INT_SHL(r,r),INT_CONSTANT)
    EMIT_INSTRUCTION, // 190 - stm: INT_IFCMP(INT_SHR(r,r),INT_CONSTANT)
    EMIT_INSTRUCTION, // 191 - stm: INT_IFCMP(INT_USHR(r,INT_CONSTANT),INT_CONSTANT)
    EMIT_INSTRUCTION, // 192 - stm: INT_IFCMP(INT_SHL(r,INT_CONSTANT),INT_CONSTANT)
    EMIT_INSTRUCTION, // 193 - stm: INT_IFCMP(INT_SHR(r,INT_CONSTANT),INT_CONSTANT)
    EMIT_INSTRUCTION, // 194 - stm: INT_IFCMP(REF_AND(r,INT_CONSTANT),INT_CONSTANT)
    EMIT_INSTRUCTION, // 195 - stm: INT_IFCMP(boolcmp, INT_CONSTANT)
    EMIT_INSTRUCTION, // 196 - stm: INT_IFCMP(boolcmp, INT_CONSTANT)
    EMIT_INSTRUCTION, // 197 - stm: INT_IFCMP(boolcmp, INT_CONSTANT)
    EMIT_INSTRUCTION, // 198 - stm: INT_IFCMP(boolcmp, INT_CONSTANT)
    EMIT_INSTRUCTION, // 199 - stm: INT_IFCMP2(r,r)
    EMIT_INSTRUCTION, // 200 - stm: INT_IFCMP2(r,INT_CONSTANT)
    EMIT_INSTRUCTION, // 201 - stm:   FLOAT_IFCMP(r,r)
    EMIT_INSTRUCTION, // 202 - stm:   DOUBLE_IFCMP(r,r)
    EMIT_INSTRUCTION, // 203 - stm: FLOAT_CMPL(r,r)
    EMIT_INSTRUCTION, // 204 - stm: FLOAT_CMPG(r,r)
    EMIT_INSTRUCTION, // 205 - stm: DOUBLE_CMPL(r,r)
    EMIT_INSTRUCTION, // 206 - stm: DOUBLE_CMPG(r,r)
    EMIT_INSTRUCTION, // 207 - stm: GOTO
    EMIT_INSTRUCTION, // 208 - stm: RETURN(NULL)
    EMIT_INSTRUCTION, // 209 - stm: RETURN(r)
    EMIT_INSTRUCTION, // 210 - r: CALL(r,any)
    EMIT_INSTRUCTION, // 211 - r: CALL(BRANCH_TARGET,any)
    EMIT_INSTRUCTION, // 212 - r: SYSCALL(r,any)
    EMIT_INSTRUCTION, // 213 - r: GET_TIME_BASE
    NOFLAGS, // 214 - r: OTHER_OPERAND(r,r)
    EMIT_INSTRUCTION, // 215 - r:  YIELDPOINT_OSR(any, any)
    EMIT_INSTRUCTION, // 216 - r:      PREPARE_INT(r, r)
    EMIT_INSTRUCTION, // 217 - r:      PREPARE_LONG(r, r)
    EMIT_INSTRUCTION, // 218 - r:      ATTEMPT_INT(r, r)
    EMIT_INSTRUCTION, // 219 - r:      ATTEMPT_LONG(r, r)
    EMIT_INSTRUCTION, // 220 - stm: IR_PROLOGUE
    EMIT_INSTRUCTION, // 221 - r:      LONG_MUL(r,INT_CONSTANT)
    EMIT_INSTRUCTION, // 222 - r:      LONG_MUL(r,r)
    EMIT_INSTRUCTION, // 223 - r:      LONG_DIV(r,r)
    EMIT_INSTRUCTION, // 224 - r:      LONG_DIV(r,REF_MOVE(INT_CONSTANT))
    EMIT_INSTRUCTION, // 225 - r:      LONG_REM(r,r)
    EMIT_INSTRUCTION, // 226 - r:      LONG_REM(r,REF_MOVE(INT_CONSTANT))
    EMIT_INSTRUCTION, // 227 - r:      LONG_SHL(r,INT_CONSTANT)
    EMIT_INSTRUCTION, // 228 - r:      LONG_SHL(r,r)
    EMIT_INSTRUCTION, // 229 - r:      LONG_SHL(LONG_USHR(r,INT_CONSTANT),INT_CONSTANT)
    EMIT_INSTRUCTION, // 230 - r:      LONG_USHR(LONG_SHL(r,INT_CONSTANT),INT_CONSTANT)
    EMIT_INSTRUCTION, // 231 - r:      LONG_SHR(r,INT_CONSTANT)
    EMIT_INSTRUCTION, // 232 - r:      LONG_SHR(r,r)
    EMIT_INSTRUCTION, // 233 - r:      LONG_USHR(r,INT_CONSTANT)
    EMIT_INSTRUCTION, // 234 - r:      LONG_USHR(r,r)
    EMIT_INSTRUCTION, // 235 - rs: INT_2LONG(r)
    EMIT_INSTRUCTION, // 236 - rs: INT_2LONG(rs)
    EMIT_INSTRUCTION, // 237 - r: LONG_2INT(r)
    EMIT_INSTRUCTION, // 238 - r: FLOAT_2LONG(r)
    EMIT_INSTRUCTION, // 239 - r: DOUBLE_2LONG(r)
    EMIT_INSTRUCTION, // 240 - r: DOUBLE_AS_LONG_BITS(r)
    EMIT_INSTRUCTION, // 241 - r: LONG_BITS_AS_DOUBLE(r)
    EMIT_INSTRUCTION, // 242 - r: REF_MOVE(ADDRESS_CONSTANT)
    EMIT_INSTRUCTION, // 243 - r: REF_MOVE(LONG_CONSTANT)
    EMIT_INSTRUCTION, // 244 - r: LONG_CMP(r,r)
    EMIT_INSTRUCTION, // 245 - stm:      LONG_IFCMP(r,r)
    EMIT_INSTRUCTION, // 246 - stm:      LONG_IFCMP(r,INT_CONSTANT)
    EMIT_INSTRUCTION, // 247 - stm:      LONG_IFCMP(r,LONG_CONSTANT)
    EMIT_INSTRUCTION, // 248 - stm:    INT_IFCMP(ATTEMPT_INT(r,r),INT_CONSTANT)
    EMIT_INSTRUCTION, // 249 - stm:    INT_IFCMP(ATTEMPT_ADDR(r,r),INT_CONSTANT)
    EMIT_INSTRUCTION, // 250 - rz: INT_2ADDRZerExt(rz)
    EMIT_INSTRUCTION, // 251 - rz: INT_2ADDRZerExt(r)
    EMIT_INSTRUCTION, // 252 - rz: INT_2ADDRZerExt(INT_LOAD(r,INT_CONSTANT))
    EMIT_INSTRUCTION, // 253 - rz: INT_2ADDRZerExt(INT_LOAD(r,r))
    EMIT_INSTRUCTION, // 254 - rz: INT_2ADDRZerExt(INT_LOAD(REF_ADD(r,INT_CONSTANT),INT_CONSTANT))
    EMIT_INSTRUCTION, // 255 - r: LONG_LOAD(r,INT_CONSTANT)
    EMIT_INSTRUCTION, // 256 - r: LONG_LOAD(r,REF_MOVE(ADDRESS_CONSTANT))
    EMIT_INSTRUCTION, // 257 - r: LONG_LOAD(r,r)
    EMIT_INSTRUCTION, // 258 - r: LONG_LOAD(REF_ADD(r,r),INT_CONSTANT)
    EMIT_INSTRUCTION, // 259 - r: LONG_LOAD(REF_ADD(r,INT_CONSTANT),INT_CONSTANT)
    EMIT_INSTRUCTION, // 260 - stm: LONG_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))
    EMIT_INSTRUCTION, // 261 - stm: LONG_STORE(r,OTHER_OPERAND(r,REF_MOVE(ADDRESS_CONSTANT)))
    EMIT_INSTRUCTION, // 262 - stm: LONG_STORE(r,OTHER_OPERAND(r,r))
    EMIT_INSTRUCTION, // 263 - stm: LONG_STORE(r,OTHER_OPERAND(REF_ADD(r,INT_CONSTANT),INT_CONSTANT))
    EMIT_INSTRUCTION, // 264 - r:      PREPARE_ADDR(r, r)
    EMIT_INSTRUCTION, // 265 - r:      ATTEMPT_ADDR(r, r)
  };

  /**
   * Gets the action flags (such as EMIT_INSTRUCTION) associated with the given
   * rule number.
   *
   * @param ruleno the rule number we want the action flags for
   * @return the action byte for the rule
   */
  @Pure
  public static byte action(int ruleno) {
    return action[unsortedErnMap[ruleno]];
  }

  /**
   * Decode the target non-terminal and minimal cost covering statement
   * into the rule that produces the non-terminal
   *
   * @param goalnt the non-terminal that we wish to produce.
   * @param stateNT the state encoding the non-terminals associated associated
   *        with covering a tree with minimal cost (computed by at compile time
   *        by jburg).
   * @return the rule number
   */
   @Pure
   public static char decode(int goalnt, int stateNT) {
     return decode[goalnt][stateNT];
   }


  /**
   * Emit code for rule number 14:
   * stm: RESOLVE
   * @param p BURS node to apply the rule to
   */
  private void code14(AbstractBURS_TreeNode p) {
    EMIT(P(p));
  }

  /**
   * Emit code for rule number 15:
   * stm: IG_PATCH_POINT
   * @param p BURS node to apply the rule to
   */
  private void code15(AbstractBURS_TreeNode p) {
    EMIT(InlineGuard.mutate(P(p), IG_PATCH_POINT, null, null, null, InlineGuard.getTarget(P(p)), InlineGuard.getBranchProfile(P(p))));
  }

  /**
   * Emit code for rule number 16:
   * stm: UNINT_BEGIN
   * @param p BURS node to apply the rule to
   */
  private void code16(AbstractBURS_TreeNode p) {
    EMIT(P(p));
  }

  /**
   * Emit code for rule number 17:
   * stm: UNINT_END
   * @param p BURS node to apply the rule to
   */
  private void code17(AbstractBURS_TreeNode p) {
    EMIT(P(p));
  }

  /**
   * Emit code for rule number 18:
   * stm: YIELDPOINT_PROLOGUE
   * @param p BURS node to apply the rule to
   */
  private void code18(AbstractBURS_TreeNode p) {
    EMIT(P(p));
  }

  /**
   * Emit code for rule number 19:
   * stm: YIELDPOINT_EPILOGUE
   * @param p BURS node to apply the rule to
   */
  private void code19(AbstractBURS_TreeNode p) {
    EMIT(P(p));
  }

  /**
   * Emit code for rule number 20:
   * stm: YIELDPOINT_BACKEDGE
   * @param p BURS node to apply the rule to
   */
  private void code20(AbstractBURS_TreeNode p) {
    EMIT(P(p));
  }

  /**
   * Emit code for rule number 21:
   * r: FRAMESIZE
   * @param p BURS node to apply the rule to
   */
  private void code21(AbstractBURS_TreeNode p) {
    EMIT(MIR_Unary.mutate(P(p), PPC_LDI, Nullary.getClearResult(P(p)), new UnknownConstantOperand()));
  }

  /**
   * Emit code for rule number 22:
   * stm: LOWTABLESWITCH(r)
   * @param p BURS node to apply the rule to
   */
  private void code22(AbstractBURS_TreeNode p) {
    LOWTABLESWITCH(P(p));
  }

  /**
   * Emit code for rule number 24:
   * r: GUARD_MOVE
   * @param p BURS node to apply the rule to
   */
  private void code24(AbstractBURS_TreeNode p) {
    EMIT(P(p));
  }

  /**
   * Emit code for rule number 25:
   * r: GUARD_COMBINE
   * @param p BURS node to apply the rule to
   */
  private void code25(AbstractBURS_TreeNode p) {
    EMIT(P(p));
  }

  /**
   * Emit code for rule number 26:
   * stm: NULL_CHECK(r)
   * @param p BURS node to apply the rule to
   */
  private void code26(AbstractBURS_TreeNode p) {
    EMIT(P(p));
  }

  /**
   * Emit code for rule number 27:
   * r: GET_CAUGHT_EXCEPTION
   * @param p BURS node to apply the rule to
   */
  private void code27(AbstractBURS_TreeNode p) {
    GET_EXCEPTION_OBJECT(P(p));
  }

  /**
   * Emit code for rule number 28:
   * stm: SET_CAUGHT_EXCEPTION(r)
   * @param p BURS node to apply the rule to
   */
  private void code28(AbstractBURS_TreeNode p) {
    SET_EXCEPTION_OBJECT(P(p));
  }

  /**
   * Emit code for rule number 29:
   * stm: FENCE
   * @param p BURS node to apply the rule to
   */
  private void code29(AbstractBURS_TreeNode p) {
    EMIT(MIR_Empty.mutate(P(p), PPC_HWSYNC));
  }

  /**
   * Emit code for rule number 30:
   * stm: WRITE_FLOOR
   * @param p BURS node to apply the rule to
   */
  private void code30(AbstractBURS_TreeNode p) {
    EMIT(MIR_Empty.mutate(P(p), PPC_SYNC));
  }

  /**
   * Emit code for rule number 31:
   * stm: READ_CEILING
   * @param p BURS node to apply the rule to
   */
  private void code31(AbstractBURS_TreeNode p) {
    EMIT(MIR_Empty.mutate(P(p), PPC_ISYNC));
  }

  /**
   * Emit code for rule number 32:
   * stm: DCBF(r)
   * @param p BURS node to apply the rule to
   */
  private void code32(AbstractBURS_TreeNode p) {
    EMIT(MIR_CacheOp.mutate(P(p), PPC_DCBF, I(0), R(CacheOp.getRef(P(p)))));
  }

  /**
   * Emit code for rule number 33:
   * stm: DCBST(r)
   * @param p BURS node to apply the rule to
   */
  private void code33(AbstractBURS_TreeNode p) {
    EMIT(MIR_CacheOp.mutate(P(p), PPC_DCBST, I(0), R(CacheOp.getRef(P(p)))));
  }

  /**
   * Emit code for rule number 34:
   * stm: DCBT(r)
   * @param p BURS node to apply the rule to
   */
  private void code34(AbstractBURS_TreeNode p) {
    EMIT(MIR_CacheOp.mutate(P(p), PPC_DCBT, I(0), R(CacheOp.getRef(P(p)))));
  }

  /**
   * Emit code for rule number 35:
   * stm: DCBTST(r)
   * @param p BURS node to apply the rule to
   */
  private void code35(AbstractBURS_TreeNode p) {
    EMIT(MIR_CacheOp.mutate(P(p), PPC_DCBTST, I(0), R(CacheOp.getRef(P(p)))));
  }

  /**
   * Emit code for rule number 36:
   * stm: DCBZ(r)
   * @param p BURS node to apply the rule to
   */
  private void code36(AbstractBURS_TreeNode p) {
    EMIT(MIR_CacheOp.mutate(P(p), PPC_DCBZ, I(0), R(CacheOp.getRef(P(p)))));
  }

  /**
   * Emit code for rule number 37:
   * stm: DCBZL(r)
   * @param p BURS node to apply the rule to
   */
  private void code37(AbstractBURS_TreeNode p) {
    EMIT(MIR_CacheOp.mutate(P(p), PPC_DCBZL, I(0), R(CacheOp.getRef(P(p)))));
  }

  /**
   * Emit code for rule number 38:
   * stm: ICBI(r)
   * @param p BURS node to apply the rule to
   */
  private void code38(AbstractBURS_TreeNode p) {
    EMIT(MIR_CacheOp.mutate(P(p), PPC_ICBI, I(0), R(CacheOp.getRef(P(p)))));
  }

  /**
   * Emit code for rule number 39:
   * stm:   ILLEGAL_INSTRUCTION
   * @param p BURS node to apply the rule to
   */
  private void code39(AbstractBURS_TreeNode p) {
    EMIT(MIR_Empty.mutate(P(p), PPC_ILLEGAL_INSTRUCTION));
  }

  /**
   * Emit code for rule number 40:
   * stm: TRAP
   * @param p BURS node to apply the rule to
   */
  private void code40(AbstractBURS_TreeNode p) {
    TRAP(P(p));
  }

  /**
   * Emit code for rule number 41:
   * stm: TRAP_IF(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code41(AbstractBURS_TreeNode p) {
    TRAP_IF(P(p));
  }

  /**
   * Emit code for rule number 42:
   * stm: TRAP_IF(r,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code42(AbstractBURS_TreeNode p) {
    TRAP_IF_IMM(P(p), false);
  }

  /**
   * Emit code for rule number 43:
   * stm: TRAP_IF(r,LONG_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code43(AbstractBURS_TreeNode p) {
    TRAP_IF_IMM(P(p), true);
  }

  /**
   * Emit code for rule number 44:
   * r: BOOLEAN_NOT(r)
   * @param p BURS node to apply the rule to
   */
  private void code44(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_XORI, Unary.getResult(P(p)), R(Unary.getVal(P(p))), IC(1)));
  }

  /**
   * Emit code for rule number 45:
   * r: BOOLEAN_CMP_INT(r,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code45(AbstractBURS_TreeNode p) {
    BOOLEAN_CMP_INT_IMM(BooleanCmp.getClearResult(P(p)), BooleanCmp.getClearCond(P(p)), R(BooleanCmp.getClearVal1(P(p))), IC(BooleanCmp.getClearVal2(P(p))));
  }

  /**
   * Emit code for rule number 46:
   * r: BOOLEAN_CMP_INT(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code46(AbstractBURS_TreeNode p) {
    BOOLEAN_CMP_INT(BooleanCmp.getClearResult(P(p)), BooleanCmp.getClearCond(P(p)), R(BooleanCmp.getClearVal1(P(p))), R(BooleanCmp.getClearVal2(P(p))));
  }

  /**
   * Emit code for rule number 47:
   * boolcmp: BOOLEAN_CMP_INT(r,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code47(AbstractBURS_TreeNode p) {
    PUSH_BOOLCMP(BooleanCmp.getClearCond(P(p)), BooleanCmp.getClearVal1(P(p)), BooleanCmp.getClearVal2(P(p)), false);
  }

  /**
   * Emit code for rule number 48:
   * boolcmp: BOOLEAN_CMP_INT(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code48(AbstractBURS_TreeNode p) {
    PUSH_BOOLCMP(BooleanCmp.getClearCond(P(p)), BooleanCmp.getClearVal1(P(p)), BooleanCmp.getClearVal2(P(p)), false);
  }

  /**
   * Emit code for rule number 49:
   * r: BOOLEAN_CMP_ADDR(r,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code49(AbstractBURS_TreeNode p) {
    BOOLEAN_CMP_ADDR_IMM(BooleanCmp.getClearResult(P(p)), BooleanCmp.getClearCond(P(p)), R(BooleanCmp.getClearVal1(P(p))), IC(BooleanCmp.getClearVal2(P(p))));
  }

  /**
   * Emit code for rule number 50:
   * r: BOOLEAN_CMP_ADDR(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code50(AbstractBURS_TreeNode p) {
    BOOLEAN_CMP_ADDR(BooleanCmp.getClearResult(P(p)), BooleanCmp.getClearCond(P(p)), R(BooleanCmp.getClearVal1(P(p))), R(BooleanCmp.getClearVal2(P(p))));
  }

  /**
   * Emit code for rule number 51:
   * boolcmp: BOOLEAN_CMP_ADDR(r,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code51(AbstractBURS_TreeNode p) {
    PUSH_BOOLCMP(BooleanCmp.getClearCond(P(p)), BooleanCmp.getClearVal1(P(p)), BooleanCmp.getClearVal2(P(p)), true);
  }

  /**
   * Emit code for rule number 52:
   * boolcmp: BOOLEAN_CMP_ADDR(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code52(AbstractBURS_TreeNode p) {
    PUSH_BOOLCMP(BooleanCmp.getClearCond(P(p)), BooleanCmp.getClearVal1(P(p)), BooleanCmp.getClearVal2(P(p)), true);
  }

  /**
   * Emit code for rule number 54:
   * boolcmp: BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code54(AbstractBURS_TreeNode p) {
    FLIP_BOOLCMP(); // invert condition
  }

  /**
   * Emit code for rule number 56:
   * boolcmp: BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code56(AbstractBURS_TreeNode p) {
    FLIP_BOOLCMP(); // invert condition
  }

  /**
   * Emit code for rule number 57:
   * r: BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code57(AbstractBURS_TreeNode p) {
    EMIT_PUSHED_BOOLCMP(BooleanCmp.getClearResult(P(p)));
  }

  /**
   * Emit code for rule number 58:
   * r: BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code58(AbstractBURS_TreeNode p) {
    FLIP_BOOLCMP(); EMIT_PUSHED_BOOLCMP(BooleanCmp.getClearResult(P(p)));
  }

  /**
   * Emit code for rule number 59:
   * r: BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code59(AbstractBURS_TreeNode p) {
    EMIT_PUSHED_BOOLCMP(BooleanCmp.getClearResult(P(p)));
  }

  /**
   * Emit code for rule number 60:
   * r: BOOLEAN_CMP_INT(boolcmp, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code60(AbstractBURS_TreeNode p) {
    FLIP_BOOLCMP(); EMIT_PUSHED_BOOLCMP(BooleanCmp.getClearResult(P(p)));
  }

  /**
   * Emit code for rule number 61:
   * r: REF_ADD(r,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code61(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_ADDI, Binary.getResult(P(p)),                
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 62:
   * r: REF_ADD(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code62(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_ADD, Binary.getResult(P(p)),                 
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 63:
   * r: REF_ADD(r,REF_MOVE(INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code63(AbstractBURS_TreeNode p) {
    {                                                                             
   int val = IV(Move.getVal(PR(p)));                                      
   EMIT(MIR_Binary.create(PPC_ADDI, Move.getResult(PR(p)).copyRO(),                    
                          R(Binary.getClearVal1(P(p))), CAL16(val)));              
   EMIT(MIR_Binary.mutate(P(p), PPC_ADDIS, Binary.getResult(P(p)),            
                          Move.getClearResult(PR(p)), CAU16(val)));       
}
  }

  /**
   * Emit code for rule number 64:
   * r: REF_ADD(r,REF_MOVE(INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code64(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_ADDIS, Binary.getResult(P(p)),               
                       R(Binary.getVal1(P(p))), CAU16(IV(Move.getVal(PR(p))))));
  }

  /**
   * Emit code for rule number 65:
   * r: REF_SUB(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code65(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_SUBF, Binary.getResult(P(p)),                
                       R(Binary.getVal2(P(p))), Binary.getVal1(P(p))));
  }

  /**
   * Emit code for rule number 66:
   * r: REF_SUB(INT_CONSTANT,r)
   * @param p BURS node to apply the rule to
   */
  private void code66(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_SUBFIC, Binary.getResult(P(p)),              
                       R(Binary.getVal2(P(p))), Binary.getVal1(P(p))));
  }

  /**
   * Emit code for rule number 67:
   * r: INT_MUL(r,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code67(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_MULLI, Binary.getResult(P(p)),               
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 68:
   * r: INT_MUL(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code68(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_MULLW, Binary.getResult(P(p)),               
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 69:
   * r: INT_DIV(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code69(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_DIVW, GuardedBinary.getResult(P(p)),  
                       R(GuardedBinary.getVal1(P(p))), GuardedBinary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 70:
   * r: INT_DIV(r,REF_MOVE(INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code70(AbstractBURS_TreeNode p) {
    INT_DIV_IMM(P(p), GuardedBinary.getClearResult(P(p)), R(GuardedBinary.getClearVal1(P(p))), 
                  Move.getClearResult(PR(p)), IC(Move.getClearVal(PR(p))));
  }

  /**
   * Emit code for rule number 71:
   * r: INT_REM(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code71(AbstractBURS_TreeNode p) {
    INT_REM(P(p), GuardedBinary.getClearResult(P(p)), R(GuardedBinary.getClearVal1(P(p))), R(GuardedBinary.getClearVal2(P(p))));
  }

  /**
   * Emit code for rule number 72:
   * r: INT_REM(r,REF_MOVE(INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code72(AbstractBURS_TreeNode p) {
    INT_REM_IMM(P(p), GuardedBinary.getClearResult(P(p)), R(GuardedBinary.getClearVal1(P(p))), 
            Move.getClearResult(PR(p)), IC(Move.getClearVal(PR(p))));
  }

  /**
   * Emit code for rule number 73:
   * r: REF_NEG(r)
   * @param p BURS node to apply the rule to
   */
  private void code73(AbstractBURS_TreeNode p) {
    EMIT(MIR_Unary.mutate(P(p), PPC_NEG, Unary.getResult(P(p)), Unary.getVal(P(p))));
  }

  /**
   * Emit code for rule number 74:
   * rz: INT_SHL(r,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code74(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_SLWI, Binary.getResult(P(p)),                
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 75:
   * rz: INT_SHL(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code75(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_SLW, Binary.getResult(P(p)), 
                       R(Binary.getVal1(P(p))), R(Binary.getVal2(P(p)))));
  }

  /**
   * Emit code for rule number 76:
   * rz: INT_SHL(INT_USHR(r,INT_CONSTANT),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code76(AbstractBURS_TreeNode p) {
    USHR_SHL(P(p), Binary.getClearResult(P(p)), R(Binary.getClearVal1(PL(p))), IC(Binary.getClearVal2(PL(p))),      
               IC(Binary.getClearVal2(P(p))));
  }

  /**
   * Emit code for rule number 77:
   * rs: INT_SHR(r,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code77(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_SRAWI, Binary.getResult(P(p)), R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 78:
   * rs: INT_SHR(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code78(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_SRAW, Binary.getResult(P(p)), 
                       R(Binary.getVal1(P(p))), R(Binary.getVal2(P(p)))));
  }

  /**
   * Emit code for rule number 79:
   * rp: INT_SHR(REF_AND(r,INT_CONSTANT),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code79(AbstractBURS_TreeNode p) {
    AND_USHR(P(p), Binary.getClearResult(P(p)),                      
                     R(Binary.getClearVal1(PL(p))), IC(Binary.getClearVal2(PL(p))),      
                     IC(Binary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 80:
   * rp: INT_USHR(r,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code80(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_SRWI, Binary.getResult(P(p)),                
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 81:
   * rz: INT_USHR(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code81(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_SRW, Binary.getResult(P(p)), 
                       R(Binary.getVal1(P(p))), R(Binary.getVal2(P(p)))));
  }

  /**
   * Emit code for rule number 82:
   * rp: INT_USHR(REF_AND(r,INT_CONSTANT),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code82(AbstractBURS_TreeNode p) {
    AND_USHR(P(p), Binary.getClearResult(P(p)), R(Binary.getClearVal1(PL(p))), 
         IC(Binary.getClearVal2(PL(p))), IC(Binary.getClearVal2(P(p))));
  }

  /**
   * Emit code for rule number 83:
   * rp: INT_USHR(REF_AND(r,REF_MOVE(INT_CONSTANT)),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code83(AbstractBURS_TreeNode p) {
    AND_USHR(P(p), Binary.getClearResult(P(p)), R(Binary.getClearVal1(PL(p))), 
         IC(Move.getClearVal(PLR(p))), IC(Binary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 84:
   * rp: INT_USHR(INT_SHL(r,INT_CONSTANT),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code84(AbstractBURS_TreeNode p) {
    SHL_USHR(P(p), Binary.getClearResult(P(p)), R(Binary.getClearVal1(PL(p))), 
         IC(Binary.getClearVal2(PL(p))), IC(Binary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 85:
   * r: REF_AND(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code85(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_AND, Binary.getResult(P(p)), R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 86:
   * czr: REF_AND(r,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code86(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_ANDIr, Binary.getResult(P(p)), R(Binary.getVal1(P(p))), IC(Binary.getVal2(P(p)))));
  }

  /**
   * Emit code for rule number 87:
   * rp: REF_AND(r,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code87(AbstractBURS_TreeNode p) {
    {                                                                             
   int mask = IV(Binary.getVal2(P(p)));                                   
   EMIT(MIR_RotateAndMask.create(PPC_RLWINM, Binary.getClearResult(P(p)),          
                                 R(Binary.getClearVal1(P(p))), IC(0),               
                                 IC(MaskBegin(mask)), IC(MaskEnd(mask))));                        
}
  }

  /**
   * Emit code for rule number 88:
   * r: REF_AND(REF_NOT(r),REF_NOT(r))
   * @param p BURS node to apply the rule to
   */
  private void code88(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_NOR, Binary.getResult(P(p)),                 
                       R(Unary.getVal(PL(p))), Unary.getVal(PR(p))));
  }

  /**
   * Emit code for rule number 89:
   * r: REF_AND(r,REF_NOT(r))
   * @param p BURS node to apply the rule to
   */
  private void code89(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_ANDC, Binary.getResult(P(p)),                
                       R(Binary.getVal1(P(p))), Unary.getClearVal(PR(p))));
  }

  /**
   * Emit code for rule number 90:
   * rp: REF_AND(INT_USHR(r,INT_CONSTANT),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code90(AbstractBURS_TreeNode p) {
    USHR_AND(P(p), Binary.getClearResult(P(p)), R(Binary.getClearVal1(PL(p))), 
               IC(Binary.getClearVal2(P(p))), IC(Binary.getClearVal2(PL(p))));
  }

  /**
   * Emit code for rule number 91:
   * rp: REF_AND(INT_USHR(r,INT_CONSTANT),REF_MOVE(INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code91(AbstractBURS_TreeNode p) {
    USHR_AND(P(p), Binary.getClearResult(P(p)), R(Binary.getClearVal1(PL(p))), 
               IC(Move.getClearVal(PR(p))), IC(Binary.getClearVal2(PL(p))));
  }

  /**
   * Emit code for rule number 92:
   * r: REF_OR(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code92(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_OR, Binary.getResult(P(p)), R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 93:
   * r: REF_OR(r,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code93(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_ORI, Binary.getResult(P(p)), R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 94:
   * r: REF_OR(REF_NOT(r),REF_NOT(r))
   * @param p BURS node to apply the rule to
   */
  private void code94(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_NAND, Binary.getResult(P(p)), R(Unary.getVal(PL(p))), Unary.getClearVal(PR(p))));
  }

  /**
   * Emit code for rule number 95:
   * r: REF_OR(r,REF_NOT(r))
   * @param p BURS node to apply the rule to
   */
  private void code95(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_ORC, Binary.getResult(P(p)), R(Binary.getVal1(P(p))), Unary.getClearVal(PR(p))));
  }

  /**
   * Emit code for rule number 96:
   * r: REF_XOR(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code96(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_XOR, Binary.getResult(P(p)), R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 97:
   * r: REF_XOR(r,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code97(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_XORI, Binary.getResult(P(p)), R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 98:
   * r: REF_NOT(r)
   * @param p BURS node to apply the rule to
   */
  private void code98(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_NOR, Unary.getResult(P(p)), R(Unary.getVal(P(p))), Unary.getVal(P(p))));
  }

  /**
   * Emit code for rule number 99:
   * r: REF_NOT(REF_OR(r,r))
   * @param p BURS node to apply the rule to
   */
  private void code99(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_NOR, Unary.getResult(P(p)), R(Binary.getClearVal1(PL(p))), Binary.getClearVal2(PL(p))));
  }

  /**
   * Emit code for rule number 100:
   * r: REF_NOT(REF_AND(r,r))
   * @param p BURS node to apply the rule to
   */
  private void code100(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_NAND, Unary.getResult(P(p)), R(Binary.getClearVal1(PL(p))), Binary.getClearVal2(PL(p))));
  }

  /**
   * Emit code for rule number 101:
   * r: REF_NOT(REF_XOR(r,r))
   * @param p BURS node to apply the rule to
   */
  private void code101(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_EQV, Unary.getResult(P(p)), R(Binary.getClearVal1(PL(p))), Binary.getClearVal2(PL(p))));
  }

  /**
   * Emit code for rule number 102:
   * r: FLOAT_ADD(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code102(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_FADDS, Binary.getResult(P(p)), 
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 103:
   * r: DOUBLE_ADD(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code103(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_FADD, Binary.getResult(P(p)),                
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 104:
   * r: FLOAT_MUL(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code104(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_FMULS, Binary.getResult(P(p)),               
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 105:
   * r: DOUBLE_MUL(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code105(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_FMUL, Binary.getResult(P(p)),                
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 106:
   * r: FLOAT_SUB(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code106(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_FSUBS, Binary.getResult(P(p)),               
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 107:
   * r: DOUBLE_SUB(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code107(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_FSUB, Binary.getResult(P(p)),                
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 108:
   * r: FLOAT_DIV(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code108(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_FDIVS, Binary.getResult(P(p)),               
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 109:
   * r: DOUBLE_DIV(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code109(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_FDIV, Binary.getResult(P(p)),                
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 110:
   * r: FLOAT_NEG(r)
   * @param p BURS node to apply the rule to
   */
  private void code110(AbstractBURS_TreeNode p) {
    EMIT(MIR_Unary.mutate(P(p), PPC_FNEG, Unary.getResult(P(p)), Unary.getVal(P(p))));
  }

  /**
   * Emit code for rule number 111:
   * r: DOUBLE_NEG(r)
   * @param p BURS node to apply the rule to
   */
  private void code111(AbstractBURS_TreeNode p) {
    EMIT(MIR_Unary.mutate(P(p), PPC_FNEG, Unary.getResult(P(p)), Unary.getVal(P(p))));
  }

  /**
   * Emit code for rule number 112:
   * r: FLOAT_SQRT(r)
   * @param p BURS node to apply the rule to
   */
  private void code112(AbstractBURS_TreeNode p) {
    EMIT(MIR_Unary.mutate(P(p), PPC_FSQRTS, Unary.getResult(P(p)), Unary.getVal(P(p))));
  }

  /**
   * Emit code for rule number 113:
   * r: DOUBLE_SQRT(r)
   * @param p BURS node to apply the rule to
   */
  private void code113(AbstractBURS_TreeNode p) {
    EMIT(MIR_Unary.mutate(P(p), PPC_FSQRT, Unary.getResult(P(p)), Unary.getVal(P(p))));
  }

  /**
   * Emit code for rule number 114:
   * r:  FLOAT_ADD(FLOAT_MUL(r, r), r)
   * @param p BURS node to apply the rule to
   */
  private void code114(AbstractBURS_TreeNode p) {
    EMIT(MIR_Ternary.mutate(P(p), PPC_FMADDS, Binary.getResult(P(p)),             
                        R(Binary.getClearVal1(PL(p))), R(Binary.getClearVal2(PL(p))),   
                        R(Binary.getVal2(P(p)))));
  }

  /**
   * Emit code for rule number 115:
   * r:  DOUBLE_ADD(DOUBLE_MUL(r, r), r)
   * @param p BURS node to apply the rule to
   */
  private void code115(AbstractBURS_TreeNode p) {
    EMIT(MIR_Ternary.mutate(P(p), PPC_FMADD, Binary.getResult(P(p)),              
                        R(Binary.getClearVal1(PL(p))), R(Binary.getClearVal2(PL(p))),   
                        R(Binary.getVal2(P(p)))));
  }

  /**
   * Emit code for rule number 116:
   * r: FLOAT_ADD(r, FLOAT_MUL(r,r))
   * @param p BURS node to apply the rule to
   */
  private void code116(AbstractBURS_TreeNode p) {
    EMIT(MIR_Ternary.mutate(P(p), PPC_FMADDS, Binary.getResult(P(p)),             
                        R(Binary.getClearVal1(PR(p))), R(Binary.getClearVal2(PR(p))),   
                        R(Binary.getVal1(P(p)))));
  }

  /**
   * Emit code for rule number 117:
   * r: DOUBLE_ADD(r, DOUBLE_MUL(r,r))
   * @param p BURS node to apply the rule to
   */
  private void code117(AbstractBURS_TreeNode p) {
    EMIT(MIR_Ternary.mutate(P(p), PPC_FMADD, Binary.getResult(P(p)),              
                        R(Binary.getClearVal1(PR(p))), R(Binary.getClearVal2(PR(p))),   
                        R(Binary.getVal1(P(p)))));
  }

  /**
   * Emit code for rule number 118:
   * r:  FLOAT_SUB(FLOAT_MUL(r, r), r)
   * @param p BURS node to apply the rule to
   */
  private void code118(AbstractBURS_TreeNode p) {
    EMIT(MIR_Ternary.mutate(P(p), PPC_FMSUBS, Binary.getResult(P(p)),             
                        R(Binary.getClearVal1(PL(p))), R(Binary.getClearVal2(PL(p))),   
                        R(Binary.getVal2(P(p)))));
  }

  /**
   * Emit code for rule number 119:
   * r:  DOUBLE_SUB(DOUBLE_MUL(r, r), r)
   * @param p BURS node to apply the rule to
   */
  private void code119(AbstractBURS_TreeNode p) {
    EMIT(MIR_Ternary.mutate(P(p), PPC_FMSUB, Binary.getResult(P(p)),              
                        R(Binary.getClearVal1(PL(p))), R(Binary.getClearVal2(PL(p))),   
                        R(Binary.getVal2(P(p)))));
  }

  /**
   * Emit code for rule number 120:
   * r:  FLOAT_NEG(FLOAT_ADD(FLOAT_MUL(r, r), r))
   * @param p BURS node to apply the rule to
   */
  private void code120(AbstractBURS_TreeNode p) {
    EMIT(MIR_Ternary.mutate(P(p), PPC_FNMADDS, Unary.getResult(P(p)),             
                        R(Binary.getClearVal1(PLL(p))), R(Binary.getClearVal2(PLL(p))), 
                        R(Binary.getVal2(PL(p)))));
  }

  /**
   * Emit code for rule number 121:
   * r:  DOUBLE_NEG(DOUBLE_ADD(DOUBLE_MUL(r, r), r))
   * @param p BURS node to apply the rule to
   */
  private void code121(AbstractBURS_TreeNode p) {
    EMIT(MIR_Ternary.mutate(P(p), PPC_FNMADD, Unary.getResult(P(p)),              
                        R(Binary.getClearVal1(PLL(p))), R(Binary.getClearVal2(PLL(p))), 
                        R(Binary.getClearVal2(PL(p)))));
  }

  /**
   * Emit code for rule number 122:
   * r: FLOAT_NEG(FLOAT_ADD(r, FLOAT_MUL(r,r)))
   * @param p BURS node to apply the rule to
   */
  private void code122(AbstractBURS_TreeNode p) {
    EMIT(MIR_Ternary.mutate(P(p), PPC_FNMADDS, Unary.getResult(P(p)),             
                        R(Binary.getClearVal1(PLR(p))), R(Binary.getClearVal2(PLR(p))), 
                        R(Binary.getClearVal1(PL(p)))));
  }

  /**
   * Emit code for rule number 123:
   * r: DOUBLE_NEG(DOUBLE_ADD(r, DOUBLE_MUL(r,r)))
   * @param p BURS node to apply the rule to
   */
  private void code123(AbstractBURS_TreeNode p) {
    EMIT(MIR_Ternary.mutate(P(p), PPC_FNMADD, Unary.getResult(P(p)),             
                        R(Binary.getClearVal1(PLR(p))), R(Binary.getClearVal2(PLR(p))),
                        R(Binary.getClearVal1(PL(p)))));
  }

  /**
   * Emit code for rule number 124:
   * r:  FLOAT_NEG(FLOAT_SUB(FLOAT_MUL(r, r), r))
   * @param p BURS node to apply the rule to
   */
  private void code124(AbstractBURS_TreeNode p) {
    EMIT(MIR_Ternary.mutate(P(p), PPC_FNMSUBS, Unary.getResult(P(p)),             
                        R(Binary.getClearVal1(PLL(p))), R(Binary.getClearVal2(PLL(p))), 
                        R(Binary.getClearVal2(PL(p)))));
  }

  /**
   * Emit code for rule number 125:
   * r:  DOUBLE_NEG(DOUBLE_SUB(DOUBLE_MUL(r, r), r))
   * @param p BURS node to apply the rule to
   */
  private void code125(AbstractBURS_TreeNode p) {
    EMIT(MIR_Ternary.mutate(P(p), PPC_FNMSUB, Unary.getResult(P(p)),              
                        R(Binary.getClearVal1(PLL(p))), R(Binary.getClearVal2(PLL(p))), 
                        R(Binary.getClearVal2(PL(p)))));
  }

  /**
   * Emit code for rule number 126:
   * rs: INT_2BYTE(r)
   * @param p BURS node to apply the rule to
   */
  private void code126(AbstractBURS_TreeNode p) {
    EMIT(MIR_Unary.mutate(P(p), PPC_EXTSB, Unary.getResult(P(p)), Unary.getVal(P(p))));
  }

  /**
   * Emit code for rule number 127:
   * rp: INT_2USHORT(r)
   * @param p BURS node to apply the rule to
   */
  private void code127(AbstractBURS_TreeNode p) {
    EMIT(MIR_RotateAndMask.create(PPC_RLWINM, Unary.getClearResult(P(p)), null,        
                              R(Unary.getClearVal(P(p))), IC(0), IC(16), IC(31)));
  }

  /**
   * Emit code for rule number 128:
   * rs: INT_2SHORT(r)
   * @param p BURS node to apply the rule to
   */
  private void code128(AbstractBURS_TreeNode p) {
    EMIT(MIR_Unary.mutate(P(p), PPC_EXTSH, Unary.getResult(P(p)), Unary.getVal(P(p))));
  }

  /**
   * Emit code for rule number 129:
   * r: INT_2FLOAT(r)
   * @param p BURS node to apply the rule to
   */
  private void code129(AbstractBURS_TreeNode p) {
    INT_2DOUBLE(P(p), Unary.getResult(P(p)), R(Unary.getVal(P(p))));
  }

  /**
   * Emit code for rule number 130:
   * r: INT_2DOUBLE(r)
   * @param p BURS node to apply the rule to
   */
  private void code130(AbstractBURS_TreeNode p) {
    INT_2DOUBLE(P(p), Unary.getResult(P(p)), R(Unary.getVal(P(p))));
  }

  /**
   * Emit code for rule number 131:
   * r: FLOAT_2INT(r)
   * @param p BURS node to apply the rule to
   */
  private void code131(AbstractBURS_TreeNode p) {
    EMIT(P(p));  // Leave for ComplexLIR2MIRExpansion
  }

  /**
   * Emit code for rule number 132:
   * r: FLOAT_2DOUBLE(r)
   * @param p BURS node to apply the rule to
   */
  private void code132(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), PPC_FMR, Unary.getResult(P(p)), R(Unary.getVal(P(p)))));
  }

  /**
   * Emit code for rule number 133:
   * r: DOUBLE_2INT(r)
   * @param p BURS node to apply the rule to
   */
  private void code133(AbstractBURS_TreeNode p) {
    EMIT(P(p));  // Leave for ComplexLIR2MIRExpansionLeave
  }

  /**
   * Emit code for rule number 134:
   * r: DOUBLE_2FLOAT(r)
   * @param p BURS node to apply the rule to
   */
  private void code134(AbstractBURS_TreeNode p) {
    EMIT(MIR_Unary.mutate(P(p), PPC_FRSP, Unary.getResult(P(p)), Unary.getVal(P(p))));
  }

  /**
   * Emit code for rule number 135:
   * r: FLOAT_AS_INT_BITS(r)
   * @param p BURS node to apply the rule to
   */
  private void code135(AbstractBURS_TreeNode p) {
    FPR2GPR_32(P(p));
  }

  /**
   * Emit code for rule number 136:
   * r: INT_BITS_AS_FLOAT(r)
   * @param p BURS node to apply the rule to
   */
  private void code136(AbstractBURS_TreeNode p) {
    GPR2FPR_32(P(p));
  }

  /**
   * Emit code for rule number 137:
   * r: REF_MOVE(r)
   * @param p BURS node to apply the rule to
   */
  private void code137(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), PPC_MOVE, Move.getResult(P(p)), R(Move.getVal(P(p)))));
  }

  /**
   * Emit code for rule number 138:
   * rs: REF_MOVE(INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code138(AbstractBURS_TreeNode p) {
    EMIT(MIR_Unary.mutate(P(p), PPC_LDI, Move.getResult(P(p)), Move.getVal(P(p))));
  }

  /**
   * Emit code for rule number 139:
   * rs: REF_MOVE(INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code139(AbstractBURS_TreeNode p) {
    EMIT(MIR_Unary.mutate(P(p), PPC_LDIS, Move.getResult(P(p)), SRI(IV(Move.getVal(P(p))), 16)));
  }

  /**
   * Emit code for rule number 140:
   * rs: REF_MOVE(INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code140(AbstractBURS_TreeNode p) {
    {                                                                             
   int one = IV(Move.getVal(P(p)));                                       
   EMIT(MIR_Unary.create(PPC_LDIS, Move.getResult(P(p)).copyRO(), CAU16(one)));        
   EMIT(MIR_Binary.mutate(P(p), PPC_ADDI, Move.getResult(P(p)).copyRO(),      
                          Move.getClearResult(P(p)), CAL16(one)));        
}
  }

  /**
   * Emit code for rule number 141:
   * r: FLOAT_MOVE(r)
   * @param p BURS node to apply the rule to
   */
  private void code141(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), PPC_FMR, Move.getResult(P(p)), R(Move.getVal(P(p)))));
  }

  /**
   * Emit code for rule number 142:
   * r: DOUBLE_MOVE(r)
   * @param p BURS node to apply the rule to
   */
  private void code142(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), PPC_FMR, Move.getResult(P(p)), R(Move.getVal(P(p)))));
  }

  /**
   * Emit code for rule number 143:
   * rs: BYTE_LOAD(r,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code143(AbstractBURS_TreeNode p) {
    BYTE_LOAD(P(p), PPC_LBZ, Load.getClearResult(P(p)), R(Load.getClearAddress(P(p))), Load.getClearOffset(P(p)), 
          Load.getClearLocation(P(p)), Load.getClearGuard(P(p)));
  }

  /**
   * Emit code for rule number 144:
   * rs: BYTE_LOAD(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code144(AbstractBURS_TreeNode p) {
    BYTE_LOAD(P(p), PPC_LBZX, Load.getClearResult(P(p)), R(Load.getClearAddress(P(p))), Load.getClearOffset(P(p)), 
          Load.getClearLocation(P(p)), Load.getClearGuard(P(p)));
  }

  /**
   * Emit code for rule number 145:
   * rp: REF_AND(BYTE_LOAD(r,r),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code145(AbstractBURS_TreeNode p) {
    EMIT(MIR_Load.mutate(PL(p), PPC_LBZX, Binary.getClearResult(P(p)), R(Load.getAddress(PL(p))), 
                     Load.getOffset(PL(p)), Load.getLocation(PL(p)), 
                     Load.getGuard(PL(p))));
  }

  /**
   * Emit code for rule number 146:
   * rp: REF_AND(BYTE_LOAD(r,INT_CONSTANT),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code146(AbstractBURS_TreeNode p) {
    EMIT(MIR_Load.mutate(PL(p), PPC_LBZ, Binary.getClearResult(P(p)), R(Load.getAddress(PL(p))), 
                     Load.getOffset(PL(p)), Load.getLocation(PL(p)), 
                     Load.getGuard(PL(p))));
  }

  /**
   * Emit code for rule number 147:
   * rp: UBYTE_LOAD(r,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code147(AbstractBURS_TreeNode p) {
    EMIT(MIR_Load.mutate(P(p), PPC_LBZ, Load.getResult(P(p)),            
                     R(Load.getAddress(P(p))), Load.getOffset(P(p)), 
                     Load.getLocation(P(p)), Load.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 148:
   * rp: UBYTE_LOAD(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code148(AbstractBURS_TreeNode p) {
    EMIT(MIR_Load.mutate(P(p), PPC_LBZX, Load.getResult(P(p)),           
                     R(Load.getAddress(P(p))), Load.getOffset(P(p)), 
                     Load.getLocation(P(p)), Load.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 149:
   * rs: SHORT_LOAD(r,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code149(AbstractBURS_TreeNode p) {
    EMIT(MIR_Load.mutate(P(p), PPC_LHA, Load.getResult(P(p)),            
                     R(Load.getAddress(P(p))), Load.getOffset(P(p)), 
                     Load.getLocation(P(p)), Load.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 150:
   * rs: SHORT_LOAD(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code150(AbstractBURS_TreeNode p) {
    EMIT(MIR_Load.mutate(P(p), PPC_LHAX, Load.getResult(P(p)),           
                     R(Load.getAddress(P(p))), Load.getOffset(P(p)), 
                     Load.getLocation(P(p)), Load.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 151:
   * rp: USHORT_LOAD(r,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code151(AbstractBURS_TreeNode p) {
    EMIT(MIR_Load.mutate(P(p), PPC_LHZ, Load.getResult(P(p)),            
                     R(Load.getAddress(P(p))), Load.getOffset(P(p)), 
                     Load.getLocation(P(p)), Load.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 152:
   * rp: USHORT_LOAD(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code152(AbstractBURS_TreeNode p) {
    EMIT(MIR_Load.mutate(P(p), PPC_LHZX, Load.getResult(P(p)),           
                     R(Load.getAddress(P(p))), Load.getOffset(P(p)), 
                     Load.getLocation(P(p)), Load.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 153:
   * r: FLOAT_LOAD(r,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code153(AbstractBURS_TreeNode p) {
    EMIT(MIR_Load.mutate(P(p), PPC_LFS, Load.getResult(P(p)),            
                     R(Load.getAddress(P(p))), Load.getOffset(P(p)), 
                     Load.getLocation(P(p)), Load.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 154:
   * r:      FLOAT_LOAD(r,REF_MOVE(ADDRESS_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code154(AbstractBURS_TreeNode p) {
    {                                                                             
   Address val = AV(Move.getVal(PR(p)));                                      
   EMIT(MIR_Binary.create(PPC_ADDIS, Move.getResult(PR(p)).copyRO(),                   
                          R(Load.getClearAddress(P(p))), CAU16(val)));             
   EMIT(MIR_Load.mutate(P(p), PPC_LFS, Load.getResult(P(p)),         
                        Move.getClearResult(PR(p)), CAL16(val),  
                        Load.getLocation(P(p)),                      
                        Load.getGuard(P(p))));                      
}
  }

  /**
   * Emit code for rule number 155:
   * r: FLOAT_LOAD(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code155(AbstractBURS_TreeNode p) {
    EMIT(MIR_Load.mutate(P(p), PPC_LFSX, Load.getResult(P(p)),           
                     R(Load.getAddress(P(p))), Load.getOffset(P(p)), 
                     Load.getLocation(P(p)), Load.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 156:
   * r: DOUBLE_LOAD(r,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code156(AbstractBURS_TreeNode p) {
    EMIT(MIR_Load.mutate(P(p), PPC_LFD, Load.getResult(P(p)),            
                     R(Load.getAddress(P(p))), Load.getOffset(P(p)), 
                     Load.getLocation(P(p)), Load.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 157:
   * r:      DOUBLE_LOAD(r,REF_MOVE(ADDRESS_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code157(AbstractBURS_TreeNode p) {
    {                                                                             
   Address val = AV(Move.getVal(PR(p)));                                      
   EMIT(MIR_Binary.create(PPC_ADDIS, Move.getResult(PR(p)).copyRO(),                   
                          R(Load.getClearAddress(P(p))), CAU16(val)));             
   EMIT(MIR_Load.mutate(P(p), PPC_LFD, Load.getResult(P(p)),         
                        Move.getClearResult(PR(p)), CAL16(val),  
                        Load.getLocation(P(p)),                      
                        Load.getGuard(P(p))));                      
}
  }

  /**
   * Emit code for rule number 158:
   * r: DOUBLE_LOAD(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code158(AbstractBURS_TreeNode p) {
    EMIT(MIR_Load.mutate(P(p), PPC_LFDX, Load.getResult(P(p)),           
                     R(Load.getAddress(P(p))), Load.getOffset(P(p)), 
                     Load.getLocation(P(p)), Load.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 159:
   * rs:      INT_LOAD(r,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code159(AbstractBURS_TreeNode p) {
    EMIT(MIR_Load.mutate(P(p), PPC_LInt, Load.getResult(P(p)),            
                     R(Load.getAddress(P(p))), Load.getOffset(P(p)), 
                     Load.getLocation(P(p)), Load.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 160:
   * rs:      INT_LOAD(r,REF_MOVE(ADDRESS_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code160(AbstractBURS_TreeNode p) {
    {                                                                             
   Address val = AV(Move.getVal(PR(p)));                                      
   EMIT(MIR_Binary.create(PPC_ADDIS, Move.getResult(PR(p)).copyRO(),                   
                          R(Load.getClearAddress(P(p))), CAU16(val)));             
   EMIT(MIR_Load.mutate(P(p), PPC_LInt, Load.getResult(P(p)),         
                        Move.getClearResult(PR(p)), CAL16(val),           
                        Load.getLocation(P(p)),                      
                        Load.getGuard(P(p))));                      
}
  }

  /**
   * Emit code for rule number 161:
   * rs:      INT_LOAD(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code161(AbstractBURS_TreeNode p) {
    EMIT(MIR_Load.mutate(P(p), PPC_LIntX, Load.getResult(P(p)),           
                     R(Load.getAddress(P(p))), Load.getOffset(P(p)), 
                     Load.getLocation(P(p)), Load.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 162:
   * rs:      INT_LOAD(REF_ADD(r,r),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code162(AbstractBURS_TreeNode p) {
    EMIT(MIR_Load.mutate(P(p), PPC_LIntX, Load.getResult(P(p)),           
                     R(Binary.getClearVal1(PL(p))), Binary.getClearVal2(PL(p)), 
                     Load.getLocation(P(p)), Load.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 163:
   * rs:      INT_LOAD(REF_ADD(r,INT_CONSTANT),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code163(AbstractBURS_TreeNode p) {
    EMIT(MIR_Load.mutate(P(p), PPC_LInt, Load.getResult(P(p)),            
                     R(Binary.getClearVal1(PL(p))), IC(VR(p)+VLR(p)), 
                     Load.getLocation(P(p)), Load.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 164:
   * stm: BYTE_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code164(AbstractBURS_TreeNode p) {
    EMIT(MIR_Store.mutate(P(p), PPC_STB, R(Store.getValue(P(p))),        
                      R(Store.getAddress(P(p))),                     
                      Store.getOffset(P(p)),                         
                      Store.getLocation(P(p)),                       
                      Store.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 165:
   * stm: BYTE_STORE(r,OTHER_OPERAND(r,r))
   * @param p BURS node to apply the rule to
   */
  private void code165(AbstractBURS_TreeNode p) {
    EMIT(MIR_Store.mutate(P(p), PPC_STBX, R(Store.getValue(P(p))),       
                      R(Store.getAddress(P(p))),                     
                      Store.getOffset(P(p)),                         
                      Store.getLocation(P(p)),                       
                      Store.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 166:
   * stm: BYTE_STORE(INT_2BYTE(r),OTHER_OPERAND(r,INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code166(AbstractBURS_TreeNode p) {
    EMIT(MIR_Store.mutate(P(p), PPC_STB, R(Unary.getClearVal(PL(p))),    
                      R(Store.getAddress(P(p))),                     
                      Store.getOffset(P(p)),                         
                      Store.getLocation(P(p)),                       
                      Store.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 167:
   * stm: BYTE_STORE(INT_2BYTE(r),OTHER_OPERAND(r,r))
   * @param p BURS node to apply the rule to
   */
  private void code167(AbstractBURS_TreeNode p) {
    EMIT(MIR_Store.mutate(P(p), PPC_STBX, R(Unary.getClearVal(PL(p))),   
                      R(Store.getAddress(P(p))),                     
                      Store.getOffset(P(p)),                         
                      Store.getLocation(P(p)),                       
                      Store.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 168:
   * stm: SHORT_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code168(AbstractBURS_TreeNode p) {
    EMIT(MIR_Store.mutate(P(p), PPC_STH, R(Store.getValue(P(p))),        
                               R(Store.getAddress(P(p))),                     
                               Store.getOffset(P(p)),                         
                               Store.getLocation(P(p)),                       
                               Store.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 169:
   * stm: SHORT_STORE(r,OTHER_OPERAND(r,r))
   * @param p BURS node to apply the rule to
   */
  private void code169(AbstractBURS_TreeNode p) {
    EMIT(MIR_Store.mutate(P(p), PPC_STHX, R(Store.getValue(P(p))),       
                               R(Store.getAddress(P(p))),                     
                               Store.getOffset(P(p)),                         
                               Store.getLocation(P(p)),                       
                               Store.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 170:
   * stm: SHORT_STORE(INT_2SHORT(r),OTHER_OPERAND(r,INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code170(AbstractBURS_TreeNode p) {
    EMIT(MIR_Store.mutate(P(p), PPC_STH, R(Unary.getClearVal(PL(p))),         
                               R(Store.getAddress(P(p))),                     
                               Store.getOffset(P(p)),                         
                               Store.getLocation(P(p)),                       
                               Store.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 171:
   * stm: SHORT_STORE(INT_2SHORT(r),OTHER_OPERAND(r,r))
   * @param p BURS node to apply the rule to
   */
  private void code171(AbstractBURS_TreeNode p) {
    EMIT(MIR_Store.mutate(P(p), PPC_STHX, R(Unary.getClearVal(PL(p))),        
                               R(Store.getAddress(P(p))),                     
                               Store.getOffset(P(p)),                         
                               Store.getLocation(P(p)),                       
                               Store.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 172:
   * stm: SHORT_STORE(INT_2USHORT(r),OTHER_OPERAND(r,INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code172(AbstractBURS_TreeNode p) {
    EMIT(MIR_Store.mutate(P(p), PPC_STH, R(Unary.getClearVal(PL(p))),         
                               R(Store.getAddress(P(p))),                     
                               Store.getOffset(P(p)),                         
                               Store.getLocation(P(p)),                       
                               Store.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 173:
   * stm: SHORT_STORE(INT_2USHORT(r),OTHER_OPERAND(r,r))
   * @param p BURS node to apply the rule to
   */
  private void code173(AbstractBURS_TreeNode p) {
    EMIT(MIR_Store.mutate(P(p), PPC_STHX, R(Unary.getClearVal(PL(p))),        
                               R(Store.getAddress(P(p))),                     
                               Store.getOffset(P(p)),                         
                               Store.getLocation(P(p)),                       
                               Store.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 174:
   * stm: INT_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code174(AbstractBURS_TreeNode p) {
    EMIT(MIR_Store.mutate(P(p), PPC_STW, R(Store.getValue(P(p))),        
                               R(Store.getAddress(P(p))),                     
                               Store.getOffset(P(p)),                         
                               Store.getLocation(P(p)),                       
                               Store.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 175:
   * stm: INT_STORE(r,OTHER_OPERAND(r,REF_MOVE(ADDRESS_CONSTANT)))
   * @param p BURS node to apply the rule to
   */
  private void code175(AbstractBURS_TreeNode p) {
    {                                                                             
   Address val = AV(Move.getVal(PRR(p)));                                     
   EMIT(MIR_Binary.create(PPC_ADDIS, Move.getResult(PRR(p)).copyRO(),                  
                          R(Store.getClearAddress(P(p))), CAU16(val)));            
   EMIT(MIR_Store.mutate(P(p), PPC_STW, R(Store.getValue(P(p))),     
                                  Move.getClearResult(PRR(p)), CAL16(val),
                           Store.getLocation(P(p)),                    
                                  Store.getGuard(P(p))));                    
}
  }

  /**
   * Emit code for rule number 176:
   * stm: INT_STORE(r,OTHER_OPERAND(r,r))
   * @param p BURS node to apply the rule to
   */
  private void code176(AbstractBURS_TreeNode p) {
    EMIT(MIR_Store.mutate(P(p), PPC_STWX, R(Store.getValue(P(p))),       
                               R(Store.getAddress(P(p))),                     
                               Store.getOffset(P(p)),                         
                               Store.getLocation(P(p)),                       
                               Store.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 177:
   * stm: INT_STORE(r,OTHER_OPERAND(REF_ADD(r,INT_CONSTANT),INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code177(AbstractBURS_TreeNode p) {
    EMIT(MIR_Store.mutate(P(p), PPC_STW, R(Store.getValue(P(p))),        
                               R(Binary.getClearVal1(PRL(p))),                     
                               IC(VRR(p) + VRLR(p)), 
                               Store.getLocation(P(p)),                       
                               Store.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 178:
   * stm: FLOAT_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code178(AbstractBURS_TreeNode p) {
    EMIT(MIR_Store.mutate(P(p), PPC_STFS, R(Store.getValue(P(p))),       
                               R(Store.getAddress(P(p))),                     
                               Store.getOffset(P(p)),                         
                               Store.getLocation(P(p)),                       
                               Store.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 179:
   * stm:      FLOAT_STORE(r,OTHER_OPERAND(r,REF_MOVE(ADDRESS_CONSTANT)))
   * @param p BURS node to apply the rule to
   */
  private void code179(AbstractBURS_TreeNode p) {
    {                                                                             
   Address val = AV(Move.getVal(PRR(p)));                                     
   EMIT(MIR_Binary.create(PPC_ADDIS, Move.getResult(PRR(p)).copyRO(),          
                          R(Store.getAddress(P(p))), CAU16(val)));            
   EMIT(MIR_Store.mutate(P(p), PPC_STFS, R(Store.getValue(P(p))),    
                                  Move.getClearResult(PRR(p)), CAL16(val),
                                  Store.getLocation(P(p)),                    
                                  Store.getGuard(P(p))));                    
}
  }

  /**
   * Emit code for rule number 180:
   * stm: FLOAT_STORE(r,OTHER_OPERAND(r,r))
   * @param p BURS node to apply the rule to
   */
  private void code180(AbstractBURS_TreeNode p) {
    EMIT(MIR_Store.mutate(P(p), PPC_STFSX, R(Store.getValue(P(p))),      
                               R(Store.getAddress(P(p))),                     
                               Store.getOffset(P(p)),                         
                               Store.getLocation(P(p)),                       
                               Store.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 181:
   * stm: DOUBLE_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code181(AbstractBURS_TreeNode p) {
    EMIT(MIR_Store.mutate(P(p), PPC_STFD, R(Store.getValue(P(p))),       
                               R(Store.getAddress(P(p))),                     
                               Store.getOffset(P(p)),                         
                               Store.getLocation(P(p)),                       
                               Store.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 182:
   * stm:      DOUBLE_STORE(r,OTHER_OPERAND(r,REF_MOVE(ADDRESS_CONSTANT)))
   * @param p BURS node to apply the rule to
   */
  private void code182(AbstractBURS_TreeNode p) {
    {                                                                             
   Address val = AV(Move.getVal(PRR(p)));                                     
   EMIT(MIR_Binary.create(PPC_ADDIS, Move.getResult(PRR(p)).copyRO(),         
                          R(Store.getAddress(P(p))), CAU16(val)));            
   EMIT(MIR_Store.mutate(P(p), PPC_STFD, R(Store.getValue(P(p))),    
                                  Move.getClearResult(PRR(p)), CAL16(val),
                                  Store.getLocation(P(p)),                    
                                  Store.getGuard(P(p))));                    
}
  }

  /**
   * Emit code for rule number 183:
   * stm: DOUBLE_STORE(r,OTHER_OPERAND(r,r))
   * @param p BURS node to apply the rule to
   */
  private void code183(AbstractBURS_TreeNode p) {
    EMIT(MIR_Store.mutate(P(p), PPC_STFDX, R(Store.getValue(P(p))),      
                               R(Store.getAddress(P(p))),                     
                               Store.getOffset(P(p)),                         
                               Store.getLocation(P(p)),                       
                               Store.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 184:
   * stm: INT_IFCMP(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code184(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getClearGuardResult(P(p)), new TrueGuardOperand()))); 
CMP(P(p), R(IfCmp.getClearVal1(P(p))), IfCmp.getClearVal2(P(p)), IfCmp.getCond(P(p)), false);
  }

  /**
   * Emit code for rule number 185:
   * stm: INT_IFCMP(r,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code185(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getClearGuardResult(P(p)), new TrueGuardOperand()))); 
CMP(P(p), R(IfCmp.getClearVal1(P(p))), IfCmp.getClearVal2(P(p)), IfCmp.getCond(P(p)), true);
  }

  /**
   * Emit code for rule number 186:
   * stm: INT_IFCMP(INT_2BYTE(r),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code186(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getClearGuardResult(P(p)), new TrueGuardOperand()))); 
CMP_ZERO(P(p), PPC_EXTSBr, Unary.getClearResult(PL(p)),         
                     Unary.getClearVal(PL(p)), IfCmp.getCond(P(p)));
  }

  /**
   * Emit code for rule number 187:
   * stm: INT_IFCMP(INT_2SHORT(r),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code187(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getClearGuardResult(P(p)), new TrueGuardOperand()))); 
CMP_ZERO(P(p), PPC_EXTSHr, Unary.getClearResult(PL(p)),         
                     Unary.getClearVal(PL(p)), IfCmp.getCond(P(p)));
  }

  /**
   * Emit code for rule number 188:
   * stm: INT_IFCMP(INT_USHR(r,r),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code188(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getClearGuardResult(P(p)), new TrueGuardOperand()))); 
CMP_ZERO(P(p), PPC_SRWr, Binary.getClearResult(PL(p)),          
                     R(Binary.getClearVal1(PL(p))), Binary.getClearVal2(PL(p)), IfCmp.getCond(P(p)));
  }

  /**
   * Emit code for rule number 189:
   * stm: INT_IFCMP(INT_SHL(r,r),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code189(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getClearGuardResult(P(p)), new TrueGuardOperand()))); 
CMP_ZERO(P(p), PPC_SLWr, Binary.getClearResult(PL(p)),          
                     R(Binary.getClearVal1(PL(p))), Binary.getClearVal2(PL(p)), IfCmp.getCond(P(p)));
  }

  /**
   * Emit code for rule number 190:
   * stm: INT_IFCMP(INT_SHR(r,r),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code190(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getClearGuardResult(P(p)), new TrueGuardOperand()))); 
CMP_ZERO(P(p), PPC_SRAWr, Binary.getClearResult(PL(p)),         
                     R(Binary.getClearVal1(PL(p))), Binary.getClearVal2(PL(p)), IfCmp.getCond(P(p)));
  }

  /**
   * Emit code for rule number 191:
   * stm: INT_IFCMP(INT_USHR(r,INT_CONSTANT),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code191(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getClearGuardResult(P(p)), new TrueGuardOperand()))); 
CMP_ZERO(P(p), PPC_SRWIr, Binary.getClearResult(PL(p)),         
                     R(Binary.getClearVal1(PL(p))), Binary.getClearVal2(PL(p)), IfCmp.getCond(P(p)));
  }

  /**
   * Emit code for rule number 192:
   * stm: INT_IFCMP(INT_SHL(r,INT_CONSTANT),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code192(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getClearGuardResult(P(p)), new TrueGuardOperand()))); 
CMP_ZERO(P(p), PPC_SLWIr, Binary.getClearResult(PL(p)),         
                     R(Binary.getClearVal1(PL(p))), Binary.getClearVal2(PL(p)), IfCmp.getCond(P(p)));
  }

  /**
   * Emit code for rule number 193:
   * stm: INT_IFCMP(INT_SHR(r,INT_CONSTANT),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code193(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getClearGuardResult(P(p)), new TrueGuardOperand()))); 
CMP_ZERO(P(p), PPC_SRAWIr, Binary.getClearResult(PL(p)),        
                     R(Binary.getClearVal1(PL(p))), Binary.getClearVal2(PL(p)), IfCmp.getCond(P(p)));
  }

  /**
   * Emit code for rule number 194:
   * stm: INT_IFCMP(REF_AND(r,INT_CONSTANT),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code194(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getClearGuardResult(P(p)), new TrueGuardOperand()))); 
CMP_ZERO(P(p), PPC_ANDIr, Binary.getClearResult(PL(p)),         
                     R(Binary.getClearVal1(PL(p))), Binary.getClearVal2(PL(p)), IfCmp.getCond(P(p)));
  }

  /**
   * Emit code for rule number 195:
   * stm: INT_IFCMP(boolcmp, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code195(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getClearGuardResult(P(p)), new TrueGuardOperand()))); 
EMIT_BOOLCMP_BRANCH(IfCmp.getClearTarget(P(p)), IfCmp.getClearBranchProfile(P(p)));
  }

  /**
   * Emit code for rule number 196:
   * stm: INT_IFCMP(boolcmp, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code196(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getClearGuardResult(P(p)), new TrueGuardOperand()))); 
FLIP_BOOLCMP(); EMIT_BOOLCMP_BRANCH(IfCmp.getClearTarget(P(p)), IfCmp.getClearBranchProfile(P(p)));
  }

  /**
   * Emit code for rule number 197:
   * stm: INT_IFCMP(boolcmp, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code197(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getClearGuardResult(P(p)), new TrueGuardOperand()))); 
EMIT_BOOLCMP_BRANCH(IfCmp.getClearTarget(P(p)), IfCmp.getClearBranchProfile(P(p)));
  }

  /**
   * Emit code for rule number 198:
   * stm: INT_IFCMP(boolcmp, INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code198(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getClearGuardResult(P(p)), new TrueGuardOperand()))); 
FLIP_BOOLCMP(); EMIT_BOOLCMP_BRANCH(IfCmp.getClearTarget(P(p)), IfCmp.getClearBranchProfile(P(p)));
  }

  /**
   * Emit code for rule number 199:
   * stm: INT_IFCMP2(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code199(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp2.getClearGuardResult(P(p)), new TrueGuardOperand()))); 
CMP2(P(p), R(IfCmp2.getClearVal1(P(p))), IfCmp2.getClearVal2(P(p)), IfCmp2.getClearCond1(P(p)), IfCmp2.getClearCond2(P(p)), false);
  }

  /**
   * Emit code for rule number 200:
   * stm: INT_IFCMP2(r,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code200(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp2.getClearGuardResult(P(p)), new TrueGuardOperand()))); 
CMP2(P(p), R(IfCmp2.getClearVal1(P(p))), IfCmp2.getClearVal2(P(p)), IfCmp2.getClearCond1(P(p)), IfCmp2.getClearCond2(P(p)), true);
  }

  /**
   * Emit code for rule number 201:
   * stm:   FLOAT_IFCMP(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code201(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getClearGuardResult(P(p)), new TrueGuardOperand()))); 
DOUBLE_IFCMP(P(p), R(IfCmp.getClearVal1(P(p))), IfCmp.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 202:
   * stm:   DOUBLE_IFCMP(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code202(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getClearGuardResult(P(p)), new TrueGuardOperand()))); 
DOUBLE_IFCMP(P(p), R(IfCmp.getClearVal1(P(p))), IfCmp.getClearVal2(P(p)));
  }

  /**
   * Emit code for rule number 203:
   * stm: FLOAT_CMPL(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code203(AbstractBURS_TreeNode p) {
    EMIT (P(p)); //  Leave for ComplexLIR2MIRExpansion
  }

  /**
   * Emit code for rule number 204:
   * stm: FLOAT_CMPG(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code204(AbstractBURS_TreeNode p) {
    EMIT (P(p)); //  Leave for ComplexLIR2MIRExpansion
  }

  /**
   * Emit code for rule number 205:
   * stm: DOUBLE_CMPL(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code205(AbstractBURS_TreeNode p) {
    EMIT (P(p)); //  Leave for ComplexLIR2MIRExpansion
  }

  /**
   * Emit code for rule number 206:
   * stm: DOUBLE_CMPG(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code206(AbstractBURS_TreeNode p) {
    EMIT (P(p)); //  Leave for ComplexLIR2MIRExpansion
  }

  /**
   * Emit code for rule number 207:
   * stm: GOTO
   * @param p BURS node to apply the rule to
   */
  private void code207(AbstractBURS_TreeNode p) {
    EMIT(MIR_Branch.mutate(P(p), PPC_B, Goto.getTarget(P(p))));
  }

  /**
   * Emit code for rule number 208:
   * stm: RETURN(NULL)
   * @param p BURS node to apply the rule to
   */
  private void code208(AbstractBURS_TreeNode p) {
    RETURN(P(p), null);
  }

  /**
   * Emit code for rule number 209:
   * stm: RETURN(r)
   * @param p BURS node to apply the rule to
   */
  private void code209(AbstractBURS_TreeNode p) {
    RETURN(P(p), Return.getVal(P(p)));
  }

  /**
   * Emit code for rule number 210:
   * r: CALL(r,any)
   * @param p BURS node to apply the rule to
   */
  private void code210(AbstractBURS_TreeNode p) {
    CALL(P(p));
  }

  /**
   * Emit code for rule number 211:
   * r: CALL(BRANCH_TARGET,any)
   * @param p BURS node to apply the rule to
   */
  private void code211(AbstractBURS_TreeNode p) {
    CALL(P(p));
  }

  /**
   * Emit code for rule number 212:
   * r: SYSCALL(r,any)
   * @param p BURS node to apply the rule to
   */
  private void code212(AbstractBURS_TreeNode p) {
    SYSCALL(P(p));
  }

  /**
   * Emit code for rule number 213:
   * r: GET_TIME_BASE
   * @param p BURS node to apply the rule to
   */
  private void code213(AbstractBURS_TreeNode p) {
    EMIT(P(p));  // Leave for ComplexLIR2MIRExpansion
  }

  /**
   * Emit code for rule number 215:
   * r:  YIELDPOINT_OSR(any, any)
   * @param p BURS node to apply the rule to
   */
  private void code215(AbstractBURS_TreeNode p) {
    OSR(burs, P(p));
  }

  /**
   * Emit code for rule number 216:
   * r:      PREPARE_INT(r, r)
   * @param p BURS node to apply the rule to
   */
  private void code216(AbstractBURS_TreeNode p) {
    EMIT(MIR_Load.mutate(P(p), PPC_LWARX, Prepare.getResult(P(p)),   
                     R(Prepare.getAddress(P(p))), Prepare.getOffset(P(p)),           
                     Prepare.getLocation(P(p)),                  
                     Prepare.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 217:
   * r:      PREPARE_LONG(r, r)
   * @param p BURS node to apply the rule to
   */
  private void code217(AbstractBURS_TreeNode p) {
    EMIT(MIR_Load.mutate(P(p), PPC_LAddrARX, Prepare.getResult(P(p)),   
                     R(Prepare.getAddress(P(p))), Prepare.getOffset(P(p)),           
                     Prepare.getLocation(P(p)),                  
                     Prepare.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 218:
   * r:      ATTEMPT_INT(r, r)
   * @param p BURS node to apply the rule to
   */
  private void code218(AbstractBURS_TreeNode p) {
    EMIT(P(p));  // Leave for ComplexLIR2MIRExpansion
  }

  /**
   * Emit code for rule number 219:
   * r:      ATTEMPT_LONG(r, r)
   * @param p BURS node to apply the rule to
   */
  private void code219(AbstractBURS_TreeNode p) {
    EMIT(P(p));  // Leave for ComplexLIR2MIRExpansion
  }

  /**
   * Emit code for rule number 220:
   * stm: IR_PROLOGUE
   * @param p BURS node to apply the rule to
   */
  private void code220(AbstractBURS_TreeNode p) {
    EMIT(P(p));
  }

  /**
   * Emit code for rule number 221:
   * r:      LONG_MUL(r,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code221(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC_MULLI, Binary.getResult(P(p)),               
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 222:
   * r:      LONG_MUL(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code222(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC64_MULLD, Binary.getResult(P(p)),               
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 223:
   * r:      LONG_DIV(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code223(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC64_DIVD, GuardedBinary.getResult(P(p)),  
                       R(GuardedBinary.getVal1(P(p))), GuardedBinary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 224:
   * r:      LONG_DIV(r,REF_MOVE(INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code224(AbstractBURS_TreeNode p) {
    LONG_DIV_IMM(P(p), GuardedBinary.getResult(P(p)), R(GuardedBinary.getVal1(P(p))), 
                   Move.getResult(PR(p)), IC(Move.getClearVal(PR(p))));
  }

  /**
   * Emit code for rule number 225:
   * r:      LONG_REM(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code225(AbstractBURS_TreeNode p) {
    LONG_REM(P(p), GuardedBinary.getClearResult(P(p)), R(GuardedBinary.getClearVal1(P(p))), R(GuardedBinary.getClearVal2(P(p))));
  }

  /**
   * Emit code for rule number 226:
   * r:      LONG_REM(r,REF_MOVE(INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code226(AbstractBURS_TreeNode p) {
    LONG_REM_IMM(P(p), GuardedBinary.getClearResult(P(p)), R(GuardedBinary.getClearVal1(P(p))), 
                   Move.getClearResult(PR(p)), IC(Move.getClearVal(PR(p))));
  }

  /**
   * Emit code for rule number 227:
   * r:      LONG_SHL(r,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code227(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC64_SLDI, Binary.getResult(P(p)),              
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 228:
   * r:      LONG_SHL(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code228(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC64_SLD, Binary.getResult(P(p)),               
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 229:
   * r:      LONG_SHL(LONG_USHR(r,INT_CONSTANT),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code229(AbstractBURS_TreeNode p) {
    EMIT(MIR_RotateAndMask.mutate(P(p), PPC64_RLDICR, Binary.getResult(P(p)), R(Binary.getClearVal1(PL(p))), 
                              IC(VR(p) - VLR(p)), IC(0), IC(63 - VR(p))));
  }

  /**
   * Emit code for rule number 230:
   * r:      LONG_USHR(LONG_SHL(r,INT_CONSTANT),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code230(AbstractBURS_TreeNode p) {
    EMIT(MIR_RotateAndMask.mutate(P(p), PPC64_RLDICL, Binary.getResult(P(p)), R(Binary.getClearVal1(PL(p))), 
                              IC(64 - (VR(p) - VLR(p))), IC(VR(p)), IC(63)));
  }

  /**
   * Emit code for rule number 231:
   * r:      LONG_SHR(r,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code231(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC64_SRADI, Binary.getResult(P(p)), R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 232:
   * r:      LONG_SHR(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code232(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC64_SRAD, Binary.getResult(P(p)), R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 233:
   * r:      LONG_USHR(r,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code233(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC64_SRDI, Binary.getResult(P(p)), R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 234:
   * r:      LONG_USHR(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code234(AbstractBURS_TreeNode p) {
    EMIT(MIR_Binary.mutate(P(p), PPC64_SRD, Binary.getResult(P(p)),               
                       R(Binary.getVal1(P(p))), Binary.getVal2(P(p))));
  }

  /**
   * Emit code for rule number 235:
   * rs: INT_2LONG(r)
   * @param p BURS node to apply the rule to
   */
  private void code235(AbstractBURS_TreeNode p) {
    INT_2LONG(P(p), Unary.getClearResult(P(p)), R(Unary.getClearVal(P(p))));
  }

  /**
   * Emit code for rule number 236:
   * rs: INT_2LONG(rs)
   * @param p BURS node to apply the rule to
   */
  private void code236(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), PPC_MOVE, Unary.getResult(P(p)), R(Unary.getVal(P(p)))));
  }

  /**
   * Emit code for rule number 237:
   * r: LONG_2INT(r)
   * @param p BURS node to apply the rule to
   */
  private void code237(AbstractBURS_TreeNode p) {
    LONG_2INT(P(p), Unary.getClearResult(P(p)), R(Unary.getClearVal(P(p))));
  }

  /**
   * Emit code for rule number 238:
   * r: FLOAT_2LONG(r)
   * @param p BURS node to apply the rule to
   */
  private void code238(AbstractBURS_TreeNode p) {
    EMIT(P(p));  // Leave for ComplexLIR2MIRExpansion
  }

  /**
   * Emit code for rule number 239:
   * r: DOUBLE_2LONG(r)
   * @param p BURS node to apply the rule to
   */
  private void code239(AbstractBURS_TreeNode p) {
    EMIT(P(p));  // Leave for ComplexLIR2MIRExpansionLeave
  }

  /**
   * Emit code for rule number 240:
   * r: DOUBLE_AS_LONG_BITS(r)
   * @param p BURS node to apply the rule to
   */
  private void code240(AbstractBURS_TreeNode p) {
    FPR2GPR_64(P(p));
  }

  /**
   * Emit code for rule number 241:
   * r: LONG_BITS_AS_DOUBLE(r)
   * @param p BURS node to apply the rule to
   */
  private void code241(AbstractBURS_TreeNode p) {
    GPR2FPR_64(P(p));
  }

  /**
   * Emit code for rule number 242:
   * r: REF_MOVE(ADDRESS_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code242(AbstractBURS_TreeNode p) {
    LONG_CONSTANT(P(p), Move.getResult(P(p)), AC(Move.getVal(P(p))));
  }

  /**
   * Emit code for rule number 243:
   * r: REF_MOVE(LONG_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code243(AbstractBURS_TreeNode p) {
    LONG_CONSTANT(P(p), Move.getResult(P(p)), LC(Move.getVal(P(p))));
  }

  /**
   * Emit code for rule number 244:
   * r: LONG_CMP(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code244(AbstractBURS_TreeNode p) {
    EMIT (P(p)); //  Leave for ComplexLIR2MIRExpansion
  }

  /**
   * Emit code for rule number 245:
   * stm:      LONG_IFCMP(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code245(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getClearGuardResult(P(p)), new TrueGuardOperand()))); 
CMP64(P(p), R(IfCmp.getClearVal1(P(p))), IfCmp.getClearVal2(P(p)), IfCmp.getCond(P(p)), false);
  }

  /**
   * Emit code for rule number 246:
   * stm:      LONG_IFCMP(r,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code246(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getClearGuardResult(P(p)), new TrueGuardOperand()))); 
CMP64(P(p), R(IfCmp.getClearVal1(P(p))), IfCmp.getClearVal2(P(p)), IfCmp.getCond(P(p)), true);
  }

  /**
   * Emit code for rule number 247:
   * stm:      LONG_IFCMP(r,LONG_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code247(AbstractBURS_TreeNode p) {
    EMIT(CPOS(P(p), Move.create(GUARD_MOVE, IfCmp.getClearGuardResult(P(p)), new TrueGuardOperand()))); 
CMP64(P(p), R(IfCmp.getClearVal1(P(p))), IfCmp.getClearVal2(P(p)), IfCmp.getCond(P(p)), true);
  }

  /**
   * Emit code for rule number 248:
   * stm:    INT_IFCMP(ATTEMPT_INT(r,r),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code248(AbstractBURS_TreeNode p) {
    {                                                                             
   ConditionOperand c = IfCmp.getCond(P(p)).flipCode();                   
   EMIT(MIR_Store.create(PPC_STWCXr, R(Attempt.getClearNewValue(PL(p))), 
                                  R(Attempt.getClearAddress(PL(p))), Attempt.getClearOffset(PL(p)),           
                                  Attempt.getClearLocation(PL(p)),                
                                  Attempt.getClearGuard(PL(p))));                
   EMIT(MIR_CondBranch.mutate(P(p), PPC_BCOND, CR(0),                         
                              new PowerPCConditionOperand(c),             
                              IfCmp.getTarget(P(p)),                         
                              IfCmp.getBranchProfile(P(p))));                 
}
  }

  /**
   * Emit code for rule number 249:
   * stm:    INT_IFCMP(ATTEMPT_ADDR(r,r),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code249(AbstractBURS_TreeNode p) {
    {                                                                             
   ConditionOperand c = IfCmp.getCond(P(p)).flipCode();                   
   EMIT(MIR_Store.create(PPC_STAddrCXr, R(Attempt.getClearNewValue(PL(p))), 
                                  R(Attempt.getClearAddress(PL(p))), Attempt.getClearOffset(PL(p)),           
                                  Attempt.getClearLocation(PL(p)),                
                                  Attempt.getClearGuard(PL(p))));                
   EMIT(MIR_CondBranch.mutate(P(p), PPC_BCOND, CR(0),                         
                              new PowerPCConditionOperand(c),             
                              IfCmp.getTarget(P(p)),                         
                              IfCmp.getBranchProfile(P(p))));                 
}
  }

  /**
   * Emit code for rule number 250:
   * rz: INT_2ADDRZerExt(rz)
   * @param p BURS node to apply the rule to
   */
  private void code250(AbstractBURS_TreeNode p) {
    EMIT(MIR_Move.mutate(P(p), PPC_MOVE, Unary.getResult(P(p)), R(Unary.getVal(P(p)))));
  }

  /**
   * Emit code for rule number 251:
   * rz: INT_2ADDRZerExt(r)
   * @param p BURS node to apply the rule to
   */
  private void code251(AbstractBURS_TreeNode p) {
    INT_2ADDRZerExt(P(p), Unary.getClearResult(P(p)), R(Unary.getClearVal(P(p))));
  }

  /**
   * Emit code for rule number 252:
   * rz: INT_2ADDRZerExt(INT_LOAD(r,INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code252(AbstractBURS_TreeNode p) {
    EMIT(MIR_Load.mutate(PL(p), PPC_LWZ, Unary.getClearResult(P(p)),            
                     R(Load.getAddress(PL(p))), Load.getOffset(PL(p)), 
                     Load.getLocation(PL(p)), Load.getGuard(PL(p))));
  }

  /**
   * Emit code for rule number 253:
   * rz: INT_2ADDRZerExt(INT_LOAD(r,r))
   * @param p BURS node to apply the rule to
   */
  private void code253(AbstractBURS_TreeNode p) {
    EMIT(MIR_Load.mutate(PL(p), PPC_LWZX, Unary.getClearResult(P(p)),           
                     R(Load.getAddress(PL(p))), Load.getOffset(PL(p)), 
                     Load.getLocation(PL(p)), Load.getGuard(PL(p))));
  }

  /**
   * Emit code for rule number 254:
   * rz: INT_2ADDRZerExt(INT_LOAD(REF_ADD(r,INT_CONSTANT),INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code254(AbstractBURS_TreeNode p) {
    EMIT(MIR_Load.mutate(PL(p), PPC_LWZ, Unary.getClearResult(P(p)),            
                              R(Binary.getClearVal1(PLL(p))), IC(VLR(p)+VLLR(p)), 
                              Load.getLocation(PL(p)), Load.getGuard(PL(p))));
  }

  /**
   * Emit code for rule number 255:
   * r: LONG_LOAD(r,INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code255(AbstractBURS_TreeNode p) {
    EMIT(MIR_Load.mutate(P(p), PPC_LAddr, Load.getResult(P(p)),            
                     R(Load.getAddress(P(p))), Load.getOffset(P(p)), 
                     Load.getLocation(P(p)), Load.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 256:
   * r: LONG_LOAD(r,REF_MOVE(ADDRESS_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code256(AbstractBURS_TreeNode p) {
    {                                                                             
   Address val = AV(Move.getVal(PR(p)));                                      
   EMIT(MIR_Binary.create(PPC_ADDIS, Move.getResult(PR(p)).copyRO(),           
                          R(Load.getClearAddress(P(p))), CAU16(val)));             
   EMIT(MIR_Load.mutate(P(p), PPC_LAddr, Load.getResult(P(p)),         
                                 Move.getClearResult(PR(p)), CAL16(val),  
                                 Load.getLocation(P(p)),                      
                                 Load.getGuard(P(p))));                      
}
  }

  /**
   * Emit code for rule number 257:
   * r: LONG_LOAD(r,r)
   * @param p BURS node to apply the rule to
   */
  private void code257(AbstractBURS_TreeNode p) {
    EMIT(MIR_Load.mutate(P(p), PPC_LAddrX, Load.getResult(P(p)),           
                     R(Load.getAddress(P(p))), Load.getOffset(P(p)), 
                     Load.getLocation(P(p)), Load.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 258:
   * r: LONG_LOAD(REF_ADD(r,r),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code258(AbstractBURS_TreeNode p) {
    EMIT(MIR_Load.mutate(P(p), PPC_LAddrX, Load.getResult(P(p)),           
                              R(Binary.getClearVal1(PL(p))), Binary.getClearVal2(PL(p)), 
                              Load.getLocation(P(p)), Load.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 259:
   * r: LONG_LOAD(REF_ADD(r,INT_CONSTANT),INT_CONSTANT)
   * @param p BURS node to apply the rule to
   */
  private void code259(AbstractBURS_TreeNode p) {
    EMIT(MIR_Load.mutate(P(p), PPC_LAddr, Load.getResult(P(p)),            
                              R(Binary.getClearVal1(PL(p))), IC(VR(p)+VLR(p)), 
                              Load.getLocation(P(p)), Load.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 260:
   * stm: LONG_STORE(r,OTHER_OPERAND(r,INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code260(AbstractBURS_TreeNode p) {
    EMIT(MIR_Store.mutate(P(p), PPC_STAddr, R(Store.getValue(P(p))),        
                               R(Store.getAddress(P(p))),                     
                               Store.getOffset(P(p)),                         
                               Store.getLocation(P(p)),                       
                               Store.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 261:
   * stm: LONG_STORE(r,OTHER_OPERAND(r,REF_MOVE(ADDRESS_CONSTANT)))
   * @param p BURS node to apply the rule to
   */
  private void code261(AbstractBURS_TreeNode p) {
    {                                                                             
   Address val = AV(Move.getVal(PRR(p)));                                     
   EMIT(MIR_Binary.create(PPC_ADDIS, Move.getResult(PRR(p)).copyRO(),         
                          R(Store.getClearAddress(P(p))), CAU16(val)));            
   EMIT(MIR_Store.mutate(P(p), PPC_STAddr, R(Store.getValue(P(p))),     
                                  Move.getClearResult(PRR(p)), CAL16(val),
                                  Store.getLocation(P(p)),                    
                                  Store.getGuard(P(p))));                    
}
  }

  /**
   * Emit code for rule number 262:
   * stm: LONG_STORE(r,OTHER_OPERAND(r,r))
   * @param p BURS node to apply the rule to
   */
  private void code262(AbstractBURS_TreeNode p) {
    EMIT(MIR_Store.mutate(P(p), PPC_STAddrX, R(Store.getValue(P(p))),       
                               R(Store.getAddress(P(p))),                     
                               Store.getOffset(P(p)),                         
                               Store.getLocation(P(p)),                       
                               Store.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 263:
   * stm: LONG_STORE(r,OTHER_OPERAND(REF_ADD(r,INT_CONSTANT),INT_CONSTANT))
   * @param p BURS node to apply the rule to
   */
  private void code263(AbstractBURS_TreeNode p) {
    EMIT(MIR_Store.mutate(P(p), PPC_STAddr, R(Store.getValue(P(p))),        
                               R(Binary.getClearVal1(PRL(p))),                     
                               IC(VRR(p) + VRLR(p)), 
                               Store.getLocation(P(p)),                       
                               Store.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 264:
   * r:      PREPARE_ADDR(r, r)
   * @param p BURS node to apply the rule to
   */
  private void code264(AbstractBURS_TreeNode p) {
    EMIT(MIR_Load.mutate(P(p), PPC_LAddrARX, Prepare.getResult(P(p)),   
                              R(Prepare.getAddress(P(p))), Prepare.getOffset(P(p)),           
                              Prepare.getLocation(P(p)),                  
                              Prepare.getGuard(P(p))));
  }

  /**
   * Emit code for rule number 265:
   * r:      ATTEMPT_ADDR(r, r)
   * @param p BURS node to apply the rule to
   */
  private void code265(AbstractBURS_TreeNode p) {
    EMIT(P(p));  // Leave for ComplexLIR2MIRExpansion
  }

  /**
   * Emit code using given rule number
   *
   * @param p the tree that's being emitted
   * @param n the non-terminal goal of that tree
   * @param ruleno the rule that will generate the tree
   */
    @Override
  public void code(AbstractBURS_TreeNode p, int  n, int ruleno) {
    switch(unsortedErnMap[ruleno]) {
    case 14: code14(p); break;
    case 15: code15(p); break;
    case 16: code16(p); break;
    case 17: code17(p); break;
    case 18: code18(p); break;
    case 19: code19(p); break;
    case 20: code20(p); break;
    case 21: code21(p); break;
    case 22: code22(p); break;
    case 24: code24(p); break;
    case 25: code25(p); break;
    case 26: code26(p); break;
    case 27: code27(p); break;
    case 28: code28(p); break;
    case 29: code29(p); break;
    case 30: code30(p); break;
    case 31: code31(p); break;
    case 32: code32(p); break;
    case 33: code33(p); break;
    case 34: code34(p); break;
    case 35: code35(p); break;
    case 36: code36(p); break;
    case 37: code37(p); break;
    case 38: code38(p); break;
    case 39: code39(p); break;
    case 40: code40(p); break;
    case 41: code41(p); break;
    case 42: code42(p); break;
    case 43: code43(p); break;
    case 44: code44(p); break;
    case 45: code45(p); break;
    case 46: code46(p); break;
    case 47: code47(p); break;
    case 48: code48(p); break;
    case 49: code49(p); break;
    case 50: code50(p); break;
    case 51: code51(p); break;
    case 52: code52(p); break;
    case 54: code54(p); break;
    case 56: code56(p); break;
    case 57: code57(p); break;
    case 58: code58(p); break;
    case 59: code59(p); break;
    case 60: code60(p); break;
    case 61: code61(p); break;
    case 62: code62(p); break;
    case 63: code63(p); break;
    case 64: code64(p); break;
    case 65: code65(p); break;
    case 66: code66(p); break;
    case 67: code67(p); break;
    case 68: code68(p); break;
    case 69: code69(p); break;
    case 70: code70(p); break;
    case 71: code71(p); break;
    case 72: code72(p); break;
    case 73: code73(p); break;
    case 74: code74(p); break;
    case 75: code75(p); break;
    case 76: code76(p); break;
    case 77: code77(p); break;
    case 78: code78(p); break;
    case 79: code79(p); break;
    case 80: code80(p); break;
    case 81: code81(p); break;
    case 82: code82(p); break;
    case 83: code83(p); break;
    case 84: code84(p); break;
    case 85: code85(p); break;
    case 86: code86(p); break;
    case 87: code87(p); break;
    case 88: code88(p); break;
    case 89: code89(p); break;
    case 90: code90(p); break;
    case 91: code91(p); break;
    case 92: code92(p); break;
    case 93: code93(p); break;
    case 94: code94(p); break;
    case 95: code95(p); break;
    case 96: code96(p); break;
    case 97: code97(p); break;
    case 98: code98(p); break;
    case 99: code99(p); break;
    case 100: code100(p); break;
    case 101: code101(p); break;
    case 102: code102(p); break;
    case 103: code103(p); break;
    case 104: code104(p); break;
    case 105: code105(p); break;
    case 106: code106(p); break;
    case 107: code107(p); break;
    case 108: code108(p); break;
    case 109: code109(p); break;
    case 110: code110(p); break;
    case 111: code111(p); break;
    case 112: code112(p); break;
    case 113: code113(p); break;
    case 114: code114(p); break;
    case 115: code115(p); break;
    case 116: code116(p); break;
    case 117: code117(p); break;
    case 118: code118(p); break;
    case 119: code119(p); break;
    case 120: code120(p); break;
    case 121: code121(p); break;
    case 122: code122(p); break;
    case 123: code123(p); break;
    case 124: code124(p); break;
    case 125: code125(p); break;
    case 126: code126(p); break;
    case 127: code127(p); break;
    case 128: code128(p); break;
    case 129: code129(p); break;
    case 130: code130(p); break;
    case 131: code131(p); break;
    case 132: code132(p); break;
    case 133: code133(p); break;
    case 134: code134(p); break;
    case 135: code135(p); break;
    case 136: code136(p); break;
    case 137: code137(p); break;
    case 138: code138(p); break;
    case 139: code139(p); break;
    case 140: code140(p); break;
    case 141: code141(p); break;
    case 142: code142(p); break;
    case 143: code143(p); break;
    case 144: code144(p); break;
    case 145: code145(p); break;
    case 146: code146(p); break;
    case 147: code147(p); break;
    case 148: code148(p); break;
    case 149: code149(p); break;
    case 150: code150(p); break;
    case 151: code151(p); break;
    case 152: code152(p); break;
    case 153: code153(p); break;
    case 154: code154(p); break;
    case 155: code155(p); break;
    case 156: code156(p); break;
    case 157: code157(p); break;
    case 158: code158(p); break;
    case 159: code159(p); break;
    case 160: code160(p); break;
    case 161: code161(p); break;
    case 162: code162(p); break;
    case 163: code163(p); break;
    case 164: code164(p); break;
    case 165: code165(p); break;
    case 166: code166(p); break;
    case 167: code167(p); break;
    case 168: code168(p); break;
    case 169: code169(p); break;
    case 170: code170(p); break;
    case 171: code171(p); break;
    case 172: code172(p); break;
    case 173: code173(p); break;
    case 174: code174(p); break;
    case 175: code175(p); break;
    case 176: code176(p); break;
    case 177: code177(p); break;
    case 178: code178(p); break;
    case 179: code179(p); break;
    case 180: code180(p); break;
    case 181: code181(p); break;
    case 182: code182(p); break;
    case 183: code183(p); break;
    case 184: code184(p); break;
    case 185: code185(p); break;
    case 186: code186(p); break;
    case 187: code187(p); break;
    case 188: code188(p); break;
    case 189: code189(p); break;
    case 190: code190(p); break;
    case 191: code191(p); break;
    case 192: code192(p); break;
    case 193: code193(p); break;
    case 194: code194(p); break;
    case 195: code195(p); break;
    case 196: code196(p); break;
    case 197: code197(p); break;
    case 198: code198(p); break;
    case 199: code199(p); break;
    case 200: code200(p); break;
    case 201: code201(p); break;
    case 202: code202(p); break;
    case 203: code203(p); break;
    case 204: code204(p); break;
    case 205: code205(p); break;
    case 206: code206(p); break;
    case 207: code207(p); break;
    case 208: code208(p); break;
    case 209: code209(p); break;
    case 210: code210(p); break;
    case 211: code211(p); break;
    case 212: code212(p); break;
    case 213: code213(p); break;
    case 215: code215(p); break;
    case 216: code216(p); break;
    case 217: code217(p); break;
    case 218: code218(p); break;
    case 219: code219(p); break;
    case 220: code220(p); break;
    case 221: code221(p); break;
    case 222: code222(p); break;
    case 223: code223(p); break;
    case 224: code224(p); break;
    case 225: code225(p); break;
    case 226: code226(p); break;
    case 227: code227(p); break;
    case 228: code228(p); break;
    case 229: code229(p); break;
    case 230: code230(p); break;
    case 231: code231(p); break;
    case 232: code232(p); break;
    case 233: code233(p); break;
    case 234: code234(p); break;
    case 235: code235(p); break;
    case 236: code236(p); break;
    case 237: code237(p); break;
    case 238: code238(p); break;
    case 239: code239(p); break;
    case 240: code240(p); break;
    case 241: code241(p); break;
    case 242: code242(p); break;
    case 243: code243(p); break;
    case 244: code244(p); break;
    case 245: code245(p); break;
    case 246: code246(p); break;
    case 247: code247(p); break;
    case 248: code248(p); break;
    case 249: code249(p); break;
    case 250: code250(p); break;
    case 251: code251(p); break;
    case 252: code252(p); break;
    case 253: code253(p); break;
    case 254: code254(p); break;
    case 255: code255(p); break;
    case 256: code256(p); break;
    case 257: code257(p); break;
    case 258: code258(p); break;
    case 259: code259(p); break;
    case 260: code260(p); break;
    case 261: code261(p); break;
    case 262: code262(p); break;
    case 263: code263(p); break;
    case 264: code264(p); break;
    case 265: code265(p); break;
    default:
      throw new OptimizingCompilerException("BURS", "rule " + ruleno + " without emit code:",
        BURS_Debug.string[unsortedErnMap[ruleno]]);
    }
  }
}
